R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.55 ## cost to the democrats#
costR<- 0.55 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 0 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  particmatrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities#
#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	} #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	particmatrixj<-list(particmatrixj,actions)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
meanparticipation<-(voteRts+voteDts)/2#
#
voteDts[nPeriods]#
voteRts[nPeriods]#
mean(actions) ## For last election only#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
#
##Voting Trends#
particframej <- data.frame(matrix(unlist(list(particmatrixj)), nrow=n, byrow=TRUE))#
particSums<- colSums(particframej)#
particMeans<- colMeans(particframej)#
mean(particMeans) ## Mean of Actions over all j elections#
partictotalvotes<-rowSums(particframej)#
#
## Plots#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes")#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes")#
plot(elections, particMeans, cex=.3, xlab="Elections", ylab="Mean Participation")
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.55 ## cost to the democrats#
costR<- 0.55 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  particmatrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities#
#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	} #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	particmatrixj<-list(particmatrixj,actions)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
meanparticipation<-(voteRts+voteDts)/2#
#
voteDts[nPeriods]#
voteRts[nPeriods]#
mean(actions) ## For last election only#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
#
##Voting Trends#
particframej <- data.frame(matrix(unlist(list(particmatrixj)), nrow=n, byrow=TRUE))#
particSums<- colSums(particframej)#
particMeans<- colMeans(particframej)#
mean(particMeans) ## Mean of Actions over all j elections#
partictotalvotes<-rowSums(particframej)#
#
## Plots#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes")#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes")#
plot(elections, particMeans, cex=.3, xlab="Elections", ylab="Mean Participation")
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.55 ## cost to the democrats#
costR<- 0.55 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 0 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  particmatrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities#
#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	} #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	particmatrixj<-list(particmatrixj,actions)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
meanparticipation<-(voteRts+voteDts)/2#
#
voteDts[nPeriods]#
voteRts[nPeriods]#
mean(actions) ## For last election only#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
#
##Voting Trends#
particframej <- data.frame(matrix(unlist(list(particmatrixj)), nrow=n, byrow=TRUE))#
particSums<- colSums(particframej)#
particMeans<- colMeans(particframej)#
mean(particMeans) ## Mean of Actions over all j elections#
partictotalvotes<-rowSums(particframej)#
#
## Plots#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes")#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes")#
plot(elections, particMeans, cex=.3, xlab="Elections", ylab="Mean Participation")
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.8 ## cost to the democrats#
costR<- 0.8 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  particmatrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities#
#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	} #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	particmatrixj<-list(particmatrixj,actions)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
meanparticipation<-(voteRts+voteDts)/2#
#
voteDts[nPeriods]#
voteRts[nPeriods]#
mean(actions) ## For last election only#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
#
##Voting Trends#
particframej <- data.frame(matrix(unlist(list(particmatrixj)), nrow=n, byrow=TRUE))#
particSums<- colSums(particframej)#
particMeans<- colMeans(particframej)#
mean(particMeans) ## Mean of Actions over all j elections#
partictotalvotes<-rowSums(particframej)#
#
## Plots#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes")#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes")#
plot(elections, particMeans, cex=.3, xlab="Elections", ylab="Mean Participation")
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.9 ## cost to the democrats#
costR<- 0.9 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  particmatrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities#
#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	} #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	particmatrixj<-list(particmatrixj,actions)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
meanparticipation<-(voteRts+voteDts)/2#
#
voteDts[nPeriods]#
voteRts[nPeriods]#
mean(actions) ## For last election only#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
#
##Voting Trends#
particframej <- data.frame(matrix(unlist(list(particmatrixj)), nrow=n, byrow=TRUE))#
particSums<- colSums(particframej)#
particMeans<- colMeans(particframej)#
mean(particMeans) ## Mean of Actions over all j elections#
partictotalvotes<-rowSums(particframej)#
#
## Plots#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes")#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes")#
plot(elections, particMeans, cex=.3, xlab="Elections", ylab="Mean Participation")
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.95 ## cost to the democrats#
costR<- 0.95 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  particmatrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities#
#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	} #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	particmatrixj<-list(particmatrixj,actions)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
meanparticipation<-(voteRts+voteDts)/2#
#
voteDts[nPeriods]#
voteRts[nPeriods]#
mean(actions) ## For last election only#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
#
##Voting Trends#
particframej <- data.frame(matrix(unlist(list(particmatrixj)), nrow=n, byrow=TRUE))#
particSums<- colSums(particframej)#
particMeans<- colMeans(particframej)#
mean(particMeans) ## Mean of Actions over all j elections#
partictotalvotes<-rowSums(particframej)#
#
## Plots#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes")#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes")#
plot(elections, particMeans, cex=.3, xlab="Elections", ylab="Mean Participation")
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  particmatrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities#
#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	} #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	particmatrixj<-list(particmatrixj,actions)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
meanparticipation<-(voteRts+voteDts)/2#
#
voteDts[nPeriods]#
voteRts[nPeriods]#
mean(actions) ## For last election only#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
#
##Voting Trends#
particframej <- data.frame(matrix(unlist(list(particmatrixj)), nrow=n, byrow=TRUE))#
particSums<- colSums(particframej)#
particMeans<- colMeans(particframej)#
mean(particMeans) ## Mean of Actions over all j elections#
partictotalvotes<-rowSums(particframej)#
#
## Plots#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes")#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes")#
plot(elections, particMeans, cex=.3, xlab="Elections", ylab="Mean Participation")
meanParticipation
meanparticipation
mean(meanparticipation)
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  particmatrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities#
#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	} #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	particmatrixj<-list(particmatrixj,actions)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
meanparticipation<-(voteRts+voteDts)/2#
#
voteDts[nPeriods]#
voteRts[nPeriods]#
mean(actions) ## For last election only#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
#
##Voting Trends [Play with this]#
particframej <- data.frame(matrix(unlist(list(particmatrixj)), nrow=n, byrow=TRUE))#
particSums<- colSums(particframej)#
particMeans<- colMeans(particframej)#
mean(particMeans) ## Mean of Actions over all j elections#
partictotalvotes<-rowSums(particframej)#
#
## Plots#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes")#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes")#
plot(elections, particMeans, cex=.3, xlab="Elections", ylab="Mean Participation")
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  particmatrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities#
#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	} #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
meanparticipation<-(voteRts+voteDts)/2#
#
voteDts[nPeriods]#
voteRts[nPeriods]#
mean(actions) ## For last election only#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
#
## Plots#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes")#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes")
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  particmatrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities#
#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	} #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
meanparticipation<-(voteRts+voteDts)/2#
#
voteDts[nPeriods-7:nPeriods]#
voteRts[nPeriods]#
mean(actions) ## For last election only#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
#
## Plots#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes")#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes")
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  particmatrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities#
#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	} #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
meanparticipation<-(voteRts+voteDts)/2#
#
mean(voteDts[nPeriods])#
voteRts[nPeriods]#
mean(actions) ## For last election only#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
#
## Plots#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes")#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes")
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  particmatrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities#
#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	} #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
meanparticipation<-(voteRts+voteDts)/2#
#
mean(voteDts[nPeriods])#
voteDts[nPeriods]#
voteRts[nPeriods]#
mean(actions) ## For last election only#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
#
## Plots#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes")#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes")
voteD
voteR
mean(voteDts)
voteDts
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  rmatrixj<-matrix(nrow=(0), ncol=(0))#
  dmatrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
    meanvoteDts<-mean(voteDts)#
    meanvoteRts<-mean(voteRts)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	rmatrixj<- list(rmatrixj, meanvoteRts)#
	dmatrixj<- list(dmatrixj, meanvoteDts)#
	}#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
meanparticipation<-(voteRts+voteDts)/2#
#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## For last election only#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
#
## Plots#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes")#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes")
rmatrixj
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  rmatrixj<-matrix(nrow=(0), ncol=(0))#
  dmatrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
    meanvoteDts<-mean(voteDts)#
    meanvoteRts<-mean(voteRts)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
	rmatrixj<- list(rmatrixj, meanvoteRts)#
	dmatrixj<- list(dmatrixj, meanvoteDts)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
meanparticipation<-(voteRts+voteDts)/2#
#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## For last election only#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
#
## Plots#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes")#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes")
rmatrixj
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  rmatrixj<-matrix(nrow=(0), ncol=(0))#
  dmatrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
    meanvoteDts<-mean(voteDts)#
    meanvoteRts<-mean(voteRts)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
	rmatrixj<- list(rmatrixj, meanvoteRts)#
	dmatrixj<- list(dmatrixj, meanvoteDts)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
meanparticipation<-(voteRts+voteDts)/2#
#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## For last election only#
mean(rmatrixj)#
mean(dmatrixj)#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
#
## Plots#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes")#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes")
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  rmatrixj<-matrix(nrow=(0), ncol=(0))#
  dmatrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
    meanvoteDts<-mean(voteDts)#
    meanvoteRts<-mean(voteRts)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
	rmatrixj<- list(rmatrixj, meanvoteRts)#
	dmatrixj<- list(dmatrixj, meanvoteDts)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
meanparticipation<-(voteRts+voteDts)/2#
#
rframej <- data.frame(matrix(unlist(list(rmatrixj)), nrow=n, byrow=TRUE))#
dframej <- data.frame(matrix(unlist(list(dmatrixj)), nrow=n, byrow=TRUE))#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## For last election only#
mean(rmatrixj)#
mean(dmatrixj)#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
#
## Plots#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes")#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes")
rmatrixj
rframej
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  rmatrixj<-matrix(nrow=(0), ncol=(0))#
  dmatrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
    meanvoteDts<-mean(voteDts)#
    meanvoteRts<-mean(voteRts)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
	rmatrixj<- list(rmatrixj, meanvoteRts)#
	dmatrixj<- list(dmatrixj, meanvoteDts)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
meanparticipation<-(voteRts+voteDts)/2#
#
rframej <- data.frame(matrix(unlist(list(rmatrixj)), nrow=n, byrow=FALSE))#
dframej <- data.frame(matrix(unlist(list(dmatrixj)), nrow=n, byrow=FALSE))#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## For last election only#
mean(rmatrixj)#
mean(dmatrixj)#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
#
## Plots#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes")#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes")
rmatrixj
rframej
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  rmatrixj<-matrix(nrow=(0), ncol=(0))#
  dmatrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
    meanvoteDts<-mean(voteDts)#
    meanvoteRts<-mean(voteRts)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
	rmatrixj<- list(rmatrixj, meanvoteRts)#
	dmatrixj<- list(dmatrixj, meanvoteDts)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
meanparticipation<-(voteRts+voteDts)/2#
#
rframej <- data.frame(matrix(unlist(list(rmatrixj)), nrow=nPeriods, byrow=TRUE))#
dframej <- data.frame(matrix(unlist(list(dmatrixj)), nrow=nPeriods, byrow=TRUE))#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## For last election only#
mean(rmatrixj)#
mean(dmatrixj)#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
#
## Plots#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes")#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes")
rframej
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  rmatrixj<-matrix(nrow=(0), ncol=(0))#
  dmatrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
    meanvoteDts<-mean(voteDts)#
    meanvoteRts<-mean(voteRts)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
	rmatrixj<- list(rmatrixj, meanvoteRts)#
	dmatrixj<- list(dmatrixj, meanvoteDts)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
meanparticipation<-(voteRts+voteDts)/2#
#
rframej <- data.frame(matrix(unlist(list(rmatrixj)), nrow=nPeriods, byrow=TRUE))#
dframej <- data.frame(matrix(unlist(list(dmatrixj)), nrow=nPeriods, byrow=TRUE))#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## For last election only#
colMeans(rmatrixj)#
colMeans(dmatrixj)#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
#
## Plots#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes")#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes")
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  rmatrixj<-matrix(nrow=(0), ncol=(0))#
  dmatrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
    meanvoteDts<-mean(voteDts)#
    meanvoteRts<-mean(voteRts)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
	rmatrixj<- list(rmatrixj, meanvoteRts)#
	dmatrixj<- list(dmatrixj, meanvoteDts)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
meanparticipation<-(voteRts+voteDts)/2#
#
rframej <- data.frame(matrix(unlist(list(rmatrixj)), nrow=nPeriods, byrow=TRUE))#
dframej <- data.frame(matrix(unlist(list(dmatrixj)), nrow=nPeriods, byrow=TRUE))#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## For last election only#
rowMeans(rmatrixj)#
rowMeans(dmatrixj)#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
#
## Plots#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes")#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes")
rframej
sum(rframej[1])
mean(rframej[1])
mean(rmatrixj[1])
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  ##rmatrixj<-matrix(nrow=(0), ncol=(0))#
  ##dmatrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
    ##meanvoteDts<-mean(voteDts)#
    ##meanvoteRts<-mean(voteRts)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
	##rmatrixj<- list(rmatrixj, meanvoteRts)#
	##dmatrixj<- list(dmatrixj, meanvoteDts)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
meanparticipation<-(voteRts+voteDts)/2#
#
rframej <- data.frame(matrix(unlist(list(rmatrixj)), nrow=nPeriods, byrow=TRUE))#
dframej <- data.frame(matrix(unlist(list(dmatrixj)), nrow=nPeriods, byrow=TRUE))#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## For last election only#
## rowMeans(rmatrixj)#
## rowMeans(dmatrixj)#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
#
## Plots#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes")#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes")
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  ##rmatrixj<-matrix(nrow=(0), ncol=(0))#
  ##dmatrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
    ##meanvoteDts<-mean(voteDts)#
    ##meanvoteRts<-mean(voteRts)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
	##rmatrixj<- list(rmatrixj, meanvoteRts)#
	##dmatrixj<- list(dmatrixj, meanvoteDts)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
meanparticipation<-(voteRts+voteDts)/2#
#
## rframej <- data.frame(matrix(unlist(list(rmatrixj)), nrow=nPeriods, byrow=TRUE))#
## dframej <- data.frame(matrix(unlist(list(dmatrixj)), nrow=nPeriods, byrow=TRUE))#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## For last election only#
## rowMeans(rmatrixj)#
## rowMeans(dmatrixj)#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
#
## Plots#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes")#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes")
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  ##rmatrixj<-matrix(nrow=(0), ncol=(0))#
  ##dmatrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
    ##meanvoteDts<-mean(voteDts)#
    ##meanvoteRts<-mean(voteRts)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
	##rmatrixj<- list(rmatrixj, meanvoteRts)#
	##dmatrixj<- list(dmatrixj, meanvoteDts)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
meanparticipation<-(voteRts+voteDts)/2#
#
## rframej <- data.frame(matrix(unlist(list(rmatrixj)), nrow=nPeriods, byrow=TRUE))#
## dframej <- data.frame(matrix(unlist(list(dmatrixj)), nrow=nPeriods, byrow=TRUE))#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## For last election only#
## rowMeans(rmatrixj)#
## rowMeans(dmatrixj)#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
#
## Plots#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot((elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes", col="Red"), (elections, voteDts))#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes")
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  ##rmatrixj<-matrix(nrow=(0), ncol=(0))#
  ##dmatrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
    ##meanvoteDts<-mean(voteDts)#
    ##meanvoteRts<-mean(voteRts)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
	##rmatrixj<- list(rmatrixj, meanvoteRts)#
	##dmatrixj<- list(dmatrixj, meanvoteDts)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
meanparticipation<-(voteRts+voteDts)/2#
#
## rframej <- data.frame(matrix(unlist(list(rmatrixj)), nrow=nPeriods, byrow=TRUE))#
## dframej <- data.frame(matrix(unlist(list(dmatrixj)), nrow=nPeriods, byrow=TRUE))#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## For last election only#
## rowMeans(rmatrixj)#
## rowMeans(dmatrixj)#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
#
## Plots#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot((elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes", col="Red") (elections, voteDts))#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes")
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  ##rmatrixj<-matrix(nrow=(0), ncol=(0))#
  ##dmatrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
    ##meanvoteDts<-mean(voteDts)#
    ##meanvoteRts<-mean(voteRts)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
	##rmatrixj<- list(rmatrixj, meanvoteRts)#
	##dmatrixj<- list(dmatrixj, meanvoteDts)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
meanparticipation<-(voteRts+voteDts)/2#
#
## rframej <- data.frame(matrix(unlist(list(rmatrixj)), nrow=nPeriods, byrow=TRUE))#
## dframej <- data.frame(matrix(unlist(list(dmatrixj)), nrow=nPeriods, byrow=TRUE))#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## For last election only#
## rowMeans(rmatrixj)#
## rowMeans(dmatrixj)#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
#
## Plots#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot((elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes" col="Red") (elections, voteDts))#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes")
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  ##rmatrixj<-matrix(nrow=(0), ncol=(0))#
  ##dmatrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
    ##meanvoteDts<-mean(voteDts)#
    ##meanvoteRts<-mean(voteRts)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
	##rmatrixj<- list(rmatrixj, meanvoteRts)#
	##dmatrixj<- list(dmatrixj, meanvoteDts)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
meanparticipation<-(voteRts+voteDts)/2#
#
## rframej <- data.frame(matrix(unlist(list(rmatrixj)), nrow=nPeriods, byrow=TRUE))#
## dframej <- data.frame(matrix(unlist(list(dmatrixj)), nrow=nPeriods, byrow=TRUE))#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## For last election only#
## rowMeans(rmatrixj)#
## rowMeans(dmatrixj)#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
#
## Plots#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes")#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes")
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  ##rmatrixj<-matrix(nrow=(0), ncol=(0))#
  ##dmatrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
    ##meanvoteDts<-mean(voteDts)#
    ##meanvoteRts<-mean(voteRts)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
	##rmatrixj<- list(rmatrixj, meanvoteRts)#
	##dmatrixj<- list(dmatrixj, meanvoteDts)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
meanparticipation<-(voteRts+voteDts)/2#
#
## rframej <- data.frame(matrix(unlist(list(rmatrixj)), nrow=nPeriods, byrow=TRUE))#
## dframej <- data.frame(matrix(unlist(list(dmatrixj)), nrow=nPeriods, byrow=TRUE))#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## For last election only#
## rowMeans(rmatrixj)#
## rowMeans(dmatrixj)#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
#
## Plots#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes")#
par(new=T)#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes")#
par(new=F)
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  ##rmatrixj<-matrix(nrow=(0), ncol=(0))#
  ##dmatrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
    ##meanvoteDts<-mean(voteDts)#
    ##meanvoteRts<-mean(voteRts)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
	##rmatrixj<- list(rmatrixj, meanvoteRts)#
	##dmatrixj<- list(dmatrixj, meanvoteDts)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
meanparticipation<-(voteRts+voteDts)/2#
#
## rframej <- data.frame(matrix(unlist(list(rmatrixj)), nrow=nPeriods, byrow=TRUE))#
## dframej <- data.frame(matrix(unlist(list(dmatrixj)), nrow=nPeriods, byrow=TRUE))#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## For last election only#
## rowMeans(rmatrixj)#
## rowMeans(dmatrixj)#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
#
## Plots#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes")#
par(new=T)#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes", col="Red")#
par(new=F)
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  ##rmatrixj<-matrix(nrow=(0), ncol=(0))#
  ##dmatrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
    ##meanvoteDts<-mean(voteDts)#
    ##meanvoteRts<-mean(voteRts)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
	##rmatrixj<- list(rmatrixj, meanvoteRts)#
	##dmatrixj<- list(dmatrixj, meanvoteDts)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
meanparticipation<-(voteRts+voteDts)/2#
#
## rframej <- data.frame(matrix(unlist(list(rmatrixj)), nrow=nPeriods, byrow=TRUE))#
## dframej <- data.frame(matrix(unlist(list(dmatrixj)), nrow=nPeriods, byrow=TRUE))#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## For last election only#
## rowMeans(rmatrixj)#
## rowMeans(dmatrixj)#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
#
## Plots#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes", col="Red")#
par(new=T)#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes", col="Blue")#
par(new=F)
help packages
installed.packages
library()
install.packages("ggplot2")
library()
install.packages("shiny")
library()
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=FALSE))#
primarySums<- colSums(primaryframej) ## Participation in Primary#
primaryMeans<- colMeans(primaryframej) ## Participation Rate#
primaryMeans#
nPeriodthPrimaryMean<-primaryMeans[7]#
nPeriodthPrimaryMean#
primarytotalvotes<-rowSums(primaryframej) ## Individual Participation by number of votes#
primaryparticipation<-table(primarytotalvotes) ## Summary of number of times respondents voted#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
## meanparticipation<-(voteRts+voteDts)/2 ## For each of nPeriods#
#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## Voting rate for last election only#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
#
## Plots#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes", col="Red")#
##par(new=T)#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes", col="Blue")#
##par(new=F)#
#
sum(actions)#
primarySums[7]
actions
primaryframej[7]
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primarySums<- colSums(primaryframej) ## Participation in Primary#
primaryMeans<- colMeans(primaryframej) ## Participation Rate#
primaryMeans#
nPeriodthPrimaryMean<-primaryMeans[7]#
nPeriodthPrimaryMean#
primarytotalvotes<-rowSums(primaryframej) ## Individual Participation by number of votes#
primaryparticipation<-table(primarytotalvotes) ## Summary of number of times respondents voted#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
## meanparticipation<-(voteRts+voteDts)/2 ## For each of nPeriods#
#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## Voting rate for last election only#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
#
## Plots#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes", col="Red")#
##par(new=T)#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes", col="Blue")#
##par(new=F)#
#
sum(actions)#
primarySums[7]
meanparticipation<-(voteRts+voteDts)/2 ## For each of nPeriods
meanparticipation
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primarySums<- colSums(primaryframej) ## Participation in Primary#
primaryMeans<- colMeans(primaryframej) ## Participation Rate#
primaryMeans#
nPeriodthPrimaryMean<-primaryMeans[7]#
nPeriodthPrimaryMean#
primarytotalvotes<-rowSums(primaryframej) ## Individual Participation by number of votes#
primaryparticipation<-table(primarytotalvotes) ## Summary of number of times respondents voted#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
## meanparticipation<-(voteRts+voteDts)/2 ## For each of nPeriods#
#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## Voting rate for last election only#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
#
## Plots#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes", col="Red")#
##par(new=T)#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes", col="Blue")#
##par(new=F)#
#
sum(actions)#
primarySums[7]
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primarySums<- colSums(primaryframej) ## Participation in Primary#
primaryMeans<- colMeans(primaryframej) ## Participation Rate#
## primaryMeans#
nPeriodthPrimaryMean<-primaryMeans[7]#
nPeriodthPrimaryMean#
#
primaryIndVotes<-rowSums(primaryframej) ## Individual Participation by number of votes#
primaryIndParticipation<-table(primaryIndVotes) ## Summary of number of times respondents voted#
primaryIndParticipation#
barplot(primaryIndParticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
## meanparticipation<-(voteRts+voteDts)/2 ## For each of nPeriods#
#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## Voting rate for last election only#
#
##Habitual Voting Behavior#
primaryHabitual<-(((primaryIndParticipation["0"])+(primaryIndParticipation["7"]))/n)#
primaryHabitual#
#
## Plots#
% par(mfrow=c(2,2))#
% barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
% plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes", col="Red")#
% ##par(new=T)#
% plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes", col="Blue")#
##par(new=F)#
#
sum(actions)#
primarySums[7]
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primarySums<- colSums(primaryframej) ## Participation in Primary#
primaryMeans<- colMeans(primaryframej) ## Participation Rate#
## primaryMeans#
nPeriodthPrimaryMean<-primaryMeans[7]#
nPeriodthPrimaryMean#
#
primaryIndVotes<-rowSums(primaryframej) ## Individual Participation by number of votes#
primaryIndParticipation<-table(primaryIndVotes) ## Summary of number of times respondents voted#
primaryIndParticipation#
## barplot(primaryIndParticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
## meanparticipation<-(voteRts+voteDts)/2 ## For each of nPeriods#
#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## Voting rate for last election only#
#
##Habitual Voting Behavior#
primaryHabitual<-(((primaryIndParticipation["0"])+(primaryIndParticipation["7"]))/n)#
primaryHabitual#
#
## Plots#
## par(mfrow=c(2,2))#
## barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
## plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes", col="Red")#
##par(new=T)#
## plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes", col="Blue")#
##par(new=F)#
#
sum(actions)#
primarySums[7]
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primarySums<- colSums(primaryframej) ## Participation in Primary#
primaryMeans<- colMeans(primaryframej) ## Participation Rate#
## primaryMeans#
nPeriodthPrimaryMean<-primaryMeans[7]#
nPeriodthPrimaryMean#
#
primaryIndVotes<-rowSums(primaryframej) ## Individual Participation by number of votes#
primaryIndParticipation<-table(primaryIndVotes) ## Summary of number of times respondents voted (mode)#
primaryIndParticipation#
## barplot(primaryIndParticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
## meanparticipation<-(voteRts+voteDts)/2 ## For each of nPeriods#
#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## Voting rate for last election only#
#
##Habitual Voting Behavior#
primaryHabitual<-(((primaryIndParticipation["0"])+(primaryIndParticipation["7"]))/n)#
primaryHabitual#
#
## Plots#
## par(mfrow=c(2,2))#
## barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
## plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes", col="Red")#
##par(new=T)#
## plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes", col="Blue")#
##par(new=F)#
#
sum(actions)#
primarySums[7]
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primarySums<- colSums(primaryframej) ## Participation in Primary#
primaryMeans<- colMeans(primaryframej) ## Participation Rate#
## primaryMeans#
nPeriodthPrimaryMean<-primaryMeans[7]#
nPeriodthPrimaryMean#
#
primaryIndVotes<-rowSums(primaryframej) ## Individual Participation by number of votes#
primaryIndParticipation<-table(primaryIndVotes) ## Summary of number of times respondents voted (mode)#
primaryIndParticipation#
## barplot(primaryIndParticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
## meanparticipation<-(voteRts+voteDts)/2 ## For each of nPeriods#
#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## Voting rate for last election only#
#
##Habitual Voting Behavior#
primaryHabitual<-(((primaryIndParticipation["0"])+(primaryIndParticipation["7"]))/n)#
primaryHabitual#
#
## Plots#
## par(mfrow=c(2,2))#
## barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
## plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes", col="Red")#
##par(new=T)#
## plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes", col="Blue")#
##par(new=F)#
#
sum(actions)#
primarySums[7]#
##}
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-10 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  votematrixi<-matrix(nrow=(0), ncol=(0))#
  habitmatrixi<-matrix(nrow=(0), ncol=(0))#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primarySums<- colSums(primaryframej) ## Participation in Primary#
primaryMeans<- colMeans(primaryframej) ## Participation Rate#
## primaryMeans#
nPeriodthPrimaryMean<-primaryMeans[7]#
nPeriodthPrimaryMean#
#
primaryIndVotes<-rowSums(primaryframej) ## Individual Participation by number of votes#
primaryIndParticipation<-table(primaryIndVotes) ## Summary of number of times respondents voted (mode)#
primaryIndParticipation#
## barplot(primaryIndParticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
## meanparticipation<-(voteRts+voteDts)/2 ## For each of nPeriods#
#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## Voting rate for last election only#
#
##Habitual Voting Behavior#
primaryHabitual<-(((primaryIndParticipation["0"])+(primaryIndParticipation["7"]))/n) ## For consistent voters and abstainers#
primaryHabitual#
#
## Plots#
## par(mfrow=c(2,2))#
## barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
## plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes", col="Red")#
##par(new=T)#
## plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes", col="Blue")#
##par(new=F)#
#
sum(actions)#
primarySums[7]#
#
votematrixi<- list(votematrixi, mean(actions))#
habitmatrixi<- list(habitmatrixi, primaryHabitual)#
}
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-10 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  votematrixi<-matrix(nrow=(0), ncol=(0))#
  habitmatrixi<-matrix(nrow=(0), ncol=(0))#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primarySums<- colSums(primaryframej) ## Participation in Primary#
primaryMeans<- colMeans(primaryframej) ## Participation Rate#
## primaryMeans#
nPeriodthPrimaryMean<-primaryMeans[7]#
nPeriodthPrimaryMean#
#
primaryIndVotes<-rowSums(primaryframej) ## Individual Participation by number of votes#
primaryIndParticipation<-table(primaryIndVotes) ## Summary of number of times respondents voted (mode)#
primaryIndParticipation#
## barplot(primaryIndParticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
## meanparticipation<-(voteRts+voteDts)/2 ## For each of nPeriods#
#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## Voting rate for last election only#
#
##Habitual Voting Behavior#
primaryHabitual<-(((primaryIndParticipation["0"])+(primaryIndParticipation["7"]))/n) ## For consistent voters and abstainers#
primaryHabitual#
#
## Plots#
## par(mfrow=c(2,2))#
## barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
## plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes", col="Red")#
##par(new=T)#
## plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes", col="Blue")#
##par(new=F)#
#
sum(actions)#
primarySums[7]#
#
votematrixi<- list(votematrixi, mean(actions))#
habitmatrixi<- list(habitmatrixi, primaryHabitual)#
}
votematrixi
habitmatrixi
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-10 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
votematrixi<-matrix(nrow=(0), ncol=(0))#
habitmatrixi<-matrix(nrow=(0), ncol=(0))#
#
for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primarySums<- colSums(primaryframej) ## Participation in Primary#
primaryMeans<- colMeans(primaryframej) ## Participation Rate#
## primaryMeans#
nPeriodthPrimaryMean<-primaryMeans[7]#
nPeriodthPrimaryMean#
#
primaryIndVotes<-rowSums(primaryframej) ## Individual Participation by number of votes#
primaryIndParticipation<-table(primaryIndVotes) ## Summary of number of times respondents voted (mode)#
primaryIndParticipation#
## barplot(primaryIndParticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
## meanparticipation<-(voteRts+voteDts)/2 ## For each of nPeriods#
#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## Voting rate for last election only#
#
##Habitual Voting Behavior#
primaryHabitual<-(((primaryIndParticipation["0"])+(primaryIndParticipation["7"]))/n) ## For consistent voters and abstainers#
primaryHabitual#
#
## Plots#
## par(mfrow=c(2,2))#
## barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
## plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes", col="Red")#
##par(new=T)#
## plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes", col="Blue")#
##par(new=F)#
#
sum(actions)#
primarySums[7]#
#
votematrixi<- list(votematrixi, mean(actions))#
habitmatrixi<- list(habitmatrixi, primaryHabitual)#
}
votematrixi
habitmatrixi
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-10 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
votematrixi<-matrix(nrow=(0), ncol=(0))#
habitmatrixi<-matrix(nrow=(0), ncol=(0))#
#
for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##Primary Election Data#
primaryVoteFramej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primaryVoteSumsj<- colSums(primaryVoteFramej) ## Participation in Primary#
primaryVoteMeansj<- colMeans(primaryVoteFramej) ## Participation Rate#
## primaryVoteMeansj#
nPeriodthPrimaryMeanj<-primaryVoteMeansj[7]#
nPeriodthPrimaryMeanj#
#
primaryIndVotesj<-rowSums(primaryVoteFramej) ## Individual Participation by number of votes#
primaryIndParticipationj<-table(primaryIndVotesj) ## Summary of number of times respondents voted (mode)#
primaryIndParticipationj#
## barplot(primaryIndParticipationj, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
electionsj<-c(1:nPeriods)#
## meanparticipationj<-(voteRts+voteDts)/2 ## For each of nPeriods#
#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## Voting rate for last election only#
#
##Habitual Voting Behavior#
primaryHabitualj<-(((primaryIndParticipationj["0"])+(primaryIndParticipationj["7"]))/n) ## For consistent voters and abstainers#
primaryHabitualj#
#
## Plots#
## par(mfrow=c(2,2))#
## barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
## plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes", col="Red")#
##par(new=T)#
## plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes", col="Blue")#
##par(new=F)#
#
sum(actions)#
primarySums[7]#
#
votematrixi<- list(votematrixi, mean(actions))#
habitmatrixi<- list(habitmatrixi, primaryHabitualj)#
#
}#
#
primaryVoteFramei <- data.frame(matrix(unlist(list(votematrixi)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primaryHabitFramei <- data.frame(matrix(unlist(list(habitmatrixi)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
#
primaryVoteSumsi<- colSums(primaryVoteFramei) ## Participation in Primary#
primaryVoteMeansi<- colMeans(primaryVoteFramei) ## Participation Rate#
## primaryVoteMeansi#
nPeriodthPrimaryMean<-primaryVoteMeansi[7]#
nPeriodthPrimaryMeani#
#
primaryIndVotes<-rowSums(primaryVoteFramej) ## Individual Participation by number of votes#
primaryIndParticipation<-table(primaryIndVotes) ## Summary of number of times respondents voted (mode)#
primaryIndParticipation#
## barplot(primaryIndParticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
## meanparticipation<-(voteRts+voteDts)/2 ## For each of nPeriods#
#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## Voting rate for last election only#
#
##Habitual Voting Behavior#
primaryHabitual<-(((primaryIndParticipation["0"])+(primaryIndParticipation["7"]))/n) ## For consistent voters and abstainers#
primaryHabitual
primaryVoteFramei
votematrixi
habitmatrixi
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-10 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  votematrixi<-matrix(nrow=(0), ncol=(0))#
  habitmatrixi<-matrix(nrow=(0), ncol=(0))#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##Primary Election Data#
primaryVoteFramej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primaryVoteSumsj<- colSums(primaryVoteFramej) ## Participation in Primary#
primaryVoteMeansj<- colMeans(primaryVoteFramej) ## Participation Rate#
## primaryVoteMeansj#
nPeriodthPrimaryMeanj<-primaryVoteMeansj[7]#
nPeriodthPrimaryMeanj#
#
primaryIndVotesj<-rowSums(primaryVoteFramej) ## Individual Participation by number of votes#
primaryIndParticipationj<-table(primaryIndVotesj) ## Summary of number of times respondents voted (mode)#
primaryIndParticipationj#
## barplot(primaryIndParticipationj, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
electionsj<-c(1:nPeriods)#
## meanparticipationj<-(voteRts+voteDts)/2 ## For each of nPeriods#
#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## Voting rate for last election only#
#
##Habitual Voting Behavior#
primaryHabitualj<-(((primaryIndParticipationj["0"])+(primaryIndParticipationj["7"]))/n) ## For consistent voters and abstainers#
primaryHabitualj#
#
## Plots#
## par(mfrow=c(2,2))#
## barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
## plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes", col="Red")#
##par(new=T)#
## plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes", col="Blue")#
##par(new=F)#
#
sum(actions)#
primarySumsj[7]#
#
votematrixi<- list(votematrixi, mean(actions))#
habitmatrixi<- list(habitmatrixi, primaryHabitualj)#
#
}#
#
primaryVoteFramei <- data.frame(matrix(unlist(list(votematrixi)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primaryHabitFramei <- data.frame(matrix(unlist(list(habitmatrixi)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
#
primaryVoteSumsi<- colSums(primaryVoteFramei) ## Participation in Primary#
primaryVoteMeansi<- colMeans(primaryVoteFramei) ## Participation Rate#
## primaryVoteMeansi#
nPeriodthPrimaryMeani<-primaryVoteMeansi[7]#
nPeriodthPrimaryMeani#
#
primaryIndVotes<-rowSums(primaryVoteFramej) ## Individual Participation by number of votes#
primaryIndParticipation<-table(primaryIndVotes) ## Summary of number of times respondents voted (mode)#
primaryIndParticipation#
## barplot(primaryIndParticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
## meanparticipation<-(voteRts+voteDts)/2 ## For each of nPeriods#
#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## Voting rate for last election only#
#
##Habitual Voting Behavior#
primaryHabitual<-(((primaryIndParticipation["0"])+(primaryIndParticipation["7"]))/n) ## For consistent voters and abstainers#
primaryHabitual
votematrixi
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-10 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  votematrixi<-matrix(nrow=(0), ncol=(0))#
  habitmatrixi<-matrix(nrow=(0), ncol=(0))#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##Primary Election Data#
primaryVoteFramej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primaryVoteSumsj<- colSums(primaryVoteFramej) ## Participation in Primary#
primaryVoteMeansj<- colMeans(primaryVoteFramej) ## Participation Rate#
## primaryVoteMeansj#
nPeriodthPrimaryMeanj<-primaryVoteMeansj[7]#
nPeriodthPrimaryMeanj#
#
primaryIndVotesj<-rowSums(primaryVoteFramej) ## Individual Participation by number of votes#
primaryIndParticipationj<-table(primaryIndVotesj) ## Summary of number of times respondents voted (mode)#
primaryIndParticipationj#
## barplot(primaryIndParticipationj, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
electionsj<-c(1:nPeriods)#
## meanparticipationj<-(voteRts+voteDts)/2 ## For each of nPeriods#
#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## Voting rate for last election only#
#
##Habitual Voting Behavior#
primaryHabitualj<-(((primaryIndParticipationj["0"])+(primaryIndParticipationj["7"]))/n) ## For consistent voters and abstainers#
primaryHabitualj#
#
## Plots#
## par(mfrow=c(2,2))#
## barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
## plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes", col="Red")#
##par(new=T)#
## plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes", col="Blue")#
##par(new=F)#
#
sum(actions)#
primarySumsj[7]#
#
  votematrixi<- list(votematrixi, mean(actions))#
  habitmatrixi<- list(habitmatrixi, primaryHabitualj)#
#
}#
#
primaryVoteFramei <- data.frame(matrix(unlist(list(votematrixi)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primaryHabitFramei <- data.frame(matrix(unlist(list(habitmatrixi)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
#
primaryVoteSumsi<- colSums(primaryVoteFramei) ## Participation in Primary#
primaryVoteMeansi<- colMeans(primaryVoteFramei) ## Participation Rate#
## primaryVoteMeansi#
nPeriodthPrimaryMeani<-primaryVoteMeansi[7]#
nPeriodthPrimaryMeani#
#
primaryIndVotes<-rowSums(primaryVoteFramej) ## Individual Participation by number of votes#
primaryIndParticipation<-table(primaryIndVotes) ## Summary of number of times respondents voted (mode)#
primaryIndParticipation#
## barplot(primaryIndParticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
## meanparticipation<-(voteRts+voteDts)/2 ## For each of nPeriods#
#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## Voting rate for last election only#
#
##Habitual Voting Behavior#
primaryHabitual<-(((primaryIndParticipation["0"])+(primaryIndParticipation["7"]))/n) ## For consistent voters and abstainers#
primaryHabitual
votematrixi
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-10 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  votematrixi<-matrix(nrow=(0), ncol=(0))#
  habitmatrixi<-matrix(nrow=(0), ncol=(0))#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##Primary Election Data#
primaryVoteFramej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primaryVoteSumsj<- colSums(primaryVoteFramej) ## Participation in Primary#
primaryVoteMeansj<- colMeans(primaryVoteFramej) ## Participation Rate#
## primaryVoteMeansj#
nPeriodthPrimaryMeanj<-primaryVoteMeansj[7]#
nPeriodthPrimaryMeanj#
#
primaryIndVotesj<-rowSums(primaryVoteFramej) ## Individual Participation by number of votes#
primaryIndParticipationj<-table(primaryIndVotesj) ## Summary of number of times respondents voted (mode)#
primaryIndParticipationj#
## barplot(primaryIndParticipationj, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
electionsj<-c(1:nPeriods)#
## meanparticipationj<-(voteRts+voteDts)/2 ## For each of nPeriods#
#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## Voting rate for last election only#
#
##Habitual Voting Behavior#
primaryHabitualj<-(((primaryIndParticipationj["0"])+(primaryIndParticipationj["7"]))/n) ## For consistent voters and abstainers#
primaryHabitualj#
#
## Plots#
## par(mfrow=c(2,2))#
## barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
## plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes", col="Red")#
##par(new=T)#
## plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes", col="Blue")#
##par(new=F)#
#
sum(actions)#
primarySumsj[7]#
#
votematrixi<- list(votematrixi, mean(actions))#
habitmatrixi<- list(habitmatrixi, primaryHabitualj)#
#
}
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-10 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  votematrixi<-matrix(nrow=(0), ncol=(0))#
  habitmatrixi<-matrix(nrow=(0), ncol=(0))#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##Primary Election Data#
primaryVoteFramej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primaryVoteSumsj<- colSums(primaryVoteFramej) ## Participation in Primary#
primaryVoteMeansj<- colMeans(primaryVoteFramej) ## Participation Rate#
## primaryVoteMeansj#
nPeriodthPrimaryMeanj<-primaryVoteMeansj[7]#
nPeriodthPrimaryMeanj#
#
primaryIndVotesj<-rowSums(primaryVoteFramej) ## Individual Participation by number of votes#
primaryIndParticipationj<-table(primaryIndVotesj) ## Summary of number of times respondents voted (mode)#
primaryIndParticipationj#
## barplot(primaryIndParticipationj, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
electionsj<-c(1:nPeriods)#
## meanparticipationj<-(voteRts+voteDts)/2 ## For each of nPeriods#
#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## Voting rate for last election only#
#
##Habitual Voting Behavior#
primaryHabitualj<-(((primaryIndParticipationj["0"])+(primaryIndParticipationj["7"]))/n) ## For consistent voters and abstainers#
primaryHabitualj#
#
## Plots#
## par(mfrow=c(2,2))#
## barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
## plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes", col="Red")#
##par(new=T)#
## plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes", col="Blue")#
##par(new=F)#
#
sum(actions)#
primaryVoteSumsj[7]#
#
votematrixi<- list(votematrixi, mean(actions))#
habitmatrixi<- list(habitmatrixi, primaryHabitualj)#
#
}
votematrixi
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-10 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
votematrixi<-matrix(nrow=(0), ncol=(0))#
habitmatrixi<-matrix(nrow=(0), ncol=(0))#
#
for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##Primary Election Data#
primaryVoteFramej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primaryVoteSumsj<- colSums(primaryVoteFramej) ## Participation in Primary#
primaryVoteMeansj<- colMeans(primaryVoteFramej) ## Participation Rate#
## primaryVoteMeansj#
nPeriodthPrimaryMeanj<-primaryVoteMeansj[7]#
nPeriodthPrimaryMeanj#
#
primaryIndVotesj<-rowSums(primaryVoteFramej) ## Individual Participation by number of votes#
primaryIndParticipationj<-table(primaryIndVotesj) ## Summary of number of times respondents voted (mode)#
primaryIndParticipationj#
## barplot(primaryIndParticipationj, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
electionsj<-c(1:nPeriods)#
## meanparticipationj<-(voteRts+voteDts)/2 ## For each of nPeriods#
#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## Voting rate for last election only#
#
##Habitual Voting Behavior#
primaryHabitualj<-(((primaryIndParticipationj["0"])+(primaryIndParticipationj["7"]))/n) ## For consistent voters and abstainers#
primaryHabitualj#
#
## Plots#
## par(mfrow=c(2,2))#
## barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
## plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes", col="Red")#
##par(new=T)#
## plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes", col="Blue")#
##par(new=F)#
#
sum(actions)#
primaryVoteSumsj[7]#
#
votematrixi<- list(votematrixi, mean(actions))#
habitmatrixi<- list(habitmatrixi, primaryHabitualj)#
#
}
votematrixi
habitmatrixi
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-10 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
votematrixi<-matrix(nrow=(0), ncol=(0))#
habitmatrixi<-matrix(nrow=(0), ncol=(0))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
#
## This section is for inner J loop only #
##Primary Election Data for j Periods#
primaryVoteFramej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primaryVoteSumsj<- colSums(primaryVoteFramej) ## Participation in Primary#
primaryVoteMeansj<- colMeans(primaryVoteFramej) ## Participation Rate#
## primaryVoteMeansj#
nPeriodthPrimaryMeanj<-primaryVoteMeansj[7]#
nPeriodthPrimaryMeanj#
#
primaryIndVotesj<-rowSums(primaryVoteFramej) ## Individual Participation by number of votes#
primaryIndParticipationj<-table(primaryIndVotesj) ## Summary of number of times respondents voted (mode)#
primaryIndParticipationj#
## barplot(primaryIndParticipationj, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
electionsj<-c(1:nPeriods)#
## meanparticipationj<-(voteRts+voteDts)/2 ## For each of nPeriods#
#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## Voting rate for last election only#
#
##Habitual Voting Behavior#
primaryHabitualj<-(((primaryIndParticipationj["0"])+(primaryIndParticipationj["7"]))/n) ## For consistent voters and abstainers#
primaryHabitualj#
#
## Plots#
## par(mfrow=c(2,2))#
## barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
## plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes", col="Red")#
##par(new=T)#
## plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes", col="Blue")#
##par(new=F)#
#
sum(actions)#
primaryVoteSumsj[7]#
#
votematrixi<- list(votematrixi, mean(actions))#
habitmatrixi<- list(habitmatrixi, primaryHabitualj)#
#
## }
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-10 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
votematrixi<-matrix(nrow=(0), ncol=(0))#
habitmatrixi<-matrix(nrow=(0), ncol=(0))#
#
for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
#
## This section is for inner J loop only #
##Primary Election Data for j Periods#
primaryVoteFramej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primaryVoteSumsj<- colSums(primaryVoteFramej) ## Participation in Primary#
primaryVoteMeansj<- colMeans(primaryVoteFramej) ## Participation Rate#
## primaryVoteMeansj#
nPeriodthPrimaryMeanj<-primaryVoteMeansj[7]#
nPeriodthPrimaryMeanj#
#
primaryIndVotesj<-rowSums(primaryVoteFramej) ## Individual Participation by number of votes#
primaryIndParticipationj<-table(primaryIndVotesj) ## Summary of number of times respondents voted (mode)#
primaryIndParticipationj#
## barplot(primaryIndParticipationj, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
electionsj<-c(1:nPeriods)#
## meanparticipationj<-(voteRts+voteDts)/2 ## For each of nPeriods#
#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## Voting rate for last election only#
#
##Habitual Voting Behavior#
primaryHabitualj<-(((primaryIndParticipationj["0"])+(primaryIndParticipationj["7"]))/n) ## For consistent voters and abstainers#
primaryHabitualj#
#
## Plots#
## par(mfrow=c(2,2))#
## barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
## plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes", col="Red")#
##par(new=T)#
## plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes", col="Blue")#
##par(new=F)#
#
sum(actions)#
primaryVoteSumsj[7]#
#
votematrixi<- list(votematrixi, mean(actions))#
habitmatrixi<- list(habitmatrixi, primaryHabitualj)#
#
}#
#
primaryVoteFramei <- data.frame(matrix(unlist(list(votematrixi)), nrow=n, byrow=FALSE))  ## Extracts data from matrix
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-10 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
votematrixi<-matrix(nrow=(0), ncol=(0))#
habitmatrixi<-matrix(nrow=(0), ncol=(0))#
#
for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
#
## This section is for inner J loop only #
##Primary Election Data for j Periods#
primaryVoteFramej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primaryVoteSumsj<- colSums(primaryVoteFramej) ## Participation in Primary#
primaryVoteMeansj<- colMeans(primaryVoteFramej) ## Participation Rate#
## primaryVoteMeansj#
nPeriodthPrimaryMeanj<-primaryVoteMeansj[7]#
nPeriodthPrimaryMeanj#
#
primaryIndVotesj<-rowSums(primaryVoteFramej) ## Individual Participation by number of votes#
primaryIndParticipationj<-table(primaryIndVotesj) ## Summary of number of times respondents voted (mode)#
primaryIndParticipationj#
## barplot(primaryIndParticipationj, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
electionsj<-c(1:nPeriods)#
## meanparticipationj<-(voteRts+voteDts)/2 ## For each of nPeriods#
#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## Voting rate for last election only#
#
##Habitual Voting Behavior#
primaryHabitualj<-(((primaryIndParticipationj["0"])+(primaryIndParticipationj["7"]))/n) ## For consistent voters and abstainers#
primaryHabitualj#
#
## Plots#
## par(mfrow=c(2,2))#
## barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
## plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes", col="Red")#
##par(new=T)#
## plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes", col="Blue")#
##par(new=F)#
#
sum(actions)#
primaryVoteSumsj[7]#
#
votematrixi<- list(votematrixi, mean(actions))#
habitmatrixi<- list(habitmatrixi, primaryHabitualj)#
#
}#
#
primaryVoteFramei <- data.frame(matrix(unlist(list(votematrixi)), nrow=nSims, byrow=FALSE))  ## Extracts data from matrix
primaryVoteFramei
colSums(primaryVoteFramei)
colMeans(primaryVoteFramei)
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-10 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
votematrixi<-matrix(nrow=(0), ncol=(0))#
habitmatrixi<-matrix(nrow=(0), ncol=(0))#
#
for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
#
## This section is for inner J loop only #
##Primary Election Data for j Periods#
primaryVoteFramej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primaryVoteSumsj<- colSums(primaryVoteFramej) ## Participation in Primary#
primaryVoteMeansj<- colMeans(primaryVoteFramej) ## Participation Rate#
## primaryVoteMeansj#
nPeriodthPrimaryMeanj<-primaryVoteMeansj[7]#
nPeriodthPrimaryMeanj#
#
primaryIndVotesj<-rowSums(primaryVoteFramej) ## Individual Participation by number of votes#
primaryIndParticipationj<-table(primaryIndVotesj) ## Summary of number of times respondents voted (mode)#
primaryIndParticipationj#
## barplot(primaryIndParticipationj, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
electionsj<-c(1:nPeriods)#
## meanparticipationj<-(voteRts+voteDts)/2 ## For each of nPeriods#
#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## Voting rate for last election only#
#
##Habitual Voting Behavior#
primaryHabitualj<-(((primaryIndParticipationj["0"])+(primaryIndParticipationj["7"]))/n) ## For consistent voters and abstainers#
primaryHabitualj#
#
## Plots#
## par(mfrow=c(2,2))#
## barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
## plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes", col="Red")#
##par(new=T)#
## plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes", col="Blue")#
##par(new=F)#
#
sum(actions)#
primaryVoteSumsj[7]#
#
votematrixi<- list(votematrixi, mean(actions))#
habitmatrixi<- list(habitmatrixi, primaryHabitualj)#
#
}#
#
primaryVoteFramei <- data.frame(matrix(unlist(list(votematrixi)), nrow=nSims, byrow=FALSE))  ## Extracts data from matrix#
primaryVoteMeansi<-colMeans(primaryVoteFramei) ## Vote Mean for nSims#
primaryVoteMeansi
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-10 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
votematrixi<-matrix(nrow=(0), ncol=(0))#
habitmatrixi<-matrix(nrow=(0), ncol=(0))#
#
for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
#
## This section is for inner J loop only #
##Primary Election Data for j Periods#
primaryVoteFramej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primaryVoteSumsj<- colSums(primaryVoteFramej) ## Participation in Primary#
primaryVoteMeansj<- colMeans(primaryVoteFramej) ## Participation Rate#
## primaryVoteMeansj#
nPeriodthPrimaryMeanj<-primaryVoteMeansj[7]#
nPeriodthPrimaryMeanj#
#
primaryIndVotesj<-rowSums(primaryVoteFramej) ## Individual Participation by number of votes#
primaryIndParticipationj<-table(primaryIndVotesj) ## Summary of number of times respondents voted (mode)#
primaryIndParticipationj#
## barplot(primaryIndParticipationj, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
electionsj<-c(1:nPeriods)#
## meanparticipationj<-(voteRts+voteDts)/2 ## For each of nPeriods#
#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## Voting rate for last election only#
#
##Habitual Voting Behavior#
primaryHabitualj<-(((primaryIndParticipationj["0"])+(primaryIndParticipationj["7"]))/n) ## For consistent voters and abstainers#
primaryHabitualj#
#
## Plots#
## par(mfrow=c(2,2))#
## barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
## plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes", col="Red")#
##par(new=T)#
## plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes", col="Blue")#
##par(new=F)#
#
sum(actions)#
primaryVoteSumsj[7]#
#
votematrixi<- list(votematrixi, actions)#
habitmatrixi<- list(habitmatrixi, primaryHabitualj)#
#
}#
#
primaryVoteFramei <- data.frame(matrix(unlist(list(votematrixi)), nrow=nSims, byrow=FALSE))  ## Extracts data from matrix#
primaryVoteMeansi<-colMeans(primaryVoteFramei) ## Vote Mean for nSims#
primaryVoteMeansi
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-10 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
votematrixi<-matrix(nrow=(0), ncol=(0))#
habitmatrixi<-matrix(nrow=(0), ncol=(0))#
#
for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
#
## This section is for inner J loop only #
##Primary Election Data for j Periods#
primaryVoteFramej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primaryVoteSumsj<- colSums(primaryVoteFramej) ## Participation in Primary#
primaryVoteMeansj<- colMeans(primaryVoteFramej) ## Participation Rate#
## primaryVoteMeansj#
nPeriodthPrimaryMeanj<-primaryVoteMeansj[7]#
nPeriodthPrimaryMeanj#
#
primaryIndVotesj<-rowSums(primaryVoteFramej) ## Individual Participation by number of votes#
primaryIndParticipationj<-table(primaryIndVotesj) ## Summary of number of times respondents voted (mode)#
primaryIndParticipationj#
## barplot(primaryIndParticipationj, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
electionsj<-c(1:nPeriods)#
## meanparticipationj<-(voteRts+voteDts)/2 ## For each of nPeriods#
#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## Voting rate for last election only#
#
##Habitual Voting Behavior#
primaryHabitualj<-(((primaryIndParticipationj["0"])+(primaryIndParticipationj["7"]))/n) ## For consistent voters and abstainers#
primaryHabitualj#
#
## Plots#
## par(mfrow=c(2,2))#
## barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
## plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes", col="Red")#
##par(new=T)#
## plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes", col="Blue")#
##par(new=F)#
#
sum(actions)#
primaryVoteSumsj[7]#
#
votematrixi<- list(votematrixi, actions)#
habitmatrixi<- list(habitmatrixi, primaryHabitualj)#
#
}#
#
primaryVoteFramei <- data.frame(matrix(unlist(list(votematrixi)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primaryVoteMeansi<-colMeans(primaryVoteFramei) ## Vote Mean for nSims#
primaryVoteMeansi
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-10 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
votematrixi<-matrix(nrow=(0), ncol=(0))#
habitmatrixi<-matrix(nrow=(0), ncol=(0))#
#
for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
#
## This section is for inner J loop only #
##Primary Election Data for j Periods#
primaryVoteFramej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primaryVoteSumsj<- colSums(primaryVoteFramej) ## Participation in Primary#
primaryVoteMeansj<- colMeans(primaryVoteFramej) ## Participation Rate#
## primaryVoteMeansj#
nPeriodthPrimaryMeanj<-primaryVoteMeansj[7]#
nPeriodthPrimaryMeanj#
#
primaryIndVotesj<-rowSums(primaryVoteFramej) ## Individual Participation by number of votes#
primaryIndParticipationj<-table(primaryIndVotesj) ## Summary of number of times respondents voted (mode)#
primaryIndParticipationj#
## barplot(primaryIndParticipationj, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
electionsj<-c(1:nPeriods)#
## meanparticipationj<-(voteRts+voteDts)/2 ## For each of nPeriods#
#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## Voting rate for last election only#
#
##Habitual Voting Behavior#
primaryHabitualj<-(((primaryIndParticipationj["0"])+(primaryIndParticipationj["7"]))/n) ## For consistent voters and abstainers#
primaryHabitualj#
#
## Plots#
## par(mfrow=c(2,2))#
## barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
## plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes", col="Red")#
##par(new=T)#
## plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes", col="Blue")#
##par(new=F)#
#
sum(actions)#
primaryVoteSumsj[7]#
#
votematrixi<- list(votematrixi, actions)#
habitmatrixi<- list(habitmatrixi, primaryHabitualj)#
#
}#
#
primaryVoteFramei <- data.frame(matrix(unlist(list(votematrixi)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primaryVoteMeansi<-colMeans(primaryVoteFramei) ## Vote Mean for each in nSims#
primaryVoteMeansi#
overallPrimaryMean<-rowMeans(primaryVoteMeansi)
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-10 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
votematrixi<-matrix(nrow=(0), ncol=(0))#
habitmatrixi<-matrix(nrow=(0), ncol=(0))#
#
for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
#
## This section is for inner J loop only #
##Primary Election Data for j Periods#
primaryVoteFramej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primaryVoteSumsj<- colSums(primaryVoteFramej) ## Participation in Primary#
primaryVoteMeansj<- colMeans(primaryVoteFramej) ## Participation Rate#
## primaryVoteMeansj#
nPeriodthPrimaryMeanj<-primaryVoteMeansj[7]#
nPeriodthPrimaryMeanj#
#
primaryIndVotesj<-rowSums(primaryVoteFramej) ## Individual Participation by number of votes#
primaryIndParticipationj<-table(primaryIndVotesj) ## Summary of number of times respondents voted (mode)#
primaryIndParticipationj#
## barplot(primaryIndParticipationj, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
electionsj<-c(1:nPeriods)#
## meanparticipationj<-(voteRts+voteDts)/2 ## For each of nPeriods#
#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## Voting rate for last election only#
#
##Habitual Voting Behavior#
primaryHabitualj<-(((primaryIndParticipationj["0"])+(primaryIndParticipationj["7"]))/n) ## For consistent voters and abstainers#
primaryHabitualj#
#
## Plots#
## par(mfrow=c(2,2))#
## barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
## plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes", col="Red")#
##par(new=T)#
## plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes", col="Blue")#
##par(new=F)#
#
sum(actions)#
primaryVoteSumsj[7]#
#
votematrixi<- list(votematrixi, actions)#
habitmatrixi<- list(habitmatrixi, primaryHabitualj)#
#
}#
#
primaryVoteFramei <- data.frame(matrix(unlist(list(votematrixi)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primaryVoteMeansi<-colMeans(primaryVoteFramei) ## Vote Mean for each in nSims#
primaryVoteMeansi#
overallPrimaryMean<-Mean(primaryVoteMeansi)
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-10 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
votematrixi<-matrix(nrow=(0), ncol=(0))#
habitmatrixi<-matrix(nrow=(0), ncol=(0))#
#
for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
#
## This section is for inner J loop only #
##Primary Election Data for j Periods#
primaryVoteFramej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primaryVoteSumsj<- colSums(primaryVoteFramej) ## Participation in Primary#
primaryVoteMeansj<- colMeans(primaryVoteFramej) ## Participation Rate#
## primaryVoteMeansj#
nPeriodthPrimaryMeanj<-primaryVoteMeansj[7]#
nPeriodthPrimaryMeanj#
#
primaryIndVotesj<-rowSums(primaryVoteFramej) ## Individual Participation by number of votes#
primaryIndParticipationj<-table(primaryIndVotesj) ## Summary of number of times respondents voted (mode)#
primaryIndParticipationj#
## barplot(primaryIndParticipationj, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
electionsj<-c(1:nPeriods)#
## meanparticipationj<-(voteRts+voteDts)/2 ## For each of nPeriods#
#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## Voting rate for last election only#
#
##Habitual Voting Behavior#
primaryHabitualj<-(((primaryIndParticipationj["0"])+(primaryIndParticipationj["7"]))/n) ## For consistent voters and abstainers#
primaryHabitualj#
#
## Plots#
## par(mfrow=c(2,2))#
## barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
## plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes", col="Red")#
##par(new=T)#
## plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes", col="Blue")#
##par(new=F)#
#
sum(actions)#
primaryVoteSumsj[7]#
#
votematrixi<- list(votematrixi, actions)#
habitmatrixi<- list(habitmatrixi, primaryHabitualj)#
#
}#
#
primaryVoteFramei <- data.frame(matrix(unlist(list(votematrixi)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primaryVoteMeansi<-colMeans(primaryVoteFramei) ## Vote Mean for each in nSims#
primaryVoteMeansi#
overallPrimaryMean<-mean(primaryVoteMeansi)
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-10 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
votematrixi<-matrix(nrow=(0), ncol=(0))#
habitmatrixi<-matrix(nrow=(0), ncol=(0))#
#
for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
#
## This section is for inner J loop only #
##Primary Election Data for j Periods#
primaryVoteFramej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primaryVoteSumsj<- colSums(primaryVoteFramej) ## Participation in Primary#
primaryVoteMeansj<- colMeans(primaryVoteFramej) ## Participation Rate#
## primaryVoteMeansj#
nPeriodthPrimaryMeanj<-primaryVoteMeansj[7]#
nPeriodthPrimaryMeanj#
#
primaryIndVotesj<-rowSums(primaryVoteFramej) ## Individual Participation by number of votes#
primaryIndParticipationj<-table(primaryIndVotesj) ## Summary of number of times respondents voted (mode)#
primaryIndParticipationj#
## barplot(primaryIndParticipationj, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
electionsj<-c(1:nPeriods)#
## meanparticipationj<-(voteRts+voteDts)/2 ## For each of nPeriods#
#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## Voting rate for last election only#
#
##Habitual Voting Behavior#
primaryHabitualj<-(((primaryIndParticipationj["0"])+(primaryIndParticipationj["7"]))/n) ## For consistent voters and abstainers#
primaryHabitualj#
#
## Plots#
## par(mfrow=c(2,2))#
## barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
## plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes", col="Red")#
##par(new=T)#
## plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes", col="Blue")#
##par(new=F)#
#
sum(actions)#
primaryVoteSumsj[7]#
#
votematrixi<- list(votematrixi, actions)#
habitmatrixi<- list(habitmatrixi, primaryHabitualj)#
#
}#
#
primaryVoteFramei <- data.frame(matrix(unlist(list(votematrixi)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primaryVoteMeansi<-colMeans(primaryVoteFramei) ## Vote Mean for each in nSims#
primaryVoteMeansi#
overallPrimaryMean<-mean(primaryVoteMeansi)#
overallPrimaryMean
votematrixi
actions
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-10 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
votematrixi<-matrix(nrow=(0), ncol=(0))#
habitmatrixi<-matrix(nrow=(0), ncol=(0))#
#
for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
#
## This section is for inner J loop only #
##Primary Election Data for j Periods#
primaryVoteFramej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primaryVoteSumsj<- colSums(primaryVoteFramej) ## Participation in Primary#
primaryVoteMeansj<- colMeans(primaryVoteFramej) ## Participation Rate#
## primaryVoteMeansj#
nPeriodthPrimaryMeanj<-primaryVoteMeansj[7]#
nPeriodthPrimaryMeanj#
#
primaryIndVotesj<-rowSums(primaryVoteFramej) ## Individual Participation by number of votes#
primaryIndParticipationj<-table(primaryIndVotesj) ## Summary of number of times respondents voted (mode)#
primaryIndParticipationj#
## barplot(primaryIndParticipationj, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
electionsj<-c(1:nPeriods)#
## meanparticipationj<-(voteRts+voteDts)/2 ## For each of nPeriods#
#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## Voting rate for last election only#
#
##Habitual Voting Behavior#
primaryHabitualj<-(((primaryIndParticipationj["0"])+(primaryIndParticipationj["7"]))/n) ## For consistent voters and abstainers#
primaryHabitualj#
#
## Plots#
## par(mfrow=c(2,2))#
## barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
## plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes", col="Red")#
##par(new=T)#
## plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes", col="Blue")#
##par(new=F)#
#
sum(actions)#
primaryVoteSumsj[7]#
#
votematrixi<- list(votematrixi, actions)#
habitmatrixi<- list(habitmatrixi, primaryHabitualj)#
#
}#
#
primaryVoteFramei <- data.frame(matrix(unlist(list(votematrixi)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primaryVoteMeansi<-colMeans(primaryVoteFramei) ## Vote Mean for each in nSims#
primaryVoteMeansi#
overallPrimaryMean<-mean(primaryVoteMeansi) ## Mean for nPeriodth in nSims#
overallPrimaryMean
habitmatrixi
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-10 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
votematrixi<-matrix(nrow=(0), ncol=(0))#
habitmatrixi<-matrix(nrow=(0), ncol=(0))#
#
for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
#
## This section is for inner J loop only #
##Primary Election Data for j Periods#
primaryVoteFramej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primaryVoteSumsj<- colSums(primaryVoteFramej) ## Participation in Primary#
primaryVoteMeansj<- colMeans(primaryVoteFramej) ## Participation Rate#
## primaryVoteMeansj#
nPeriodthPrimaryMeanj<-primaryVoteMeansj[7]#
nPeriodthPrimaryMeanj#
#
primaryIndVotesj<-rowSums(primaryVoteFramej) ## Individual Participation by number of votes#
primaryIndParticipationj<-table(primaryIndVotesj) ## Summary of number of times respondents voted (mode)#
primaryIndParticipationj#
## barplot(primaryIndParticipationj, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
electionsj<-c(1:nPeriods)#
## meanparticipationj<-(voteRts+voteDts)/2 ## For each of nPeriods#
#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## Voting rate for last election only#
#
##Habitual Voting Behavior#
primaryHabitualj<-(((primaryIndParticipationj["0"])+(primaryIndParticipationj["7"]))/n) ## For consistent voters and abstainers#
primaryHabitualj#
#
## Plots#
## par(mfrow=c(2,2))#
## barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
## plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes", col="Red")#
##par(new=T)#
## plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes", col="Blue")#
##par(new=F)#
#
sum(actions)#
primaryVoteSumsj[7]#
#
votematrixi<- list(votematrixi, actions)#
habitmatrixi<- list(habitmatrixi, primaryHabitualj)#
#
}#
#
primaryVoteFramei <- data.frame(matrix(unlist(list(votematrixi)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primaryVoteMeansi<-colMeans(primaryVoteFramei) ## Vote Mean for each in nSims#
primaryVoteMeansi#
overallPrimaryMean<-mean(primaryVoteMeansi) ## Mean for nPeriodth in nSims#
overallPrimaryMean#
#
primaryHabitFramei <- data.frame(matrix(unlist(list(habitmatrixi)), nrow=nSims, byrow=FALSE))  ## Extracts data from matrix
primaryHabitFramei
colMeans(primaryHabitFramei)
ls()
load("/Users/jg/Dropbox/Active USF/698 Genetics/Genetic Research/FowlerRworkspace")
ls()
actions
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-10 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
votematrixi<-matrix(nrow=(0), ncol=(0))#
habitmatrixi<-matrix(nrow=(0), ncol=(0))#
#
for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
#
## This section is for inner J loop only #
##Primary Election Data for j Periods#
primaryVoteFramej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primaryVoteSumsj<- colSums(primaryVoteFramej) ## Participation in Primary#
primaryVoteMeansj<- colMeans(primaryVoteFramej) ## Participation Rate#
## primaryVoteMeansj#
nPeriodthPrimaryMeanj<-primaryVoteMeansj[7]#
nPeriodthPrimaryMeanj#
#
primaryIndVotesj<-rowSums(primaryVoteFramej) ## Individual Participation by number of votes#
primaryIndParticipationj<-table(primaryIndVotesj) ## Summary of number of times respondents voted (mode)#
primaryIndParticipationj#
## barplot(primaryIndParticipationj, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
electionsj<-c(1:nPeriods)#
## meanparticipationj<-(voteRts+voteDts)/2 ## For each of nPeriods#
#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## Voting rate for last election only#
#
##Habitual Voting Behavior#
primaryHabitualj<-(((primaryIndParticipationj["0"])+(primaryIndParticipationj["7"]))/n) ## For consistent voters and abstainers#
primaryHabitualj#
#
## Plots#
## par(mfrow=c(2,2))#
## barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
## plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes", col="Red")#
##par(new=T)#
## plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes", col="Blue")#
##par(new=F)#
#
sum(actions)#
primaryVoteSumsj[7]#
#
votematrixi<- list(votematrixi, actions)#
habitmatrixi<- list(habitmatrixi, primaryHabitualj)#
#
}#
#
primaryVoteFramei <- data.frame(matrix(unlist(list(votematrixi)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primaryVoteMeansi<-colMeans(primaryVoteFramei) ## Vote Mean for each in nSims#
primaryVoteMeansi#
overallPrimaryMean<-mean(primaryVoteMeansi) ## Mean for nPeriodth in nSims#
overallPrimaryMean#
#
primaryHabitFramei <- data.frame(matrix(unlist(list(habitmatrixi)), nrow=nSims, byrow=FALSE))  ## Extracts data from matrix#
overallPrimaryHabitBehavior<- colMeans(primaryHabitFramei) ## Habitual Behavior for nPeriodth in nSims#
overallPrimaryHabitBehavior
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-10 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
votematrixi<-matrix(nrow=(0), ncol=(0))#
habitmatrixi<-matrix(nrow=(0), ncol=(0))#
#
for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
#
## This section is for inner J loop only #
##Primary Election Data for j Periods#
primaryVoteFramej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primaryVoteSumsj<- colSums(primaryVoteFramej) ## Participation in Primary#
primaryVoteMeansj<- colMeans(primaryVoteFramej) ## Participation Rate#
## primaryVoteMeansj#
nPeriodthPrimaryMeanj<-primaryVoteMeansj[7]#
nPeriodthPrimaryMeanj#
#
primaryIndVotesj<-rowSums(primaryVoteFramej) ## Individual Participation by number of votes#
primaryIndParticipationj<-table(primaryIndVotesj) ## Summary of number of times respondents voted (mode)#
primaryIndParticipationj#
## barplot(primaryIndParticipationj, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
electionsj<-c(1:nPeriods)#
## meanparticipationj<-(voteRts+voteDts)/2 ## For each of nPeriods#
#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## Voting rate for last election only#
#
##Habitual Voting Behavior#
primaryHabitualj<-(((primaryIndParticipationj["0"])+(primaryIndParticipationj["7"]))/n) ## For consistent voters and abstainers#
primaryHabitualj#
#
## Plots#
 par(mfrow=c(2,2))#
 barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
 plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes", col="Red")#
##par(new=T)#
 plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes", col="Blue")#
##par(new=F)#
#
sum(actions)#
primaryVoteSumsj[7]#
#
votematrixi<- list(votematrixi, actions)#
habitmatrixi<- list(habitmatrixi, primaryHabitualj)#
#
}#
#
primaryVoteFramei <- data.frame(matrix(unlist(list(votematrixi)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primaryVoteMeansi<-colMeans(primaryVoteFramei) ## Vote Mean for each in nSims#
primaryVoteMeansi#
overallPrimaryMean<-mean(primaryVoteMeansi) ## Mean for nPeriodth in nSims#
overallPrimaryMean#
#
primaryHabitFramei <- data.frame(matrix(unlist(list(habitmatrixi)), nrow=nSims, byrow=FALSE))  ## Extracts data from matrix#
overallPrimaryHabitBehavior<- colMeans(primaryHabitFramei) ## Habitual Behavior for nPeriodth in nSims#
overallPrimaryHabitBehavior
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-10 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
votematrixi<-matrix(nrow=(0), ncol=(0))#
habitmatrixi<-matrix(nrow=(0), ncol=(0))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
#
## This section is for inner J loop only #
##Primary Election Data for j Periods#
primaryVoteFramej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primaryVoteSumsj<- colSums(primaryVoteFramej) ## Participation in Primary#
primaryVoteMeansj<- colMeans(primaryVoteFramej) ## Participation Rate#
## primaryVoteMeansj#
nPeriodthPrimaryMeanj<-primaryVoteMeansj[7]#
nPeriodthPrimaryMeanj#
#
primaryIndVotesj<-rowSums(primaryVoteFramej) ## Individual Participation by number of votes#
primaryIndParticipationj<-table(primaryIndVotesj) ## Summary of number of times respondents voted (mode)#
primaryIndParticipationj#
## barplot(primaryIndParticipationj, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
electionsj<-c(1:nPeriods)#
## meanparticipationj<-(voteRts+voteDts)/2 ## For each of nPeriods#
#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## Voting rate for last election only#
#
##Habitual Voting Behavior#
primaryHabitualj<-(((primaryIndParticipationj["0"])+(primaryIndParticipationj["7"]))/n) ## For consistent voters and abstainers#
primaryHabitualj#
#
## Plots#
 par(mfrow=c(2,2))#
 barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
 plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes", col="Red")#
##par(new=T)#
 plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes", col="Blue")#
##par(new=F)#
#
sum(actions)#
primaryVoteSumsj[7]#
#
votematrixi<- list(votematrixi, actions)#
habitmatrixi<- list(habitmatrixi, primaryHabitualj)#
#
##}#
#
primaryVoteFramei <- data.frame(matrix(unlist(list(votematrixi)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primaryVoteMeansi<-colMeans(primaryVoteFramei) ## Vote Mean for each in nSims#
primaryVoteMeansi#
overallPrimaryMean<-mean(primaryVoteMeansi) ## Mean for nPeriodth in nSims#
overallPrimaryMean#
#
primaryHabitFramei <- data.frame(matrix(unlist(list(habitmatrixi)), nrow=nSims, byrow=FALSE))  ## Extracts data from matrix#
overallPrimaryHabitBehavior<- colMeans(primaryHabitFramei) ## Habitual Behavior for nPeriodth in nSims#
overallPrimaryHabitBehavior
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-10 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
votematrixi<-matrix(nrow=(0), ncol=(0))#
habitmatrixi<-matrix(nrow=(0), ncol=(0))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
#
## This section is for inner J loop only #
##Primary Election Data for j Periods#
primaryVoteFramej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primaryVoteSumsj<- colSums(primaryVoteFramej) ## Participation in Primary#
primaryVoteMeansj<- colMeans(primaryVoteFramej) ## Participation Rate#
## primaryVoteMeansj#
nPeriodthPrimaryMeanj<-primaryVoteMeansj[7]#
nPeriodthPrimaryMeanj#
#
primaryIndVotesj<-rowSums(primaryVoteFramej) ## Individual Participation by number of votes#
primaryIndParticipationj<-table(primaryIndVotesj) ## Summary of number of times respondents voted (mode)#
primaryIndParticipationj#
## barplot(primaryIndParticipationj, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
electionsj<-c(1:nPeriods)#
## meanparticipationj<-(voteRts+voteDts)/2 ## For each of nPeriods#
#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## Voting rate for last election only#
#
##Habitual Voting Behavior#
primaryHabitualj<-(((primaryIndParticipationj["0"])+(primaryIndParticipationj["7"]))/n) ## For consistent voters and abstainers#
primaryHabitualj#
#
## Plots#
 par(mfrow=c(2,2))#
 barplot(primaryIndParticipationj, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
 plot(electionsj, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes", col="Red")#
##par(new=T)#
 plot(electionsj, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes", col="Blue")#
##par(new=F)#
#
sum(actions)#
primaryVoteSumsj[7]#
#
votematrixi<- list(votematrixi, actions)#
habitmatrixi<- list(habitmatrixi, primaryHabitualj)#
#
##}#
#
primaryVoteFramei <- data.frame(matrix(unlist(list(votematrixi)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primaryVoteMeansi<-colMeans(primaryVoteFramei) ## Vote Mean for each in nSims#
primaryVoteMeansi#
overallPrimaryMean<-mean(primaryVoteMeansi) ## Mean for nPeriodth in nSims#
overallPrimaryMean#
#
primaryHabitFramei <- data.frame(matrix(unlist(list(habitmatrixi)), nrow=nSims, byrow=FALSE))  ## Extracts data from matrix#
overallPrimaryHabitBehavior<- colMeans(primaryHabitFramei) ## Habitual Behavior for nPeriodth in nSims#
overallPrimaryHabitBehavior
library(ggplot2)#
library(scales)#
#
##data(economics)#
##View(economics)#
#
scatterplot <- ggplot(economics,#
	aes(x=date, y= psavert)) +#
	geop_point() +#
	ggtitle("US Economic Time Series") +#
	xlab("Year") +#
	ylab("Personal Savings Rate")
library(ggplot2)#
library(scales)#
#
##data(economics)#
##View(economics)#
#
scatterplot <- ggplot(economics,#
	aes(x=date, y= psavert)) +#
	geom_point() +#
	ggtitle("US Economic Time Series") +#
	xlab("Year") +#
	ylab("Personal Savings Rate")
scatterplot
library(ggplot2)#
library(scales)#
#
##data(economics)#
##View(economics)#
#
scatterplot <- ggplot(economics,#
	aes(x=date, y= psavert)) +#
	geom_line() +#
	ggtitle("US Economic Time Series") +#
	xlab("Year") +#
	ylab("Personal Savings Rate")#
#
scatterplot
print(scatterplot)
library(ggplot2)#
library(scales)#
#
##data(economics)#
##View(economics)#
#
scatterplot <- ggplot(economics, aes(x=date, y= psavert)) + ##base#
	geom_line() +#
	ggtitle("US Economic Time Series") +#
	xlab("Year") +#
	ylab("Personal Savings Rate")#
#
print(scatterplot)#
#
help(geom_line)
scatterplot <- ggplot(economics, aes(x=date, y= psavert)) + ##base#
	geom_area() +#
	ggtitle("US Economic Time Series") +#
	xlab("Year") +#
	ylab("Personal Savings Rate")#
#
print(scatterplot)
library(ggplot2)#
library(scales)#
#
##data(economics)#
##View(economics)#
#
economics$year <- + as.POSIXlt(economics$date)$year#
economics$month <- + as.POSIXlt(economics$date)$mon#
#
p <- ggplot(subset(economics, year >= 2003), aes(x=date, y= psavert)) + ##base#
	geom_bar(stat="identity") +#
	ylim(-5,5)#
	ggtitle("US Economic Time Series") +#
	xlab("Year") +#
	ylab("Personal Savings Rate")#
print(p)#
#
##help(geom_line)
library(ggplot2)#
library(scales)#
#
##data(economics)#
##View(economics)#
#
economics$year <- + as.POSIXlt(economics$date)$year#
economics$month <- + as.POSIXlt(economics$date)$mon#
#
p <- ggplot(subset(economics, year >= 2003), aes(x=date, y= psavert)) + ##base#
	geom_bar(stat="identity") +#
	ylim(-5,5) +#
	ggtitle("US Economic Time Series") +#
	xlab("Year") +#
	ylab("Personal Savings Rate")#
print(p)#
#
##help(geom_line)
library(ggplot2)#
library(scales)#
#
##data(economics)#
##View(economics)#
#
economics$year <- 1900 + as.POSIXlt(economics$date)$year#
economics$mon <- 1 + as.POSIXlt(economics$date)$mon#
#
p <- ggplot(subset(economics, year >= 2003), aes(x=date, y= psavert)) + ##base#
	geom_bar(stat="identity") +#
	ylim(-5,5) +#
	ggtitle("US Economic Time Series") +#
	xlab("Year") +#
	ylab("Personal Savings Rate")#
print(p)#
#
##help(geom_line)
library(ggplot2)#
library(scales)#
#
##data(economics)#
##View(economics)#
#
economics$year <- 1900 + as.POSIXlt(economics$date)$year#
economics$mon <- 1 + as.POSIXlt(economics$date)$mon#
#
p <- ggplot(subset(economics, year <= 1990),#
	aes(x=factor(year), y= psavert)) + ##base#
	geom_bar(stat="identity") +#
	ylim(-5,5) +#
	ggtitle("US Economic Time Series") +#
	xlab("Year") +#
	ylab("Personal Savings Rate")#
#
print(p)#
#
##help(geom_line)
library(ggplot2)#
library(scales)#
#
##data(economics)#
##View(economics)#
#
economics$year <- 1900 + as.POSIXlt(economics$date)$year#
economics$mon <- 1 + as.POSIXlt(economics$date)$mon#
#
p <- ggplot(subset(economics, year <= 1990),#
	aes(x=factor(year), y= psavert)) + ##base#
	geom_boxplot() +#
	ylim(-5,5) +#
	ggtitle("US Economic Time Series") +#
	xlab("Year") +#
	ylab("Personal Savings Rate")#
#
print(p)#
#
##help(geom_line)
library(ggplot2)#
library(scales)#
#
##data(economics)#
##View(economics)#
#
economics$year <- 1900 + as.POSIXlt(economics$date)$year ##posix is date object#
economics$month <- 1 + as.POSIXlt(economics$date)$mon#
#
p <- ggplot(subset(economics, year <= 1990),#
	aes(x=factor(year), y= psavert)) + ##base#
	geom_bar(stat="identity") +#
	ylim(-5,5) +#
	ggtitle("US Economic Time Series") +#
	xlab("Year") +#
	ylab("Personal Savings Rate")#
#
print(p)#
#
##help(geom_line)
library(ggplot2)#
library(scales)#
#
##data(economics)#
##View(economics)#
#
economics$year <- 1900 + as.POSIXlt(economics$date)$year ##posix is date object#
economics$month <- 1 + as.POSIXlt(economics$date)$mon#
#
p <- ggplot(subset(economics, year %in% seq(1970, 2010, 5)),#
	aes(x=factor(year), y= psavert)) + ##base#
	geom_line(stat="identity") +#
	ylim(-5,5) +#
	ggtitle("US Economic Time Series") +#
	xlab("Year") +#
	ylab("Personal Savings Rate")#
#
print(p)#
#
##help(geom_line)
library(ggplot2)#
library(scales)#
#
##data(economics)#
##View(economics)#
#
economics$year <- 1900 + as.POSIXlt(economics$date)$year ##posix is date object#
economics$month <- 1 + as.POSIXlt(economics$date)$mon#
#
p <- ggplot(subset(economics, year %in% seq(1970, 2010, 5)),#
	aes(x=factor(month), y= psavert)) + ##base#
	geom_line() +#
	ylim(-5,5) +#
	ggtitle("US Economic Time Series") +#
	xlab("Year") +#
	ylab("Personal Savings Rate")#
#
print(p)#
#
##help(geom_line)
library(ggplot2)#
library(scales)#
#
##data(economics)#
##View(economics)#
#
economics$year <- 1900 + as.POSIXlt(economics$date)$year ##posix is date object#
economics$month <- 1 + as.POSIXlt(economics$date)$mon#
#
p <- ggplot(subset(economics, year %in% seq(1970, 2010, 5)),#
	aes(x=month, y= psavert)) + ##base#
	geom_line() +#
	ylim(-5,5) +#
	ggtitle("US Economic Time Series") +#
	xlab("Year") +#
	ylab("Personal Savings Rate")#
#
print(p)#
#
##help(geom_line)
library(ggplot2)#
library(scales)#
#
##data(economics)#
##View(economics)#
#
economics$year <- 1900 + as.POSIXlt(economics$date)$year ##posix is date object#
economics$month <- 1 + as.POSIXlt(economics$date)$mon#
#
d<-subset(economics, year %in% seq(1970, 2010, 5))#
#
p <- ggplot(d, #
	aes(x=month, y= psavert, #
	group = factor(year),#
	color = factor(year))) + ##base#
	geom_line() +#
	ylim(-5,5) +#
	ggtitle("US Economic Time Series") +#
	xlab("Year") +#
	ylab("Personal Savings Rate")#
#
print(p)#
#
##help(geom_line)
library(ggplot2)#
library(scales)#
#
##data(economics)#
##View(economics)#
#
economics$year <- 1900 + as.POSIXlt(economics$date)$year ##posix is date object#
economics$month <- 1 + as.POSIXlt(economics$date)$mon#
#
d<-subset(economics, year %in% seq(1970, 2010, 5))#
#
p <- ggplot(d, #
	aes(x=month, y= psavert, #
	group = factor(year),#
	color = factor(year))) + ##base#
	geom_line() +#
	ylim(-2,15) +#
	ggtitle("US Economic Time Series") +#
	xlab("Year") +#
	ylab("Personal Savings Rate")#
#
print(p)#
#
##help(geom_line)
library(ggplot2)#
library(scales)#
#
##data(economics)#
##View(economics)#
#
economics$year <- 1900 + as.POSIXlt(economics$date)$year ##posix is date object#
economics$month <- 1 + as.POSIXlt(economics$date)$mon#
#
d<-subset(economics, year %in% seq(1970, 2010, 5))#
#
p <- ggplot(d, #
	aes(x=month, y= psavert, #
	group = factor(year),#
	color = factor(year))) + ##base#
	geom_line() +#
	ylim(-5,15) +#
	ggtitle("US Economic Time Series") +#
	xlab("Year") +#
	ylab("Personal Savings Rate")#
#
print(p)#
#
##help(geom_line)
library(ggplot2)#
library(scales)#
#
##data(economics)#
##View(economics)#
#
economics$year <- 1900 + as.POSIXlt(economics$date)$year ##posix is date object#
economics$month <- 1 + as.POSIXlt(economics$date)$mon#
monthtext<- c("Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec")#
#
d<-subset(economics, year %in% seq(1970, 2010, 5))#
#
p <- ggplot(d, #
	aes(x=month, y= psavert, #
	group = factor(year),#
	color = factor(year))) + ##base#
	geom_line() +#
	ylim(-5,15) +#
	ggtitle("US Economic Time Series") +#
	xlab("Year") +#
	ylab("Personal Savings Rate")#
	scale_x_discrete(labels = monthtext)#
print(p)#
#
##help(geom_line)
library(ggplot2)#
library(scales)#
#
##data(economics)#
##View(economics)#
#
economics$year <- 1900 + as.POSIXlt(economics$date)$year ##posix is date object#
economics$month <- 1 + as.POSIXlt(economics$date)$mon#
monthtext<- c("Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec")#
#
d<-subset(economics, year %in% seq(1970, 2010, 5))#
#
p <- ggplot(d, #
	aes(x=month, y= psavert, #
	group = factor(year),#
	color = factor(year))) + ##base#
	geom_line() +#
	ylim(-5,15) +#
	ggtitle("US Economic Time Series") +#
	xlab("Year") +#
	ylab("Personal Savings Rate") +#
	scale_x_discrete(labels = monthtext) +#
	facet_wrap( ~year, ncol=3)#
#
print(p)#
#
##help(geom_line)
library(ggplot2)#
data(movies)#
data(EuStockMarkets)
movies
MSAN 622#
## Jeremy Gilmore#
## Homework 1#
#
library(ggplot2)#
data(movies)#
data(EuStockMarkets)#
#
## modify data: movies#
movies=movies[!(movies$budget<="0"),]#
genre <- rep(NA, nrow(movies))#
count <- rowSums(movies[, 18:24])#
genre[which(count > 1)] = "Mixed"#
genre[which(count < 1)] = "None"#
genre[which(count == 1 & movies$Action == 1)] = "Action"#
genre[which(count == 1 & movies$Animation == 1)] = "Animation"#
genre[which(count == 1 & movies$Comedy == 1)] = "Comedy"#
genre[which(count == 1 & movies$Drama == 1)] = "Drama"#
genre[which(count == 1 & movies$Documentary == 1)] = "Documentary"#
genre[which(count == 1 & movies$Romance == 1)] = "Romance"#
genre[which(count == 1 & movies$Short == 1)] = "Short"#
#
## modify data: EuStockMarkets#
eu <- transform(data.frame(EuStockMarkets), time = time(EuStockMarkets))
movies
MSAN 622#
## Jeremy Gilmore#
## Homework 1#
#
library(ggplot2)#
data(movies)#
data(EuStockMarkets)#
#
## modify data: movies#
movies=movies[(movies$budget<="0"),]#
##subset(dataframe, )#
genre <- rep(NA, nrow(movies))#
count <- rowSums(movies[, 18:24])#
genre[which(count > 1)] = "Mixed"#
genre[which(count < 1)] = "None"#
genre[which(count == 1 & movies$Action == 1)] = "Action"#
genre[which(count == 1 & movies$Animation == 1)] = "Animation"#
genre[which(count == 1 & movies$Comedy == 1)] = "Comedy"#
genre[which(count == 1 & movies$Drama == 1)] = "Drama"#
genre[which(count == 1 & movies$Documentary == 1)] = "Documentary"#
genre[which(count == 1 & movies$Romance == 1)] = "Romance"#
genre[which(count == 1 & movies$Short == 1)] = "Short"#
#
## modify data: EuStockMarkets#
eu <- transform(data.frame(EuStockMarkets), time = time(EuStockMarkets))
movies
MSAN 622#
## Jeremy Gilmore#
## Homework 1#
#
library(ggplot2)#
data(movies)#
data(EuStockMarkets)#
#
## modify data: movies#
movies=movies[!(movies$budget<=0),]#
##subset(dataframe, )#
genre <- rep(NA, nrow(movies))#
count <- rowSums(movies[, 18:24])#
genre[which(count > 1)] = "Mixed"#
genre[which(count < 1)] = "None"#
genre[which(count == 1 & movies$Action == 1)] = "Action"#
genre[which(count == 1 & movies$Animation == 1)] = "Animation"#
genre[which(count == 1 & movies$Comedy == 1)] = "Comedy"#
genre[which(count == 1 & movies$Drama == 1)] = "Drama"#
genre[which(count == 1 & movies$Documentary == 1)] = "Documentary"#
genre[which(count == 1 & movies$Romance == 1)] = "Romance"#
genre[which(count == 1 & movies$Short == 1)] = "Short"#
#
## modify data: EuStockMarkets#
eu <- transform(data.frame(EuStockMarkets), time = time(EuStockMarkets))
movies
library(ggplot2)#
data(movies)#
data(EuStockMarkets)
movies
movies=movies[!(movies$budget<=0 | movies$budget=="NA"),]
movies
MSAN 622#
## Jeremy Gilmore#
## Homework 1#
#
library(ggplot2)#
data(movies)#
data(EuStockMarkets)#
#
## modify data: movies#
movies=movies[(movies$budget>0),]#
##subset(dataframe, )#
genre <- rep(NA, nrow(movies))#
count <- rowSums(movies[, 18:24])#
genre[which(count > 1)] = "Mixed"#
genre[which(count < 1)] = "None"#
genre[which(count == 1 & movies$Action == 1)] = "Action"#
genre[which(count == 1 & movies$Animation == 1)] = "Animation"#
genre[which(count == 1 & movies$Comedy == 1)] = "Comedy"#
genre[which(count == 1 & movies$Drama == 1)] = "Drama"#
genre[which(count == 1 & movies$Documentary == 1)] = "Documentary"#
genre[which(count == 1 & movies$Romance == 1)] = "Romance"#
genre[which(count == 1 & movies$Short == 1)] = "Short"#
#
## modify data: EuStockMarkets#
eu <- transform(data.frame(EuStockMarkets), time = time(EuStockMarkets))
movies
library(ggplot2)#
data(movies)#
data(EuStockMarkets)
budget
movies$budget
MSAN 622#
## Jeremy Gilmore#
## Homework 1#
#
library(ggplot2)#
data(movies)#
data(EuStockMarkets)#
#
## modify data: movies#
##movies=movies[(movies$budget>0),]#
##subset(dataframe, )#
genre <- rep(NA, nrow(movies))#
count <- rowSums(movies[, 18:24])#
genre[which(count > 1)] = "Mixed"#
genre[which(count < 1)] = "None"#
genre[which(count == 1 & movies$Action == 1)] = "Action"#
genre[which(count == 1 & movies$Animation == 1)] = "Animation"#
genre[which(count == 1 & movies$Comedy == 1)] = "Comedy"#
genre[which(count == 1 & movies$Drama == 1)] = "Drama"#
genre[which(count == 1 & movies$Documentary == 1)] = "Documentary"#
genre[which(count == 1 & movies$Romance == 1)] = "Romance"#
genre[which(count == 1 & movies$Short == 1)] = "Short"#
#
## modify data: EuStockMarkets#
eu <- transform(data.frame(EuStockMarkets), time = time(EuStockMarkets))
budget
library(ggplot2)#
library(shiny)#
#
data("movies", package = "ggplot2")#
#
start <- which(colnames(movies) == "Action")#
#
end <- which (colnames(movies) == "Short")#
#
genres <- colnames(movies)[start:end]#
#
counts <- rep(0, lengeth(genres))#
#
for(i in 1:length(genres)) {#
	counts[i] <- sum(movies[, genres[i]])#
}#
#
df <- data.frame(factor(genres), counts)#
colnames(df) <- c("Genres", "Counts")#
#
p <- ggplot(df, aes(x = Genres, y = Counts, fill = Genres))#
#
p <- p + geom_bar(stat="identity")#
#
print(p)
library(ggplot2)#
library(shiny)#
#
data("movies", package = "ggplot2")#
#
start <- which(colnames(movies) == "Action")#
#
end <- which (colnames(movies) == "Short")#
#
genres <- colnames(movies)[start:end]#
#
counts <- rep(0, length(genres))#
#
for(i in 1:length(genres)) {#
	counts[i] <- sum(movies[, genres[i]])#
}#
#
df <- data.frame(factor(genres), counts)#
colnames(df) <- c("Genres", "Counts")#
#
p <- ggplot(df, aes(x = Genres, y = Counts, fill = Genres))#
#
p <- p + geom_bar(stat="identity")#
#
print(p)
library(ggplot2)#
library(shiny)#
#
data("movies", package = "ggplot2")#
#
start <- which(colnames(movies) == "Action")#
#
end <- which (colnames(movies) == "Short")#
#
genres <- colnames(movies)[start:end]#
#
counts <- rep(0, length(genres))#
#
for(i in 1:length(genres)) {#
	counts[i] <- sum(movies[, genres[i]])#
}#
#
df <- data.frame(factor(genres), counts)#
colnames(df) <- c("Genres", "Counts")#
#
## How to Sort by Bars#
sortOrder <- order(df$Counts, decreasing = FALSE)#
p <- ggplot(df, aes(x = Genres, y = Counts, fill = Genres))#
#
p <- p + geom_bar(stat="identity")#
#
print(p)
library(ggplot2)#
library(shiny)#
#
data("movies", package = "ggplot2")#
#
start <- which(colnames(movies) == "Action")#
#
end <- which (colnames(movies) == "Short")#
#
genres <- colnames(movies)[start:end]#
#
counts <- rep(0, length(genres))#
#
for(i in 1:length(genres)) {#
	counts[i] <- sum(movies[, genres[i]])#
}#
#
df <- data.frame(factor(genres), counts)#
colnames(df) <- c("Genres", "Counts")#
#
## How to Sort by Bars#
sortOrder <- order(df$Counts, decreasing = FALSE)#
df$Genres <- factor(df$Genres[sortOrder])#
#
p <- ggplot(df, aes(x = Genres, y = Counts, fill = Genres))#
#
p <- p + geom_bar(stat="identity")#
#
print(p)
library(ggplot2)#
library(shiny)#
#
data("movies", package = "ggplot2")#
#
start <- which(colnames(movies) == "Action")#
#
end <- which (colnames(movies) == "Short")#
#
genres <- colnames(movies)[start:end]#
#
counts <- rep(0, length(genres))#
#
for(i in 1:length(genres)) {#
	counts[i] <- sum(movies[, genres[i]])#
}#
#
df <- data.frame(factor(genres), counts)#
colnames(df) <- c("Genres", "Counts")#
#
## How to Sort by Bars#
sortOrder <- order(df$Counts, decreasing = FALSE)#
df$Genres <- factor(df$Genres, levels = df$Genres[sortOrder])#
#
p <- ggplot(df, aes(x = Genres, y = Counts, fill = Genres))#
#
p <- p + geom_bar(stat="identity")#
#
print(p)
library(ggplot2)#
library(shiny)#
#
data("movies", package = "ggplot2")#
#
start <- which(colnames(movies) == "Action")#
#
end <- which (colnames(movies) == "Short")#
#
genres <- colnames(movies)[start:end]#
#
counts <- rep(0, length(genres))#
#
for(i in 1:length(genres)) {#
	counts[i] <- sum(movies[, genres[i]])#
}#
#
df <- data.frame(factor(genres), counts)#
colnames(df) <- c("Genres", "Counts")#
#
## How to Sort by Bars#
sortOrder <- order(df$Counts, decreasing = FALSE)#
df$Genres <- factor(df$Genres, levels = df$Genres[sortOrder])#
#
p <- ggplot(df, aes(x = Genres, y = Counts, fill = Genres))#
#
p <- p + geom_bar(stat="identity")#
#
p <- p + xlab("Movie Genre")#
p <- p + ylab("Count in 1000s")#
p <- p + ggtitle("Movies by Genre")#
p <- p + labs(fill = "Movie Genres")#
#
thousand_formatter <- function(x) {#
	label <- x / 1000#
}#
#
p <- p + scale_y_continuous(#
	label = thousand_formatter#
	)#
#
print(p)
library(ggplot2)#
library(shiny)#
#
data("movies", package = "ggplot2")#
#
start <- which(colnames(movies) == "Action")#
#
end <- which (colnames(movies) == "Short")#
#
genres <- colnames(movies)[start:end]#
#
counts <- rep(0, length(genres))#
#
for(i in 1:length(genres)) {#
	counts[i] <- sum(movies[, genres[i]])#
}#
#
df <- data.frame(factor(genres), counts)#
colnames(df) <- c("Genres", "Counts")#
#
## How to Sort by Bars#
sortOrder <- order(df$Counts, decreasing = FALSE)#
df$Genres <- factor(df$Genres, levels = df$Genres[sortOrder])#
#
p <- ggplot(df, aes(x = Genres, y = Counts, fill = Genres))#
#
p <- p + geom_bar(stat="identity")#
#
p <- p + xlab("Movie Genre")#
p <- p + ylab("Count in 1000s")#
p <- p + ggtitle("Movies by Genre")#
p <- p + labs(fill = "Movie Genres")#
#
##thousand_formatter <- function(x) {#
##	label <- x / 1000#
##}#
#
thousand_formatter <- funciton(x) {#
	return(sprintf("%dk", round(x / 1000))) # d is digit, f would be floating#
}#
p <- p + scale_y_continuous(#
	label = thousand_formatter#
	)#
print(p)
library(ggplot2)#
library(shiny)#
#
data("movies", package = "ggplot2")#
#
start <- which(colnames(movies) == "Action")#
#
end <- which (colnames(movies) == "Short")#
#
genres <- colnames(movies)[start:end]#
#
counts <- rep(0, length(genres))#
#
for(i in 1:length(genres)) {#
	counts[i] <- sum(movies[, genres[i]])#
}#
#
df <- data.frame(factor(genres), counts)#
colnames(df) <- c("Genres", "Counts")#
#
## How to Sort by Bars#
sortOrder <- order(df$Counts, decreasing = FALSE)#
df$Genres <- factor(df$Genres, levels = df$Genres[sortOrder])#
#
p <- ggplot(df, aes(x = Genres, y = Counts, fill = Genres))#
#
p <- p + geom_bar(stat="identity")#
#
p <- p + xlab("Movie Genre")#
p <- p + ylab("Count in 1000s")#
p <- p + ggtitle("Movies by Genre")#
p <- p + labs(fill = "Movie Genres")#
#
##thousand_formatter <- function(x) {#
##	label <- x / 1000#
##}#
#
thousand_formatter <- function(x) {#
	return(sprintf("%dk", round(x / 1000))) # d is digit, f would be floating#
}#
p <- p + scale_y_continuous(#
	label = thousand_formatter#
	)#
print(p)
library(ggplot2)#
library(shiny)#
#
data("movies", package = "ggplot2")#
#
start <- which(colnames(movies) == "Action")#
#
end <- which (colnames(movies) == "Short")#
#
genres <- colnames(movies)[start:end]#
#
counts <- rep(0, length(genres))#
#
for(i in 1:length(genres)) {#
	counts[i] <- sum(movies[, genres[i]])#
}#
#
df <- data.frame(factor(genres), counts)#
colnames(df) <- c("Genres", "Counts")#
#
## How to Sort by Bars#
sortOrder <- order(df$Counts, decreasing = FALSE)#
df$Genres <- factor(df$Genres, levels = df$Genres[sortOrder])#
#
p <- ggplot(df, aes(x = Genres, y = Counts, fill = Genres))#
#
p <- p + geom_bar(stat="identity")#
#
p <- p + xlab("Movie Genre")#
p <- p + ylab("Count in 1000s")#
p <- p + ggtitle("Movies by Genre")#
p <- p + labs(fill = "Movie Genres")#
#
##thousand_formatter <- function(x) {#
##	label <- x / 1000#
##}#
#
thousand_formatter <- function(x) {#
	return(sprintf("%dk", round(x / 1000))) # d is digit, f would be floating#
}#
p <- p + scale_y_continuous(#
	expand = c(0,500),#
	label = thousand_formatter#
	)#
print(p)
library(ggplot2)#
library(shiny)#
#
data("movies", package = "ggplot2")#
#
start <- which(colnames(movies) == "Action")#
#
end <- which (colnames(movies) == "Short")#
#
genres <- colnames(movies)[start:end]#
#
counts <- rep(0, length(genres))#
#
for(i in 1:length(genres)) {#
	counts[i] <- sum(movies[, genres[i]])#
}#
#
df <- data.frame(factor(genres), counts)#
colnames(df) <- c("Genres", "Counts")#
#
## How to Sort by Bars#
sortOrder <- order(df$Counts, decreasing = FALSE)#
df$Genres <- factor(df$Genres, levels = df$Genres[sortOrder])#
#
p <- ggplot(df, aes(x = Genres, y = Counts, fill = Genres))#
#
p <- p + geom_bar(stat="identity")#
#
p <- p + xlab("Movie Genre")#
p <- p + ylab("Count in 1000s")#
p <- p + ggtitle("Movies by Genre")#
p <- p + labs(fill = "Movie Genres")#
#
##thousand_formatter <- function(x) {#
##	label <- x / 1000#
##}#
#
thousand_formatter <- function(x) {#
	return(sprintf("%dk", round(x / 1000))) # d is digit, f would be floating#
}#
p <- p + scale_y_continuous(#
	expand = c(0,0),#
	label = thousand_formatter#
	)#
print(p)
library(ggplot2)#
library(shiny)#
#
data("movies", package = "ggplot2")#
#
start <- which(colnames(movies) == "Action")#
#
end <- which (colnames(movies) == "Short")#
#
genres <- colnames(movies)[start:end]#
#
counts <- rep(0, length(genres))#
#
for(i in 1:length(genres)) {#
	counts[i] <- sum(movies[, genres[i]])#
}#
#
df <- data.frame(factor(genres), counts)#
colnames(df) <- c("Genres", "Counts")#
#
## How to Sort by Bars#
sortOrder <- order(df$Counts, decreasing = FALSE)#
df$Genres <- factor(df$Genres, levels = df$Genres[sortOrder])#
#
p <- ggplot(df, aes(x = Genres, y = Counts, fill = Genres))#
#
p <- p + geom_bar(stat="identity")#
#
p <- p + xlab("Movie Genre")#
p <- p + ylab("Count in 1000s")#
p <- p + ggtitle("Movies by Genre")#
p <- p + labs(fill = "Movie Genres")#
#
##thousand_formatter <- function(x) {#
##	label <- x / 1000#
##}#
#
thousand_formatter <- function(x) {#
	return(sprintf("%dk", round(x / 1000))) # d is digit, f would be floating#
}#
p <- p + scale_y_continuous(#
	expand = c(0,20), # removes padding at bottom#
	label = thousand_formatter#
	)#
print(p)
library(ggplot2)#
library(shiny)#
#
data("movies", package = "ggplot2")#
#
start <- which(colnames(movies) == "Action")#
#
end <- which (colnames(movies) == "Short")#
#
genres <- colnames(movies)[start:end]#
#
counts <- rep(0, length(genres))#
#
for(i in 1:length(genres)) {#
	counts[i] <- sum(movies[, genres[i]])#
}#
#
df <- data.frame(factor(genres), counts)#
colnames(df) <- c("Genres", "Counts")#
#
## How to Sort by Bars#
sortOrder <- order(df$Counts, decreasing = FALSE)#
df$Genres <- factor(df$Genres, levels = df$Genres[sortOrder])#
#
p <- ggplot(df, aes(x = Genres, y = Counts, fill = Genres))#
#
p <- p + geom_bar(stat="identity")#
#
p <- p + xlab("Movie Genre")#
p <- p + ylab("Count in 1000s")#
p <- p + ggtitle("Movies by Genre")#
p <- p + labs(fill = "Movie Genres")#
#
##thousand_formatter <- function(x) {#
##	label <- x / 1000#
##}#
#
thousand_formatter <- function(x) {#
	return(sprintf("%dk", round(x / 1000))) # d is digit, f would be floating#
}#
p <- p + scale_y_continuous(#
	expand = c(0,20), # removes padding at bottom#
	label = thousand_formatter#
	)#
#
p <- p + theme(axis.title.x = element())#
print(p)
library(ggplot2)#
library(shiny)#
#
data("movies", package = "ggplot2")#
#
start <- which(colnames(movies) == "Action")#
#
end <- which (colnames(movies) == "Short")#
#
genres <- colnames(movies)[start:end]#
#
counts <- rep(0, length(genres))#
#
for(i in 1:length(genres)) {#
	counts[i] <- sum(movies[, genres[i]])#
}#
#
df <- data.frame(factor(genres), counts)#
colnames(df) <- c("Genres", "Counts")#
#
## How to Sort by Bars#
sortOrder <- order(df$Counts, decreasing = FALSE)#
df$Genres <- factor(df$Genres, levels = df$Genres[sortOrder])#
#
p <- ggplot(df, aes(x = Genres, y = Counts, fill = Genres))#
#
p <- p + geom_bar(stat="identity")#
#
p <- p + xlab("Movie Genre")#
p <- p + ylab("Count in 1000s")#
p <- p + ggtitle("Movies by Genre")#
p <- p + labs(fill = "Movie Genres")#
#
##thousand_formatter <- function(x) {#
##	label <- x / 1000#
##}#
#
thousand_formatter <- function(x) {#
	return(sprintf("%dk", round(x / 1000))) # d is digit, f would be floating#
}#
p <- p + scale_y_continuous(#
	expand = c(0,20), # removes padding at bottom#
	label = thousand_formatter#
	)#
#
p <- p + theme(axis.title.x = element())#
p <- p + theme(axis.title.y = element())#
print(p)
library(ggplot2)#
library(shiny)#
#
data("movies", package = "ggplot2")#
#
start <- which(colnames(movies) == "Action")#
#
end <- which (colnames(movies) == "Short")#
#
genres <- colnames(movies)[start:end]#
#
counts <- rep(0, length(genres))#
#
for(i in 1:length(genres)) {#
	counts[i] <- sum(movies[, genres[i]])#
}#
#
df <- data.frame(factor(genres), counts)#
colnames(df) <- c("Genres", "Counts")#
#
## How to Sort by Bars#
sortOrder <- order(df$Counts, decreasing = FALSE)#
df$Genres <- factor(df$Genres, levels = df$Genres[sortOrder])#
#
p <- ggplot(df, aes(x = Genres, y = Counts, fill = Genres))#
#
p <- p + geom_bar(stat="identity")#
#
p <- p + xlab("Movie Genre")#
p <- p + ylab("Count in 1000s")#
p <- p + ggtitle("Movies by Genre")#
p <- p + labs(fill = "Movie Genres")#
#
##thousand_formatter <- function(x) {#
##	label <- x / 1000#
##}#
#
thousand_formatter <- function(x) {#
	return(sprintf("%dk", round(x / 1000))) # d is digit, f would be floating#
}#
p <- p + scale_y_continuous(#
	expand = c(0,20), # removes padding at bottom#
	label = thousand_formatter#
	)#
#
p <- p + theme(axis.title.x = element_blank())#
p <- p + theme(axis.title.y = element_blank())#
p <- p + theme(legend.position = "none")#
print(p)
library(ggplot2)#
library(shiny)#
#
data("movies", package = "ggplot2")#
#
start <- which(colnames(movies) == "Action")#
#
end <- which (colnames(movies) == "Short")#
#
genres <- colnames(movies)[start:end]#
#
counts <- rep(0, length(genres))#
#
for(i in 1:length(genres)) {#
	counts[i] <- sum(movies[, genres[i]])#
}#
#
df <- data.frame(factor(genres), counts)#
colnames(df) <- c("Genres", "Counts")#
#
## How to Sort by Bars#
sortOrder <- order(df$Counts, decreasing = FALSE)#
df$Genres <- factor(df$Genres, levels = df$Genres[sortOrder])#
#
p <- ggplot(df, aes(x = Genres, y = Counts, fill = Genres))#
#
p <- p + geom_bar(stat="identity")#
#
p <- p + xlab("Movie Genre")#
p <- p + ylab("Count in 1000s")#
p <- p + ggtitle("Movies by Genre")#
p <- p + labs(fill = "Movie Genres")#
#
##thousand_formatter <- function(x) {#
##	label <- x / 1000#
##}#
#
thousand_formatter <- function(x) {#
	return(sprintf("%dk", round(x / 1000))) # d is digit, f would be floating#
}#
p <- p + scale_y_continuous(#
	expand = c(0,20), # removes padding at bottom#
	label = thousand_formatter#
	)#
#
p <- p + theme(axis.title.x = element_blank())#
p <- p + theme(axis.title.y = element_blank())#
p <- p + theme(legend.position = "none")#
p <- p + theme(axis.ticks.x = element_blank())#
print(p)
library(ggplot2)#
library(shiny)#
#
data("movies", package = "ggplot2")#
#
start <- which(colnames(movies) == "Action")#
#
end <- which (colnames(movies) == "Short")#
#
genres <- colnames(movies)[start:end]#
#
counts <- rep(0, length(genres))#
#
for(i in 1:length(genres)) {#
	counts[i] <- sum(movies[, genres[i]])#
}#
#
df <- data.frame(factor(genres), counts)#
colnames(df) <- c("Genres", "Counts")#
#
## How to Sort by Bars#
sortOrder <- order(df$Counts, decreasing = FALSE)#
df$Genres <- factor(df$Genres, levels = df$Genres[sortOrder])#
#
p <- ggplot(df, aes(x = Genres, y = Counts, fill = Genres))#
#
p <- p + geom_bar(stat="identity")#
#
p <- p + xlab("Movie Genre")#
p <- p + ylab("Count in 1000s")#
p <- p + ggtitle("Movies by Genre")#
p <- p + labs(fill = "Movie Genres")#
#
##thousand_formatter <- function(x) {#
##	label <- x / 1000#
##}#
#
thousand_formatter <- function(x) {#
	return(sprintf("%dk", round(x / 1000))) # d is digit, f would be floating#
}#
p <- p + scale_y_continuous(#
	expand = c(0,20), # removes padding at bottom#
	label = thousand_formatter#
	)#
#
p <- p + theme(axis.title.x = element_blank())#
p <- p + theme(axis.title.y = element_blank())#
p <- p + theme(legend.position = "none")#
p <- p + theme(axis.ticks.x = element_blank())#
p <- p + theme(panel.grid.major.x = element_blank())#
print(p)
library(ggplot2)#
library(shiny)#
#
data("movies", package = "ggplot2")#
#
start <- which(colnames(movies) == "Action")#
#
end <- which (colnames(movies) == "Short")#
#
genres <- colnames(movies)[start:end]#
#
counts <- rep(0, length(genres))#
#
for(i in 1:length(genres)) {#
	counts[i] <- sum(movies[, genres[i]])#
}#
#
df <- data.frame(factor(genres), counts)#
colnames(df) <- c("Genres", "Counts")#
#
## How to Sort by Bars#
sortOrder <- order(df$Counts, decreasing = FALSE)#
df$Genres <- factor(df$Genres, levels = df$Genres[sortOrder])#
#
p <- ggplot(df, aes(x = Genres, y = Counts, fill = Genres))#
#
p <- p + geom_bar(stat="identity")#
#
p <- p + xlab("Movie Genre")#
p <- p + ylab("Count in 1000s")#
p <- p + ggtitle("Movies by Genre")#
p <- p + labs(fill = "Movie Genres")#
#
##thousand_formatter <- function(x) {#
##	label <- x / 1000#
##}#
#
thousand_formatter <- function(x) {#
	return(sprintf("%dk", round(x / 1000))) # d is digit, f would be floating#
}#
p <- p + scale_y_continuous(#
	expand = c(0,20), # removes padding at bottom#
	label = thousand_formatter#
	)#
#
p <- p + theme(axis.title.x = element_blank())#
p <- p + theme(axis.title.y = element_blank())#
p <- p + theme(legend.position = "none")#
p <- p + theme(axis.ticks.x = element_blank())#
p <- p + theme(panel.grid.major.x = element_blank())#
p <- p + theme(panel.grid.minor.y = element_blank())#
print(p)
library(ggplot2)#
library(shiny)#
#
data("movies", package = "ggplot2")#
#
start <- which(colnames(movies) == "Action")#
#
end <- which (colnames(movies) == "Short")#
#
genres <- colnames(movies)[start:end]#
#
counts <- rep(0, length(genres))#
#
for(i in 1:length(genres)) {#
	counts[i] <- sum(movies[, genres[i]])#
}#
#
df <- data.frame(factor(genres), counts)#
colnames(df) <- c("Genres", "Counts")#
#
## How to Sort by Bars#
sortOrder <- order(df$Counts, decreasing = FALSE)#
df$Genres <- factor(df$Genres, levels = df$Genres[sortOrder])#
#
p <- ggplot(df, aes(x = Genres, y = Counts, fill = Genres))#
#
p <- p + geom_bar(stat="identity")#
#
p <- p + xlab("Movie Genre")#
p <- p + ylab("Count in 1000s")#
p <- p + ggtitle("Movies by Genre")#
p <- p + labs(fill = "Movie Genres")#
#
##thousand_formatter <- function(x) {#
##	label <- x / 1000#
##}#
#
thousand_formatter <- function(x) {#
	return(sprintf("%dk", round(x / 1000))) # d is digit, f would be floating#
}#
p <- p + scale_y_continuous(#
	expand = c(0,40), # removes padding at bottom#
	label = thousand_formatter#
	)#
#
p <- p + theme(axis.title.x = element_blank())#
p <- p + theme(axis.title.y = element_blank())#
p <- p + theme(legend.position = "none")#
p <- p + theme(axis.ticks.x = element_blank())#
p <- p + theme(panel.grid.major.x = element_blank())#
p <- p + theme(panel.grid.minor.y = element_blank())#
print(p)
library(ggplot2)#
library(shiny)#
#
data("movies", package = "ggplot2")#
#
start <- which(colnames(movies) == "Action")#
#
end <- which (colnames(movies) == "Short")#
#
genres <- colnames(movies)[start:end]#
#
counts <- rep(0, length(genres))#
#
for(i in 1:length(genres)) {#
	counts[i] <- sum(movies[, genres[i]])#
}#
#
df <- data.frame(factor(genres), counts)#
colnames(df) <- c("Genres", "Counts")#
#
## How to Sort by Bars#
sortOrder <- order(df$Counts, decreasing = FALSE)#
df$Genres <- factor(df$Genres, levels = df$Genres[sortOrder])#
#
p <- ggplot(df, aes(x = Genres, y = Counts, fill = Genres))#
#
p <- p + geom_bar(stat="identity")#
#
p <- p + xlab("Movie Genre")#
p <- p + ylab("Count in 1000s")#
p <- p + ggtitle("Movies by Genre")#
p <- p + labs(fill = "Movie Genres")#
#
##thousand_formatter <- function(x) {#
##	label <- x / 1000#
##}#
#
thousand_formatter <- function(x) {#
	return(sprintf("%dk", round(x / 1000))) # d is digit, f would be floating#
}#
p <- p + scale_y_continuous(#
	expand = c(0,500), # removes padding at bottom#
	label = thousand_formatter#
	)#
#
p <- p + theme(axis.title.x = element_blank())#
p <- p + theme(axis.title.y = element_blank())#
p <- p + theme(legend.position = "none")#
p <- p + theme(axis.ticks.x = element_blank())#
p <- p + theme(panel.grid.major.x = element_blank())#
p <- p + theme(panel.grid.minor.y = element_blank())#
p <- p + theme(axis.text.x = element_text(size=12))#
print(p)
library(ggplot2)#
library(shiny)#
#
data("movies", package = "ggplot2")#
#
start <- which(colnames(movies) == "Action")#
#
end <- which (colnames(movies) == "Short")#
#
genres <- colnames(movies)[start:end]#
#
counts <- rep(0, length(genres))#
#
for(i in 1:length(genres)) {#
	counts[i] <- sum(movies[, genres[i]])#
}#
#
df <- data.frame(factor(genres), counts)#
colnames(df) <- c("Genres", "Counts")#
#
## How to Sort by Bars#
sortOrder <- order(df$Counts, decreasing = FALSE)#
df$Genres <- factor(df$Genres, levels = df$Genres[sortOrder])#
#
p <- ggplot(df, aes(x = Genres, y = Counts, fill = Genres))#
#
p <- p + geom_bar(stat="identity")#
#
p <- p + xlab("Movie Genre")#
p <- p + ylab("Count in 1000s")#
p <- p + ggtitle("Movies by Genre")#
p <- p + labs(fill = "Movie Genres")#
#
##thousand_formatter <- function(x) {#
##	label <- x / 1000#
##}#
#
thousand_formatter <- function(x) {#
	return(sprintf("%dk", round(x / 1000))) # d is digit, f would be floating#
}#
p <- p + scale_y_continuous(#
	expand = c(0,200), # removes padding at bottom#
	label = thousand_formatter#
	)#
#
p <- p + theme(axis.title.x = element_blank())#
p <- p + theme(axis.title.y = element_blank())#
p <- p + theme(legend.position = "none")#
p <- p + theme(axis.ticks.x = element_blank())#
p <- p + theme(panel.grid.major.x = element_blank())#
p <- p + theme(panel.grid.minor.y = element_blank())#
p <- p + theme(axis.text.x = element_text(size=12))#
print(p)
library(ggplot2)#
library(shiny)#
#
data("movies", package = "ggplot2")#
#
start <- which(colnames(movies) == "Action")#
#
end <- which (colnames(movies) == "Short")#
#
genres <- colnames(movies)[start:end]#
#
counts <- rep(0, length(genres))#
#
for(i in 1:length(genres)) {#
	counts[i] <- sum(movies[, genres[i]])#
}#
#
df <- data.frame(factor(genres), counts)#
colnames(df) <- c("Genres", "Counts")#
#
## How to Sort by Bars#
sortOrder <- order(df$Counts, decreasing = FALSE)#
df$Genres <- factor(df$Genres, levels = df$Genres[sortOrder])#
#
p <- ggplot(df, aes(x = Genres, y = Counts, fill = Genres))#
#
p <- p + geom_bar(stat="identity")#
#
p <- p + xlab("Movie Genre")#
p <- p + ylab("Count in 1000s")#
p <- p + ggtitle("Movies by Genre")#
p <- p + labs(fill = "Movie Genres")#
#
##thousand_formatter <- function(x) {#
##	label <- x / 1000#
##}#
#
thousand_formatter <- function(x) {#
	return(sprintf("%dk", round(x / 1000))) # d is digit, f would be floating#
}#
p <- p + scale_y_continuous(#
	expand = c(0,200), # removes padding at bottom#
	label = thousand_formatter#
	)#
#
p <- p + theme(axis.title.x = element_blank())#
p <- p + theme(axis.title.y = element_blank())#
p <- p + theme(legend.position = "none")#
p <- p + theme(axis.ticks.x = element_blank())#
p <- p + theme(panel.grid.major.x = element_blank())#
p <- p + theme(panel.grid.minor.y = element_blank())#
p <- p + theme(axis.text.x = element_text(size=12))#
p <- p + scale_color_brewer(type = "qual", palette = "Set3")#
print(p)
library(ggplot2)#
library(shiny)#
#
data("movies", package = "ggplot2")#
#
start <- which(colnames(movies) == "Action")#
#
end <- which (colnames(movies) == "Short")#
#
genres <- colnames(movies)[start:end]#
#
counts <- rep(0, length(genres))#
#
for(i in 1:length(genres)) {#
	counts[i] <- sum(movies[, genres[i]])#
}#
#
df <- data.frame(factor(genres), counts)#
colnames(df) <- c("Genres", "Counts")#
#
## How to Sort by Bars#
sortOrder <- order(df$Counts, decreasing = FALSE)#
df$Genres <- factor(df$Genres, levels = df$Genres[sortOrder])#
#
p <- ggplot(df, aes(x = Genres, y = Counts, fill = Genres))#
#
p <- p + geom_bar(stat="identity")#
#
p <- p + xlab("Movie Genre")#
p <- p + ylab("Count in 1000s")#
p <- p + ggtitle("Movies by Genre")#
p <- p + labs(fill = "Movie Genres")#
#
##thousand_formatter <- function(x) {#
##	label <- x / 1000#
##}#
#
thousand_formatter <- function(x) {#
	return(sprintf("%dk", round(x / 1000))) # d is digit, f would be floating#
}#
p <- p + scale_y_continuous(#
	expand = c(0,200), # removes padding at bottom#
	label = thousand_formatter#
	)#
#
p <- p + theme(axis.title.x = element_blank())#
p <- p + theme(axis.title.y = element_blank())#
p <- p + theme(legend.position = "none")#
p <- p + theme(axis.ticks.x = element_blank())#
p <- p + theme(panel.grid.major.x = element_blank())#
p <- p + theme(panel.grid.minor.y = element_blank())#
p <- p + theme(axis.text.x = element_text(size=12))#
p <- p + scale_fill_brewer(type = "qual", palette = "Set3")#
print(p)
library(ggplot2)#
library(shiny)#
#
data("movies", package = "ggplot2")#
#
start <- which(colnames(movies) == "Action")#
#
end <- which (colnames(movies) == "Short")#
#
genres <- colnames(movies)[start:end]#
#
counts <- rep(0, length(genres))#
#
for(i in 1:length(genres)) {#
	counts[i] <- sum(movies[, genres[i]])#
}#
#
df <- data.frame(factor(genres), counts)#
colnames(df) <- c("Genres", "Counts")#
#
## How to Sort by Bars#
sortOrder <- order(df$Counts, decreasing = FALSE)#
df$Genres <- factor(df$Genres, levels = df$Genres[sortOrder])#
#
p <- ggplot(df, aes(x = Genres, y = Counts, fill = Genres, color = "red"))#
#
p <- p + geom_bar(stat="identity")#
#
p <- p + xlab("Movie Genre")#
p <- p + ylab("Count in 1000s")#
p <- p + ggtitle("Movies by Genre")#
p <- p + labs(fill = "Movie Genres")#
#
##thousand_formatter <- function(x) {#
##	label <- x / 1000#
##}#
#
thousand_formatter <- function(x) {#
	return(sprintf("%dk", round(x / 1000))) # d is digit, f would be floating#
}#
p <- p + scale_y_continuous(#
	expand = c(0,200), # removes padding at bottom#
	label = thousand_formatter#
	)#
#
p <- p + theme(axis.title.x = element_blank())#
p <- p + theme(axis.title.y = element_blank())#
p <- p + theme(legend.position = "none")#
p <- p + theme(axis.ticks.x = element_blank())#
p <- p + theme(panel.grid.major.x = element_blank())#
p <- p + theme(panel.grid.minor.y = element_blank())#
p <- p + theme(axis.text.x = element_text(size=12))#
p <- p + scale_fill_brewer(type = "qual", palette = "Set3")#
#
palette1 <- c("...")#
p <- p + scale_fill_manual(value = "palette1")#
#
p <- p + scale_fill_grey(start = 0.4 end 0.4)#
print(p)
if (!require("devtools"))#
  install.packages("devtools")#
devtools::install_github("shiny", "rstudio")
library()
Server File#
# library(ggplot2)#
# library(shiny)#
#
# shinyServer(function(input, output) {#
	# localFrame <- globalData #copy of global#
	# sortOrder <- reactive({#
		# if (input$sortColumn == "Genre") {#
			# return(#
				# order(localFrame$Genre,#
					# descending = input$sortDescending))#
		# }#
		# else {#
			# return(#
				# )#
		# }#
	# })#
	# output$scatterPlot <- renderPlot({#
		# scatterPlot <- getPlot(localFrame, sortOrder(), ""None"") #getPlot function#
		# print(scatterPlot)#
	# })#
## Jeremy Gilmore#
## MSAN 622#
#
## Homework 2#
#
library(ggplot2)#
library(scales)#
data(movies)#
#
## modify data: movies#
movies=movies[which(!movies$budget<=0 & !movies$mpaa==""),]#
genre <- rep(NA, nrow(movies))#
count <- rowSums(movies[, 18:24])#
genre[which(count > 1)] = "Mixed"#
genre[which(count < 1)] = "None"#
genre[which(count == 1 & movies$Action == 1)] = "Action"#
genre[which(count == 1 & movies$Animation == 1)] = "Animation"#
genre[which(count == 1 & movies$Comedy == 1)] = "Comedy"#
genre[which(count == 1 & movies$Drama == 1)] = "Drama"#
genre[which(count == 1 & movies$Documentary == 1)] = "Documentary"#
genre[which(count == 1 & movies$Romance == 1)] = "Romance"#
genre[which(count == 1 & movies$Short == 1)] = "Short"#
movies$Genre<-genre#
#
million_formatter <- function(x) {#
	#label <- round(x / 1000000)#
	return(sprintf("$%sM", round(x / 1000000)))#
}#
#
getPlot <- function(alphaVal,genreVal,mpaaVal,pointVal,colorScheme) {#
	subMovies <- subset(movies, (movies$Genre %in% genreVal) & (movies$mpaa %in% mpaaVal), c(budget, mpaa, rating))#
	MPAA <- factor(subMovies$mpaa, levels=c("PG", "PG-13", "R", "NC-17"))#
#
	assign("subMovies", subMovies, envir=globalenv())#
	assign("MPAA", MPAA, envir=globalenv())#
	p <- ggplot(subMovies,#
		aes(x= subMovies$budget, y= subMovies$rating,#
		colour=MPAA)) +#
		geom_point(alpha=alphaVal, shape=20, size=pointVal) +#
		scale_y_continuous(breaks=seq(0,10,1), labels=seq(0,10,1)) +#
		scale_x_continuous(label = million_formatter) +#
		theme(legend.position="bottom") +#
		ggtitle("IMDB Movies Data") +#
		xlab("Budget in Millions of USD") +#
		ylab("IMDB Ratings")#
#
	if (colorScheme == "Default") {#
		p <- p#
	}#
	else {#
		p <- p + scale_color_brewer(palette = colorScheme)#
	}#
	return(p)#
}#
shinyServer(function(input, output) {#
	cat("Press \"ESC\" to exit...\n")#
#
	alphaVal <- reactive ({#
		input$alphaVals#
	})#
	genreVal <- reactive ({#
		input$genreVals#
	})#
	mpaaVal <- reactive ({#
		input$mpaaVals#
	})#
	pointVal <- reactive ({#
		input$pointVals#
	})#
	colorScheme <- reactive ({#
		input$colorSchemes#
	})#
#
	output$scatterPlot <- renderPlot ({#
		print(getPlot(alphaVal,genreVal,mpaaVal,pointVal,colorScheme))#
	})#
})
Iris dataset#
#
# Shiny example 3#
#
data("iris")#
#
p <- ggplot(iris, aes(x = Sepal.Length,#
						y = Sepal.Width,#
						color = Species))#
p <- geom_point(size=4)#
print(p)
p <- ggplot(iris, aes(x = Sepal.Length,
Iris dataset#
#
# Shiny example 3#
#
data("iris")#
#
p <- ggplot(iris, aes(x = Sepal.Length,#
						y = Sepal.Width,#
						color = Species))#
p <- geom_point(size=4)#
print(p)
Iris dataset#
#
# Shiny example 3#
#
data("iris")#
#
p <- ggplot(iris, aes(x = Sepal.Length,#
						y = Sepal.Width,#
						color = Species)))#
p <- geom_point(size=4)#
print(p)
Iris dataset#
#
# Shiny example 3#
#
data("iris")#
#
p <- ggplot(iris, aes(x = Sepal.Length,#
						y = Sepal.Width,#
						color = Species))#
p <- geom_point(size=4)#
print(p)
Iris dataset#
#
# Shiny example 3#
#
data("iris")#
#
p <- ggplot(iris, aes(x = Sepal.Length,#
						y = Sepal.Width,#
						color = Species))#
p <- p + geom_point(size=4)#
print(p)
Iris dataset#
#
# Shiny example 3#
library(ggplot2)#
#
data("iris")#
#
p <- ggplot(iris, aes(x = Sepal.Length,#
						y = Sepal.Width,#
						color = Species))#
p <- p + geom_point(size=4)#
print(p)
Jeremy Gilmore#
## MSAN 622#
#
## Homework 2#
#
library(ggplot2)#
library(shiny)#
library(scales)#
data(movies)#
movies=movies[which(!movies$budget<=0 & !movies$mpaa==""),]#
genre <- rep(NA, nrow(movies))#
count <- rowSums(movies[, 18:24])#
genre[which(count > 1)] = "Mixed"#
genre[which(count < 1)] = "None"#
genre[which(count == 1 & movies$Action == 1)] = "Action"#
genre[which(count == 1 & movies$Animation == 1)] = "Animation"#
genre[which(count == 1 & movies$Comedy == 1)] = "Comedy"#
genre[which(count == 1 & movies$Drama == 1)] = "Drama"#
genre[which(count == 1 & movies$Documentary == 1)] = "Documentary"#
genre[which(count == 1 & movies$Romance == 1)] = "Romance"#
genre[which(count == 1 & movies$Short == 1)] = "Short"#
movies$Genre<-genre#
#
million_formatter <- function(x) {#
	#label <- round(x / 1000000)#
	return(sprintf("$%sM", round(x / 1000000)))#
}#
#
getPlot <- function(alphaVal,genreVal,mpaaVal,pointVal,colorScheme) {#
	subMovies <- subset(movies, (movies$Genre %in% genreVal) & (movies$mpaa %in% mpaaVal), c(budget, mpaa, rating))#
	MPAA <- factor(subMovies$mpaa, levels=c("PG", "PG-13", "R", "NC-17"))#
#
	assign("subMovies", subMovies, envir=globalenv())#
	assign("MPAA", MPAA, envir=globalenv())#
	p <- ggplot(subMovies,#
		aes(x= subMovies$budget, y= subMovies$rating,#
		colour=MPAA)) +#
		geom_point(alpha=alphaVal, shape=20, size=pointVal) +#
		scale_y_continuous(breaks=seq(0,10,1), labels=seq(0,10,1)) +#
		scale_x_continuous(label = million_formatter) +#
		theme(legend.position="bottom") +#
		ggtitle("IMDB Movies Data") +#
		xlab("Budget in Millions of USD") +#
		ylab("IMDB Ratings")#
#
	if (colorScheme == "Default") {#
		p <- p#
	}#
	else {#
		p <- p + scale_color_brewer(palette = colorScheme)#
	}#
	return(p)#
}#
#
shinyServer(function(input, output) {#
	cat("Press \"ESC\" to exit...\n")#
#
	mpaaValS <- reactive ({#
		if (input$mpaaVal == "All") {#
			result <- c("PG", "PG-13", "R", "NC-17")#
			return(result)#
		}#
		else {#
			return(input$mpaaVal)#
		}#
	})#
#
	genreValS <- reactive ({#
		if(length(input$genreVal) == 0) {#
			result <- c("Action", "Animation", "Comedy", "Documentary", 					"Drama", "Romance", "Short")#
			return(result)#
		}#
		else {#
			return(input$genreVal)#
		}#
	})#
#
	# mpaaVal <- reactive ({#
		# input$mpaaVals#
	# })#
	# pointVal <- reactive ({#
		# input$pointVals#
	# })#
	# colorScheme <- reactive ({#
		# input$colorSchemes#
	# })#
#
	output$scatterPlot <- renderPlot ({#
		scatterPlot <- getPlot(input$alphaVal, (genreValS()), (mpaaValS()), 			input$pointVal, input$colorScheme)#
		print(scatterPlot)#
	})#
})
runApp()
update.packages(shiny)
update.packages(Shiny)
library()
update.packages("shiny")
library(shiny)
shiny::runGitHub('msan622', 'j-gilmore', 'homework2')
library(ggplot2)#
library(grid)#
#
data("iris")#
#
df <- iris#
#
p <- ggplot(df, aes(#
	x = Sepal.Length#
	y = Sepal.Width#
	color = Species#
	size = Petal.Length#
	))#
#
p <- p + geom_point(alpha = 0.6, position = "jitter")#
p <- p + scale_size_area(max_size=10)#
#
print(p)
library(ggplot2)#
library(grid)#
#
data("iris")#
#
df <- iris#
#
p <- ggplot(df, aes(#
	x = Sepal.Length,#
	y = Sepal.Width,#
	color = Species,#
	size = Petal.Length#
	))#
#
p <- p + geom_point(alpha = 0.6, position = "jitter")#
p <- p + scale_size_area(max_size=10)#
#
print(p)
library(ggplot2)#
library(grid)#
#
data("iris")#
#
df <- iris[(df$Petal.Length, decreasing = TRUE),]#
#
p <- ggplot(df, aes(#
	x = Sepal.Length,#
	y = Sepal.Width,#
	color = Species,#
	size = Petal.Length#
	))#
#
p <- p + geom_point(alpha = 0.6, position = "jitter")#
p <- p + scale_size_area(max_size=10)#
#
print(p)
library(ggplot2)#
library(grid)#
#
data("iris")#
#
df <- iris[(df$Petal.Length, decreasing = TRUE),]#
#
p <- ggplot(df, aes(#
	x = Sepal.Length,#
	y = Sepal.Width,#
	color = Species,#
	size = Petal.Length#
	))#
#
p <- p + geom_point(alpha = 0.6, position = "jitter")#
p <- p + scale_size_area(max_size=10)#
#
p <- p + guides(colour = guide_legend(override.aes = list(size=8)))#
#
print(p)
Melting necessarty for heatmaps#
library(ggplot2)#
library(reshape)#
library(plyr)#
library(scales)#
# Processing Data#
processData <- function(original) {#
	processed <- original#
	colnames(processed) <- gsub("\\.", " ", colnames(processed))#
	processed <- processed[sapply(processed, is.numeric)]#
	processed <- rescaler(processed, type = "range")#
	processed$id <- 1:nrow(original)#
	processed <- melt(processed, "id")#
	processed$id <- factor(processed$id,#
		levels = 1:nrow(original), ordered = TRUE)#
	return(processed)#
}#
# possibly normalize between zero and one#
# data from 1 to 5, and from 1 to 5000 -> normalize#
#
getHeatmap <- function(dataset, midrange) {#
	p <- ggplot(dataset, aes(x = id, y = variable))#
	p <- geom_tile(aes(fill = value))#
	return(p)#
}#
#
melted < processData(iris)#
print(getheatmap(melted, c(0.4, 0.6)))
Melting necessarty for heatmaps#
library(ggplot2)#
library(reshape)#
library(plyr)#
library(scales)#
# Processing Data#
processData <- function(original) {#
	processed <- original#
	colnames(processed) <- gsub("\\.", " ", colnames(processed))#
	processed <- processed[sapply(processed, is.numeric)]#
	processed <- rescaler(processed, type = "range")#
	processed$id <- 1:nrow(original)#
	processed <- melt(processed, "id")#
	processed$id <- factor(processed$id,#
		levels = 1:nrow(original), ordered = TRUE)#
	return(processed)#
}#
# possibly normalize between zero and one#
# data from 1 to 5, and from 1 to 5000 -> normalize#
#
getHeatmap <- function(dataset, midrange) {#
	p <- ggplot(dataset, aes(x = id, y = variable))#
	p <- geom_tile(aes(fill = value))#
	return(p)#
}#
#
melted < processData(iris)#
print(getHeatmap(melted, c(0.4, 0.6)))
Melting necessarty for heatmaps#
library(ggplot2)#
library(reshape)#
library(plyr)#
library(scales)#
# Processing Data#
processData <- function(original) {#
	processed <- original#
	colnames(processed) <- gsub("\\.", " ", colnames(processed))#
	processed <- processed[sapply(processed, is.numeric)]#
	processed <- rescaler(processed, type = "range")#
	processed$id <- 1:nrow(original)#
	processed <- melt(processed, "id")#
	processed$id <- factor(processed$id,#
		levels = 1:nrow(original), ordered = TRUE)#
	return(processed)#
}#
# possibly normalize between zero and one#
# data from 1 to 5, and from 1 to 5000 -> normalize#
#
getHeatmap <- function(dataset, midrange) {#
	p <- ggplot(dataset, aes(x = id, y = variable))#
	p <- geom_tile(aes(fill = value))#
	return(p)#
}#
#
melted < processed(iris)#
print(getHeatmap(melted, c(0.4, 0.6)))
Melting necessarty for heatmaps#
library(ggplot2)#
library(reshape)#
library(plyr)#
library(scales)#
# Processing Data#
processData <- function(original) {#
	processed <- original#
	colnames(processed) <- gsub("\\.", " ", colnames(processed))#
	processed <- processed[sapply(processed, is.numeric)]#
	processed <- rescaler(processed, type = "range")#
	processed$id <- 1:nrow(original)#
	processed <- melt(processed, "id")#
	processed$id <- factor(processed$id,#
		levels = 1:nrow(original), ordered = TRUE)#
	return(processed)#
}#
# possibly normalize between zero and one#
# data from 1 to 5, and from 1 to 5000 -> normalize#
#
getHeatmap <- function(dataset, midrange) {#
	p <- ggplot(dataset, aes(x = id, y = variable))#
	p <- geom_tile(aes(fill = value))#
	return(p)#
}#
#
melted <- processData(iris)#
print(getHeatmap(melted, c(0.4, 0.6)))
if (!require(devtools))#
  install.packages("devtools")#
devtools::install_github("jcheng5/leaflet-shiny")#
shiny::runGitHub("superzip", "jcheng5")
install.packages(dplyr)
library()
?dplyr
??dplyr
install.packages(plyr)
library()
library(plyr)
shiny::runGitHub("superzip", "jcheng5")
library(shiny)
shiny::runGitHub('msan622', 'trevorstephens', subdir='homework2')
library(shiny)
shiny::runGitHub('msan622', 'ashishthakur1296', subdir='homework2')
install.packages("sqldf")
shiny::runGitHub('msan622', 'ashishthakur1296', subdir='homework2')
library(shiny)
shiny::runGitHub('msan622', 'trevorstephens', subdir='homework2')
library(shiny)
shiny::runGitHub('msan622', 'j-gilmore', 'homework3')
library(wordcloud)#
library(ggplot2)#
library(reshape2)#
library(grid)#
library(shiny)#
#
setwd("/Users/jg/Documents/DataVis/msan622/homework4/")#
#
source("dante.r")#
source("ibm.r")#
#
corp_df <- data.frame(#
    Inferno = dante_matrix[, "danteinferno.txt"],#
    Purgatory = dante_matrix[, "dantepurgatory.txt"],#
    Paradise = dante_matrix[, "danteparadise.txt"],#
    stringsAsFactors = FALSE)#
#
corp_matrix <- as.matrix(corp_df)#
# ibm_df <- corp_df[4]#
# ibm_matrix <- as.matrix(ibm_df)#
#
common_corp_df <- corp_df#
common_corp_df[corp_df==0] <- NA#
common_corp_df <- common_corp_df[!is.na(common_corp_df[1]) & !is.na(common_corp_df[2]) & !is.na(common_corp_df[3]),]#
#
common_corp_df$wordsums <- rowSums(common_corp_df)#
common_corp_df <- common_corp_df[with(common_corp_df, order(-wordsums)),]#
#
common_corp_df <- common_corp_df[1:3]#
#
plot_list <- list()#
#
plot_function <- function(data, plot_type, cloudtype, books, wordcount, colorScheme, bg) {#
	palette <- rev(brewer.pal(3,colorScheme))#
	corp_m <- as.matrix(data)#
	par(mfrow=c(1,1), bg=bg)#
	if(plot_type=="bar") {#
		bar_df <- head(data[books], wordcount)#
		bar_df$word <- rownames(bar_df)#
		bar_df <- melt(bar_df, id.vars = "word")#
		for(i in bar_df$word) {#
			p <- ggplot(bar_df, aes("i", value)) +#
			geom_bar(aes(fill=variable),#
			position ="dodge",#
			stat="identity",#
			width=.25) +#
			theme(panel.grid.major = element_blank(),#
			panel.grid.minor = element_blank(),#
			panel.background = element_rect(fill="white"),#
			plot.background = element_blank(),#
			axis.ticks = element_blank(),#
			axis.text.x = element_blank(),#
			axis.text.y = element_blank(),#
			axis.title.x = element_blank(),#
			axis.title.y = element_blank(),#
			legend.title = element_blank(),#
			legend.text = element_text(size=14, face="bold")) +#
			ggtitle(expression(bold("Frequent Word Stems\n"))) +#
			scale_fill_manual(values=palette[books]) + # or [1:3]#
			facet_wrap( ~ word, ncol=3) +#
			theme(strip.background = element_rect(fill = "white"),#
			panel.margin = unit(2,"lines"),#
			strip.text = element_text(size = 12, face="bold")) #
#
			plot_list<- p#
			return(plot_list)#
		}#
	}#
	if(cloudtype=="comparison") {#
		comparison.cloud(corp_m, max.words=200,#
		random.order=FALSE,colors=palette,#
		title.size = .001,#
		main="Differences Between Inferno, Purgatory and Paradise")#
	}#
	if(cloudtype=="commonality") {#
		commonality.cloud(corp_m, max.words=200, #
		random.order=FALSE, color=palette,#
		main="Commonality Between Inferno, Purgatory, and Paradise")#
	}#
	if(cloudtype=="inferno") {#
		inferno_df <- corp_df[1]#
		inferno_matrix <- as.matrix(inferno_df)#
		commonality.cloud(inferno_matrix, max.words=100,#
		random.order=FALSE,color=palette[1],main="Inferno")#
	}#
	if(cloudtype=="purgatory") {#
		purgatory_df <- corp_df[2]#
		purgatory_matrix <- as.matrix(purgatory_df)#
		commonality.cloud(purgatory_matrix, max.words=100,#
		random.order=FALSE,color=palette[2],main="Purgatory")#
	}#
	if(cloudtype=="paradise") {#
		paradise_df <- corp_df[3]#
		paradise_matrix <- as.matrix(paradise_df)#
		commonality.cloud(paradise_matrix, max.words=100,#
		random.order=FALSE,color=palette[3],main="Paradise")#
	}#
	if(plot_type=="manyeyes") {#
		commonality.cloud(corp_m, max.words=200, #
		random.order=TRUE, color=palette,#
		main="Commonality Between Inferno, Purgatory, and Paradise")#
	}#
}#
#
###
#
shinyServer(function(input, output) {#
	cat("Press \"ESC\" to exit...\n")#
#
	output$ui <- renderUI({#
		if (is.null(input$input_type))#
			return()#
		switch(input$input_type,#
			"Word Use" = fluidRow(#
				column(6, h5("Books"),#
					checkboxInput("Inferno", "Inferno",#
									value = TRUE#
					),#
					checkboxInput("Purgatory", "Purgatory",#
									value = TRUE#
					),#
					checkboxInput("Paradise", "Paradise",#
									value = TRUE#
					)#
					),#
				column(6,#
					sliderInput(inputId = "wordcount", #
						label = h5("Number of Words"), #
						min = 1, max = 24, value = 12, step = 1#
					)),#
					br(),#
					br(),#
					includeHTML("aboutwordstems.html")#
				),#
			"Word Cloud" = fluidRow(#
				column(12, "Please be patient.  Some plots load slowly.",#
					br(),#
					radioButtons("cloudtype", h5("Type of Cloud"),#
						choices = c("Commonality Cloud" = "commonality",#
									"Comparison Cloud" = "comparison",#
									"Inferno Only" = "inferno",#
									"Purgatory Only" = "purgatory",#
									"Paradise Only" = "paradise"),#
						selected = "commonality"#
					),#
					includeHTML("aboutclouds.html")#
				)#
			),#
			"Many Eyes" = fluidRow(#
				column(12,#
					includeHTML("aboutmanyeyes.html"),#
#
					h5("Click below to go to Many Eyes:"),#
					helpText( a("Word Tree of The Divine Comedy", href="http://www.manyeyes.com/software/analytics/manyeyes/visualizations/dantes-the-divine-comedy-word-tree", target="_blank")),#
					helpText( a("Phrase Net of The Divine Comedy", href="http://www.manyeyes.com/software/analytics/manyeyes/visualizations/dantes-the-divine-comedy-phrase-ne", target="_blank"))#
#
				)#
				)#
		)#
	})#
	getdata <- reactive({#
		if(input$input_type=="Word Use") {#
			return(common_corp_df)#
		}#
		if(input$input_type=="Word Cloud") {#
			return(corp_df)#
		}#
		if(input$input_type=="Many Eyes") {#
			return(ibm_df)#
		}#
	})#
	getplottype <- reactive({#
		if(input$input_type=="Word Use") {#
			return("bar")#
		}#
		if(input$input_type=="Word Cloud") {#
			return("wordcloud")#
		}#
		if(input$input_type=="Many Eyes") {#
			return("manyeyes")#
		}#
	})#
	getbooks <- reactive ({#
		results <- c(input$Inferno, input$Purgatory, input$Paradise)#
		return(results)#
	})#
	getcolor <- reactive({#
		return(input$colorScheme)#
	})#
	getcloudtype <- reactive({#
		return(input$cloudtype)#
	})#
	getimagetype <- reactive({#
		return(input$image)#
	})#
	output$plotResults <- renderPlot ({#
		plotResults <- plot_function(getdata(), getplottype(), #
		getcloudtype(), getbooks(), input$wordcount, getcolor(), "black")#
		print(plotResults)#
	}, width = 700, height = 600)#
})
runApp()
library(wordcloud)#
library(ggplot2)#
library(reshape2)#
library(grid)#
library(shiny)#
#
setwd("/Users/jg/Documents/DataVis/msan622/homework4/")#
#
source("dante.r")#
source("ibm.r")#
#
corp_df <- data.frame(#
    Inferno = dante_matrix[, "danteinferno.txt"],#
    Purgatory = dante_matrix[, "dantepurgatory.txt"],#
    Paradise = dante_matrix[, "danteparadise.txt"],#
    stringsAsFactors = FALSE)#
#
corp_matrix <- as.matrix(corp_df)#
#
ibm_df <- data.frame(#
	ibm = ibm_matrix[, "ibmuse.txt"],#
	stringAsFactors = FALSE)#
#
common_corp_df <- corp_df#
common_corp_df[corp_df==0] <- NA#
common_corp_df <- common_corp_df[!is.na(common_corp_df[1]) & !is.na(common_corp_df[2]) & !is.na(common_corp_df[3]),]#
#
common_corp_df$wordsums <- rowSums(common_corp_df)#
common_corp_df <- common_corp_df[with(common_corp_df, order(-wordsums)),]#
#
common_corp_df <- common_corp_df[1:3]#
#
plot_list <- list()#
#
plot_function <- function(data, plot_type, cloudtype, books, wordcount, colorScheme, bg) {#
	palette <- rev(brewer.pal(3,colorScheme))#
	corp_m <- as.matrix(data)#
	par(mfrow=c(1,1), bg=bg)#
	if(plot_type=="bar") {#
		bar_df <- head(data[books], wordcount)#
		bar_df$word <- rownames(bar_df)#
		bar_df <- melt(bar_df, id.vars = "word")#
		for(i in bar_df$word) {#
			p <- ggplot(bar_df, aes("i", value)) +#
			geom_bar(aes(fill=variable),#
			position ="dodge",#
			stat="identity",#
			width=.25) +#
			theme(panel.grid.major = element_blank(),#
			panel.grid.minor = element_blank(),#
			panel.background = element_rect(fill="white"),#
			plot.background = element_blank(),#
			axis.ticks = element_blank(),#
			axis.text.x = element_blank(),#
			axis.text.y = element_blank(),#
			axis.title.x = element_blank(),#
			axis.title.y = element_blank(),#
			legend.title = element_blank(),#
			legend.text = element_text(size=14, face="bold")) +#
			ggtitle(expression(bold("Frequent Word Stems\n"))) +#
			scale_fill_manual(values=palette[books]) + # or [1:3]#
			facet_wrap( ~ word, ncol=3) +#
			theme(strip.background = element_rect(fill = "white"),#
			panel.margin = unit(2,"lines"),#
			strip.text = element_text(size = 12, face="bold")) #
#
			plot_list<- p#
			return(plot_list)#
		}#
	}#
	if(cloudtype=="comparison") {#
		comparison.cloud(corp_m, max.words=200,#
		random.order=FALSE,colors=palette,#
		title.size = .001,#
		main="Differences Between Inferno, Purgatory and Paradise")#
	}#
	if(cloudtype=="commonality") {#
		commonality.cloud(corp_m, max.words=200, #
		random.order=FALSE, color=palette,#
		main="Commonality Between Inferno, Purgatory, and Paradise")#
	}#
	if(cloudtype=="inferno") {#
		inferno_df <- corp_df[1]#
		inferno_matrix <- as.matrix(inferno_df)#
		commonality.cloud(inferno_matrix, max.words=100,#
		random.order=FALSE,color=palette[1],main="Inferno")#
	}#
	if(cloudtype=="purgatory") {#
		purgatory_df <- corp_df[2]#
		purgatory_matrix <- as.matrix(purgatory_df)#
		commonality.cloud(purgatory_matrix, max.words=100,#
		random.order=FALSE,color=palette[2],main="Purgatory")#
	}#
	if(cloudtype=="paradise") {#
		paradise_df <- corp_df[3]#
		paradise_matrix <- as.matrix(paradise_df)#
		commonality.cloud(paradise_matrix, max.words=100,#
		random.order=FALSE,color=palette[3],main="Paradise")#
	}#
	if(plot_type=="manyeyes") {#
		commonality.cloud(corp_m, max.words=200, #
		random.order=TRUE, color=palette,#
		main="Commonality Between Inferno, Purgatory, and Paradise")#
	}#
}#
#
###
#
shinyServer(function(input, output) {#
	cat("Press \"ESC\" to exit...\n")#
#
	output$ui <- renderUI({#
		if (is.null(input$input_type))#
			return()#
		switch(input$input_type,#
			"Word Use" = fluidRow(#
				column(6, h5("Books"),#
					checkboxInput("Inferno", "Inferno",#
									value = TRUE#
					),#
					checkboxInput("Purgatory", "Purgatory",#
									value = TRUE#
					),#
					checkboxInput("Paradise", "Paradise",#
									value = TRUE#
					)#
					),#
				column(6,#
					sliderInput(inputId = "wordcount", #
						label = h5("Number of Words"), #
						min = 1, max = 24, value = 12, step = 1#
					)),#
					br(),#
					br(),#
					includeHTML("aboutwordstems.html")#
				),#
			"Word Cloud" = fluidRow(#
				column(12, "Please be patient.  Some plots load slowly.",#
					br(),#
					radioButtons("cloudtype", h5("Type of Cloud"),#
						choices = c("Commonality Cloud" = "commonality",#
									"Comparison Cloud" = "comparison",#
									"Inferno Only" = "inferno",#
									"Purgatory Only" = "purgatory",#
									"Paradise Only" = "paradise"),#
						selected = "commonality"#
					),#
					includeHTML("aboutclouds.html")#
				)#
			),#
			"Many Eyes" = fluidRow(#
				column(12,#
					includeHTML("aboutmanyeyes.html"),#
#
					h5("Click below to go to Many Eyes:"),#
					helpText( a("Word Tree of The Divine Comedy", href="http://www.manyeyes.com/software/analytics/manyeyes/visualizations/dantes-the-divine-comedy-word-tree", target="_blank")),#
					helpText( a("Phrase Net of The Divine Comedy", href="http://www.manyeyes.com/software/analytics/manyeyes/visualizations/dantes-the-divine-comedy-phrase-ne", target="_blank"))#
#
				)#
				)#
		)#
	})#
	getdata <- reactive({#
		if(input$input_type=="Word Use") {#
			return(common_corp_df)#
		}#
		if(input$input_type=="Word Cloud") {#
			return(corp_df)#
		}#
		if(input$input_type=="Many Eyes") {#
			return(ibm_df)#
		}#
	})#
	getplottype <- reactive({#
		if(input$input_type=="Word Use") {#
			return("bar")#
		}#
		if(input$input_type=="Word Cloud") {#
			return("wordcloud")#
		}#
		if(input$input_type=="Many Eyes") {#
			return("manyeyes")#
		}#
	})#
	getbooks <- reactive ({#
		results <- c(input$Inferno, input$Purgatory, input$Paradise)#
		return(results)#
	})#
	getcolor <- reactive({#
		return(input$colorScheme)#
	})#
	getcloudtype <- reactive({#
		return(input$cloudtype)#
	})#
	getimagetype <- reactive({#
		return(input$image)#
	})#
	output$plotResults <- renderPlot ({#
		plotResults <- plot_function(getdata(), getplottype(), #
		getcloudtype(), getbooks(), input$wordcount, getcolor(), "black")#
		print(plotResults)#
	}, width = 700, height = 600)#
})
runApp()
library(wordcloud)#
library(ggplot2)#
library(reshape2)#
library(grid)#
library(shiny)#
#
setwd("/Users/jg/Documents/DataVis/msan622/homework4/")#
#
source("dante.r")#
source("ibm.r")#
#
corp_df <- data.frame(#
    Inferno = dante_matrix[, "danteinferno.txt"],#
    Purgatory = dante_matrix[, "dantepurgatory.txt"],#
    Paradise = dante_matrix[, "danteparadise.txt"],#
    stringsAsFactors = FALSE)#
#
corp_matrix <- as.matrix(corp_df)#
#
ibm_df <- data.frame(#
	ibm = ibm_matrix[, "ibmuse.txt"],#
	stringAsFactors = FALSE)#
#
common_corp_df <- corp_df#
common_corp_df[corp_df==0] <- NA#
common_corp_df <- common_corp_df[!is.na(common_corp_df[1]) & !is.na(common_corp_df[2]) & !is.na(common_corp_df[3]),]#
#
common_corp_df$wordsums <- rowSums(common_corp_df)#
common_corp_df <- common_corp_df[with(common_corp_df, order(-wordsums)),]#
#
common_corp_df <- common_corp_df[1:3]#
#
plot_list <- list()#
#
plot_function <- function(data, plot_type, cloudtype, books, wordcount, colorScheme, bg) {#
	palette <- rev(brewer.pal(3,colorScheme))#
	corp_m <- as.matrix(data)#
	par(mfrow=c(1,1), bg=bg)#
	if(plot_type=="bar") {#
		bar_df <- head(data[books], wordcount)#
		bar_df$word <- rownames(bar_df)#
		bar_df <- melt(bar_df, id.vars = "word")#
		for(i in bar_df$word) {#
			p <- ggplot(bar_df, aes("i", value)) +#
			geom_bar(aes(fill=variable),#
			position ="dodge",#
			stat="identity",#
			width=.25) +#
			theme(panel.grid.major = element_blank(),#
			panel.grid.minor = element_blank(),#
			panel.background = element_rect(fill="white"),#
			plot.background = element_blank(),#
			axis.ticks = element_blank(),#
			axis.text.x = element_blank(),#
			axis.text.y = element_blank(),#
			axis.title.x = element_blank(),#
			axis.title.y = element_blank(),#
			legend.title = element_blank(),#
			legend.text = element_text(size=14, face="bold")) +#
			ggtitle(expression(bold("Frequent Word Stems\n"))) +#
			scale_fill_manual(values=palette[books]) + # or [1:3]#
			facet_wrap( ~ word, ncol=3) +#
			theme(strip.background = element_rect(fill = "white"),#
			panel.margin = unit(2,"lines"),#
			strip.text = element_text(size = 12, face="bold")) #
#
			plot_list<- p#
			return(plot_list)#
		}#
	}#
	if(cloudtype=="comparison") {#
		comparison.cloud(corp_m, max.words=200,#
		random.order=FALSE,colors=palette,#
		title.size = .001,#
		main="Differences Between Inferno, Purgatory and Paradise")#
	}#
	if(cloudtype=="commonality") {#
		commonality.cloud(corp_m, max.words=200, #
		random.order=FALSE, color=palette,#
		main="Commonality Between Inferno, Purgatory, and Paradise")#
	}#
	if(cloudtype=="inferno") {#
		inferno_df <- corp_df[1]#
		inferno_matrix <- as.matrix(inferno_df)#
		commonality.cloud(inferno_matrix, max.words=100,#
		random.order=FALSE,color=palette[1],main="Inferno")#
	}#
	if(cloudtype=="purgatory") {#
		purgatory_df <- corp_df[2]#
		purgatory_matrix <- as.matrix(purgatory_df)#
		commonality.cloud(purgatory_matrix, max.words=100,#
		random.order=FALSE,color=palette[2],main="Purgatory")#
	}#
	if(cloudtype=="paradise") {#
		paradise_df <- corp_df[3]#
		paradise_matrix <- as.matrix(paradise_df)#
		commonality.cloud(paradise_matrix, max.words=100,#
		random.order=FALSE,color=palette[3],main="Paradise")#
	}#
	if(plot_type=="manyeyes") {#
		commonality.cloud(corp_m, max.words=50, #
		random.order=TRUE, color=palette,#
		main="Commonality Between Inferno, Purgatory, and Paradise")#
	}#
}#
#
###
#
shinyServer(function(input, output) {#
	cat("Press \"ESC\" to exit...\n")#
#
	output$ui <- renderUI({#
		if (is.null(input$input_type))#
			return()#
		switch(input$input_type,#
			"Word Use" = fluidRow(#
				column(6, h5("Books"),#
					checkboxInput("Inferno", "Inferno",#
									value = TRUE#
					),#
					checkboxInput("Purgatory", "Purgatory",#
									value = TRUE#
					),#
					checkboxInput("Paradise", "Paradise",#
									value = TRUE#
					)#
					),#
				column(6,#
					sliderInput(inputId = "wordcount", #
						label = h5("Number of Words"), #
						min = 1, max = 24, value = 12, step = 1#
					)),#
					br(),#
					br(),#
					includeHTML("aboutwordstems.html")#
				),#
			"Word Cloud" = fluidRow(#
				column(12, "Please be patient.  Some plots load slowly.",#
					br(),#
					radioButtons("cloudtype", h5("Type of Cloud"),#
						choices = c("Commonality Cloud" = "commonality",#
									"Comparison Cloud" = "comparison",#
									"Inferno Only" = "inferno",#
									"Purgatory Only" = "purgatory",#
									"Paradise Only" = "paradise"),#
						selected = "commonality"#
					),#
					includeHTML("aboutclouds.html")#
				)#
			),#
			"Many Eyes" = fluidRow(#
				column(12,#
					includeHTML("aboutmanyeyes.html"),#
#
					h5("Click below to go to Many Eyes:"),#
					helpText( a("Word Tree of The Divine Comedy", href="http://www.manyeyes.com/software/analytics/manyeyes/visualizations/dantes-the-divine-comedy-word-tree", target="_blank")),#
					helpText( a("Phrase Net of The Divine Comedy", href="http://www.manyeyes.com/software/analytics/manyeyes/visualizations/dantes-the-divine-comedy-phrase-ne", target="_blank"))#
#
				)#
				)#
		)#
	})#
	getdata <- reactive({#
		if(input$input_type=="Word Use") {#
			return(common_corp_df)#
		}#
		if(input$input_type=="Word Cloud") {#
			return(corp_df)#
		}#
		if(input$input_type=="Many Eyes") {#
			return(ibm_df)#
		}#
	})#
	getplottype <- reactive({#
		if(input$input_type=="Word Use") {#
			return("bar")#
		}#
		if(input$input_type=="Word Cloud") {#
			return("wordcloud")#
		}#
		if(input$input_type=="Many Eyes") {#
			return("manyeyes")#
		}#
	})#
	getbooks <- reactive ({#
		results <- c(input$Inferno, input$Purgatory, input$Paradise)#
		return(results)#
	})#
	getcolor <- reactive({#
		return(input$colorScheme)#
	})#
	getcloudtype <- reactive({#
		return(input$cloudtype)#
	})#
	getimagetype <- reactive({#
		return(input$image)#
	})#
	output$plotResults <- renderPlot ({#
		plotResults <- plot_function(getdata(), getplottype(), #
		getcloudtype(), getbooks(), input$wordcount, getcolor(), "black")#
		print(plotResults)#
	}, width = 700, height = 600)#
})
runApp()
ibm_df
library(wordcloud)#
library(ggplot2)#
library(reshape2)#
library(grid)#
library(shiny)#
#
setwd("/Users/jg/Documents/DataVis/msan622/homework4/")#
#
source("dante.r")#
source("ibm.r")#
#
corp_df <- data.frame(#
    Inferno = dante_matrix[, "danteinferno.txt"],#
    Purgatory = dante_matrix[, "dantepurgatory.txt"],#
    Paradise = dante_matrix[, "danteparadise.txt"],#
    stringsAsFactors = FALSE)#
#
corp_matrix <- as.matrix(corp_df)#
#
ibm_df <- data.frame(#
	ibm = ibm_matrix[, "ibmuse.txt"],#
	stringAsFactors = FALSE)#
#
common_corp_df <- corp_df#
common_corp_df[corp_df==0] <- NA#
common_corp_df <- common_corp_df[!is.na(common_corp_df[1]) & !is.na(common_corp_df[2]) & !is.na(common_corp_df[3]),]#
#
common_corp_df$wordsums <- rowSums(common_corp_df)#
common_corp_df <- common_corp_df[with(common_corp_df, order(-wordsums)),]#
#
common_corp_df <- common_corp_df[1:3]#
#
plot_list <- list()#
#
plot_function <- function(data, plot_type, cloudtype, books, wordcount, colorScheme, bg) {#
	palette <- rev(brewer.pal(3,colorScheme))#
	corp_m <- as.matrix(data)#
	par(mfrow=c(1,1), bg=bg)#
	if(plot_type=="bar") {#
		bar_df <- head(data[books], wordcount)#
		bar_df$word <- rownames(bar_df)#
		bar_df <- melt(bar_df, id.vars = "word")#
		for(i in bar_df$word) {#
			p <- ggplot(bar_df, aes("i", value)) +#
			geom_bar(aes(fill=variable),#
			position ="dodge",#
			stat="identity",#
			width=.25) +#
			theme(panel.grid.major = element_blank(),#
			panel.grid.minor = element_blank(),#
			panel.background = element_rect(fill="white"),#
			plot.background = element_blank(),#
			axis.ticks = element_blank(),#
			axis.text.x = element_blank(),#
			axis.text.y = element_blank(),#
			axis.title.x = element_blank(),#
			axis.title.y = element_blank(),#
			legend.title = element_blank(),#
			legend.text = element_text(size=14, face="bold")) +#
			ggtitle(expression(bold("Frequent Word Stems\n"))) +#
			scale_fill_manual(values=palette[books]) + # or [1:3]#
			facet_wrap( ~ word, ncol=3) +#
			theme(strip.background = element_rect(fill = "white"),#
			panel.margin = unit(2,"lines"),#
			strip.text = element_text(size = 12, face="bold")) #
#
			plot_list<- p#
			return(plot_list)#
		}#
	}#
	if(cloudtype=="comparison") {#
		comparison.cloud(corp_m, max.words=200,#
		random.order=FALSE,colors=palette,#
		title.size = .001,#
		main="Differences Between Inferno, Purgatory and Paradise")#
	}#
	if(cloudtype=="commonality") {#
		commonality.cloud(corp_m, max.words=200, #
		random.order=FALSE, color=palette,#
		main="Commonality Between Inferno, Purgatory, and Paradise")#
	}#
	if(cloudtype=="inferno") {#
		inferno_df <- corp_df[1]#
		inferno_matrix <- as.matrix(inferno_df)#
		commonality.cloud(inferno_matrix, max.words=100,#
		random.order=FALSE,color=palette[1],main="Inferno")#
	}#
	if(cloudtype=="purgatory") {#
		purgatory_df <- corp_df[2]#
		purgatory_matrix <- as.matrix(purgatory_df)#
		commonality.cloud(purgatory_matrix, max.words=100,#
		random.order=FALSE,color=palette[2],main="Purgatory")#
	}#
	if(cloudtype=="paradise") {#
		paradise_df <- corp_df[3]#
		paradise_matrix <- as.matrix(paradise_df)#
		commonality.cloud(paradise_matrix, max.words=100,#
		random.order=FALSE,color=palette[3],main="Paradise")#
	}#
	if(plot_type=="manyeyes") {#
		commonality.cloud(ibm_df, max.words=50, #
		random.order=TRUE, color=palette,#
		main="Commonality Between Inferno, Purgatory, and Paradise")#
	}#
}#
#
###
#
shinyServer(function(input, output) {#
	cat("Press \"ESC\" to exit...\n")#
#
	output$ui <- renderUI({#
		if (is.null(input$input_type))#
			return()#
		switch(input$input_type,#
			"Word Use" = fluidRow(#
				column(6, h5("Books"),#
					checkboxInput("Inferno", "Inferno",#
									value = TRUE#
					),#
					checkboxInput("Purgatory", "Purgatory",#
									value = TRUE#
					),#
					checkboxInput("Paradise", "Paradise",#
									value = TRUE#
					)#
					),#
				column(6,#
					sliderInput(inputId = "wordcount", #
						label = h5("Number of Words"), #
						min = 1, max = 24, value = 12, step = 1#
					)),#
					br(),#
					br(),#
					includeHTML("aboutwordstems.html")#
				),#
			"Word Cloud" = fluidRow(#
				column(12, "Please be patient.  Some plots load slowly.",#
					br(),#
					radioButtons("cloudtype", h5("Type of Cloud"),#
						choices = c("Commonality Cloud" = "commonality",#
									"Comparison Cloud" = "comparison",#
									"Inferno Only" = "inferno",#
									"Purgatory Only" = "purgatory",#
									"Paradise Only" = "paradise"),#
						selected = "commonality"#
					),#
					includeHTML("aboutclouds.html")#
				)#
			),#
			"Many Eyes" = fluidRow(#
				column(12,#
					includeHTML("aboutmanyeyes.html"),#
#
					h5("Click below to go to Many Eyes:"),#
					helpText( a("Word Tree of The Divine Comedy", href="http://www.manyeyes.com/software/analytics/manyeyes/visualizations/dantes-the-divine-comedy-word-tree", target="_blank")),#
					helpText( a("Phrase Net of The Divine Comedy", href="http://www.manyeyes.com/software/analytics/manyeyes/visualizations/dantes-the-divine-comedy-phrase-ne", target="_blank"))#
#
				)#
				)#
		)#
	})#
	getdata <- reactive({#
		if(input$input_type=="Word Use") {#
			return(common_corp_df)#
		}#
		if(input$input_type=="Word Cloud") {#
			return(corp_df)#
		}#
		if(input$input_type=="Many Eyes") {#
			return(ibm_df)#
		}#
	})#
	getplottype <- reactive({#
		if(input$input_type=="Word Use") {#
			return("bar")#
		}#
		if(input$input_type=="Word Cloud") {#
			return("wordcloud")#
		}#
		if(input$input_type=="Many Eyes") {#
			return("manyeyes")#
		}#
	})#
	getbooks <- reactive ({#
		results <- c(input$Inferno, input$Purgatory, input$Paradise)#
		return(results)#
	})#
	getcolor <- reactive({#
		return(input$colorScheme)#
	})#
	getcloudtype <- reactive({#
		return(input$cloudtype)#
	})#
	getimagetype <- reactive({#
		return(input$image)#
	})#
	output$plotResults <- renderPlot ({#
		plotResults <- plot_function(getdata(), getplottype(), #
		getcloudtype(), getbooks(), input$wordcount, getcolor(), "black")#
		print(plotResults)#
	}, width = 700, height = 600)#
})
ibm_df
runApp()
ibm_df$word <- rownames(ibm_df)
ibm
ibm_df
ibm_df <- data.frame(#
	ibm = ibm_matrix[, "ibmuse.txt"],#
	stringAsFactors = FALSE)
ibm_df
ibm_matrix <- as.matrix(ibm_df)
ibm_matrix
library(wordcloud)#
library(ggplot2)#
library(reshape2)#
library(grid)#
library(shiny)#
#
setwd("/Users/jg/Documents/DataVis/msan622/homework4/")#
#
source("dante.r")#
source("ibm.r")#
#
corp_df <- data.frame(#
    Inferno = dante_matrix[, "danteinferno.txt"],#
    Purgatory = dante_matrix[, "dantepurgatory.txt"],#
    Paradise = dante_matrix[, "danteparadise.txt"],#
    stringsAsFactors = FALSE)#
#
corp_matrix <- as.matrix(corp_df)#
#
ibm_df <- data.frame(#
	ibm = ibm_matrix[, "ibmuse.txt"],#
	stringAsFactors = FALSE)#
ibm_matrix <- as.matrix(ibm_df)#
#ibm_df$word <- rownames(ibm_df)#
#
common_corp_df <- corp_df#
common_corp_df[corp_df==0] <- NA#
common_corp_df <- common_corp_df[!is.na(common_corp_df[1]) & !is.na(common_corp_df[2]) & !is.na(common_corp_df[3]),]#
#
common_corp_df$wordsums <- rowSums(common_corp_df)#
common_corp_df <- common_corp_df[with(common_corp_df, order(-wordsums)),]#
#
common_corp_df <- common_corp_df[1:3]#
#
plot_list <- list()#
#
plot_function <- function(data, plot_type, cloudtype, books, wordcount, colorScheme, bg) {#
	palette <- rev(brewer.pal(3,colorScheme))#
	corp_m <- as.matrix(data)#
	par(mfrow=c(1,1), bg=bg)#
	if(plot_type=="bar") {#
		bar_df <- head(data[books], wordcount)#
		bar_df$word <- rownames(bar_df)#
		bar_df <- melt(bar_df, id.vars = "word")#
		for(i in bar_df$word) {#
			p <- ggplot(bar_df, aes("i", value)) +#
			geom_bar(aes(fill=variable),#
			position ="dodge",#
			stat="identity",#
			width=.25) +#
			theme(panel.grid.major = element_blank(),#
			panel.grid.minor = element_blank(),#
			panel.background = element_rect(fill="white"),#
			plot.background = element_blank(),#
			axis.ticks = element_blank(),#
			axis.text.x = element_blank(),#
			axis.text.y = element_blank(),#
			axis.title.x = element_blank(),#
			axis.title.y = element_blank(),#
			legend.title = element_blank(),#
			legend.text = element_text(size=14, face="bold")) +#
			ggtitle(expression(bold("Frequent Word Stems\n"))) +#
			scale_fill_manual(values=palette[books]) + # or [1:3]#
			facet_wrap( ~ word, ncol=3) +#
			theme(strip.background = element_rect(fill = "white"),#
			panel.margin = unit(2,"lines"),#
			strip.text = element_text(size = 12, face="bold")) #
#
			plot_list<- p#
			return(plot_list)#
		}#
	}#
	if(cloudtype=="comparison") {#
		comparison.cloud(corp_m, max.words=200,#
		random.order=FALSE,colors=palette,#
		title.size = .001,#
		main="Differences Between Inferno, Purgatory and Paradise")#
	}#
	if(cloudtype=="commonality") {#
		commonality.cloud(corp_m, max.words=200, #
		random.order=FALSE, color=palette,#
		main="Commonality Between Inferno, Purgatory, and Paradise")#
	}#
	if(cloudtype=="inferno") {#
		inferno_df <- corp_df[1]#
		inferno_matrix <- as.matrix(inferno_df)#
		commonality.cloud(inferno_matrix, max.words=100,#
		random.order=FALSE,color=palette[1],main="Inferno")#
	}#
	if(cloudtype=="purgatory") {#
		purgatory_df <- corp_df[2]#
		purgatory_matrix <- as.matrix(purgatory_df)#
		commonality.cloud(purgatory_matrix, max.words=100,#
		random.order=FALSE,color=palette[2],main="Purgatory")#
	}#
	if(cloudtype=="paradise") {#
		paradise_df <- corp_df[3]#
		paradise_matrix <- as.matrix(paradise_df)#
		commonality.cloud(paradise_matrix, max.words=100,#
		random.order=FALSE,color=palette[3],main="Paradise")#
	}#
	if(plot_type=="manyeyes") {#
		commonality.cloud(ibm_matrix, max.words=50, #
		random.order=TRUE, color=palette,#
		main="Commonality Between Inferno, Purgatory, and Paradise")#
	}#
}#
#
###
#
shinyServer(function(input, output) {#
	cat("Press \"ESC\" to exit...\n")#
#
	output$ui <- renderUI({#
		if (is.null(input$input_type))#
			return()#
		switch(input$input_type,#
			"Word Use" = fluidRow(#
				column(6, h5("Books"),#
					checkboxInput("Inferno", "Inferno",#
									value = TRUE#
					),#
					checkboxInput("Purgatory", "Purgatory",#
									value = TRUE#
					),#
					checkboxInput("Paradise", "Paradise",#
									value = TRUE#
					)#
					),#
				column(6,#
					sliderInput(inputId = "wordcount", #
						label = h5("Number of Words"), #
						min = 1, max = 24, value = 12, step = 1#
					)),#
					br(),#
					br(),#
					includeHTML("aboutwordstems.html")#
				),#
			"Word Cloud" = fluidRow(#
				column(12, "Please be patient.  Some plots load slowly.",#
					br(),#
					radioButtons("cloudtype", h5("Type of Cloud"),#
						choices = c("Commonality Cloud" = "commonality",#
									"Comparison Cloud" = "comparison",#
									"Inferno Only" = "inferno",#
									"Purgatory Only" = "purgatory",#
									"Paradise Only" = "paradise"),#
						selected = "commonality"#
					),#
					includeHTML("aboutclouds.html")#
				)#
			),#
			"Many Eyes" = fluidRow(#
				column(12,#
					includeHTML("aboutmanyeyes.html"),#
#
					h5("Click below to go to Many Eyes:"),#
					helpText( a("Word Tree of The Divine Comedy", href="http://www.manyeyes.com/software/analytics/manyeyes/visualizations/dantes-the-divine-comedy-word-tree", target="_blank")),#
					helpText( a("Phrase Net of The Divine Comedy", href="http://www.manyeyes.com/software/analytics/manyeyes/visualizations/dantes-the-divine-comedy-phrase-ne", target="_blank"))#
#
				)#
				)#
		)#
	})#
	getdata <- reactive({#
		if(input$input_type=="Word Use") {#
			return(common_corp_df)#
		}#
		if(input$input_type=="Word Cloud") {#
			return(corp_df)#
		}#
		if(input$input_type=="Many Eyes") {#
			return(ibm_df)#
		}#
	})#
	getplottype <- reactive({#
		if(input$input_type=="Word Use") {#
			return("bar")#
		}#
		if(input$input_type=="Word Cloud") {#
			return("wordcloud")#
		}#
		if(input$input_type=="Many Eyes") {#
			return("manyeyes")#
		}#
	})#
	getbooks <- reactive ({#
		results <- c(input$Inferno, input$Purgatory, input$Paradise)#
		return(results)#
	})#
	getcolor <- reactive({#
		return(input$colorScheme)#
	})#
	getcloudtype <- reactive({#
		return(input$cloudtype)#
	})#
	getimagetype <- reactive({#
		return(input$image)#
	})#
	output$plotResults <- renderPlot ({#
		plotResults <- plot_function(getdata(), getplottype(), #
		getcloudtype(), getbooks(), input$wordcount, getcolor(), "black")#
		print(plotResults)#
	}, width = 700, height = 600)#
})
runApp()
ibm_df
library(wordcloud)#
library(ggplot2)#
library(reshape2)#
library(grid)#
library(shiny)#
#
setwd("/Users/jg/Documents/DataVis/msan622/homework4/")#
#
source("dante.r")#
source("ibm.r")#
#
corp_df <- data.frame(#
    Inferno = dante_matrix[, "danteinferno.txt"],#
    Purgatory = dante_matrix[, "dantepurgatory.txt"],#
    Paradise = dante_matrix[, "danteparadise.txt"],#
    stringsAsFactors = FALSE)#
#
corp_matrix <- as.matrix(corp_df)#
#
ibm_df <- data.frame(#
	ibm = ibm_matrix[, "ibmuse.txt"],#
	stringAsFactors = FALSE)#
ibm_matrix <- as.matrix(ibm_df)#
#ibm_df$word <- rownames(ibm_df)#
#
common_corp_df <- corp_df#
common_corp_df[corp_df==0] <- NA#
common_corp_df <- common_corp_df[!is.na(common_corp_df[1]) & !is.na(common_corp_df[2]) & !is.na(common_corp_df[3]),]#
#
common_corp_df$wordsums <- rowSums(common_corp_df)#
common_corp_df <- common_corp_df[with(common_corp_df, order(-wordsums)),]#
#
common_corp_df <- common_corp_df[1:3]#
#
plot_list <- list()#
#
plot_function <- function(data, plot_type, cloudtype, books, wordcount, colorScheme, bg) {#
	palette <- rev(brewer.pal(3,colorScheme))#
	corp_m <- as.matrix(data)#
	par(mfrow=c(1,1), bg=bg)#
	if(plot_type=="bar") {#
		bar_df <- head(data[books], wordcount)#
		bar_df$word <- rownames(bar_df)#
		bar_df <- melt(bar_df, id.vars = "word")#
		for(i in bar_df$word) {#
			p <- ggplot(bar_df, aes("i", value)) +#
			geom_bar(aes(fill=variable),#
			position ="dodge",#
			stat="identity",#
			width=.25) +#
			theme(panel.grid.major = element_blank(),#
			panel.grid.minor = element_blank(),#
			panel.background = element_rect(fill="white"),#
			plot.background = element_blank(),#
			axis.ticks = element_blank(),#
			axis.text.x = element_blank(),#
			axis.text.y = element_blank(),#
			axis.title.x = element_blank(),#
			axis.title.y = element_blank(),#
			legend.title = element_blank(),#
			legend.text = element_text(size=14, face="bold")) +#
			ggtitle(expression(bold("Frequent Word Stems\n"))) +#
			scale_fill_manual(values=palette[books]) + # or [1:3]#
			facet_wrap( ~ word, ncol=3) +#
			theme(strip.background = element_rect(fill = "white"),#
			panel.margin = unit(2,"lines"),#
			strip.text = element_text(size = 12, face="bold")) #
#
			plot_list<- p#
			return(plot_list)#
		}#
	}#
	if(cloudtype=="comparison") {#
		comparison.cloud(corp_m, max.words=200,#
		random.order=FALSE,colors=palette,#
		title.size = .001,#
		main="Differences Between Inferno, Purgatory and Paradise")#
	}#
	if(cloudtype=="commonality") {#
		commonality.cloud(corp_m, max.words=200, #
		random.order=FALSE, color=palette,#
		main="Commonality Between Inferno, Purgatory, and Paradise")#
	}#
	if(cloudtype=="inferno") {#
		inferno_df <- corp_df[1]#
		inferno_matrix <- as.matrix(inferno_df)#
		commonality.cloud(inferno_matrix, max.words=100,#
		random.order=FALSE,color=palette[1],main="Inferno")#
	}#
	if(cloudtype=="purgatory") {#
		purgatory_df <- corp_df[2]#
		purgatory_matrix <- as.matrix(purgatory_df)#
		commonality.cloud(purgatory_matrix, max.words=100,#
		random.order=FALSE,color=palette[2],main="Purgatory")#
	}#
	if(cloudtype=="paradise") {#
		paradise_df <- corp_df[3]#
		paradise_matrix <- as.matrix(paradise_df)#
		commonality.cloud(paradise_matrix, max.words=100,#
		random.order=FALSE,color=palette[3],main="Paradise")#
	}#
	if(plot_type=="manyeyes") {#
		wordcloud(ibm_df$word, ibm_df$freq, random.order=FALSE,#
			colors=Palette)#
		# commonality.cloud(ibm_df, max.words=50, #
		# random.order=TRUE, color=palette,#
		# main="Commonality Between Inferno, Purgatory, and Paradise")#
	}#
}#
#
###
#
shinyServer(function(input, output) {#
	cat("Press \"ESC\" to exit...\n")#
#
	output$ui <- renderUI({#
		if (is.null(input$input_type))#
			return()#
		switch(input$input_type,#
			"Word Use" = fluidRow(#
				column(6, h5("Books"),#
					checkboxInput("Inferno", "Inferno",#
									value = TRUE#
					),#
					checkboxInput("Purgatory", "Purgatory",#
									value = TRUE#
					),#
					checkboxInput("Paradise", "Paradise",#
									value = TRUE#
					)#
					),#
				column(6,#
					sliderInput(inputId = "wordcount", #
						label = h5("Number of Words"), #
						min = 1, max = 24, value = 12, step = 1#
					)),#
					br(),#
					br(),#
					includeHTML("aboutwordstems.html")#
				),#
			"Word Cloud" = fluidRow(#
				column(12, "Please be patient.  Some plots load slowly.",#
					br(),#
					radioButtons("cloudtype", h5("Type of Cloud"),#
						choices = c("Commonality Cloud" = "commonality",#
									"Comparison Cloud" = "comparison",#
									"Inferno Only" = "inferno",#
									"Purgatory Only" = "purgatory",#
									"Paradise Only" = "paradise"),#
						selected = "commonality"#
					),#
					includeHTML("aboutclouds.html")#
				)#
			),#
			"Many Eyes" = fluidRow(#
				column(12,#
					includeHTML("aboutmanyeyes.html"),#
#
					h5("Click below to go to Many Eyes:"),#
					helpText( a("Word Tree of The Divine Comedy", href="http://www.manyeyes.com/software/analytics/manyeyes/visualizations/dantes-the-divine-comedy-word-tree", target="_blank")),#
					helpText( a("Phrase Net of The Divine Comedy", href="http://www.manyeyes.com/software/analytics/manyeyes/visualizations/dantes-the-divine-comedy-phrase-ne", target="_blank"))#
#
				)#
				)#
		)#
	})#
	getdata <- reactive({#
		if(input$input_type=="Word Use") {#
			return(common_corp_df)#
		}#
		if(input$input_type=="Word Cloud") {#
			return(corp_df)#
		}#
		if(input$input_type=="Many Eyes") {#
			return(ibm_df)#
		}#
	})#
	getplottype <- reactive({#
		if(input$input_type=="Word Use") {#
			return("bar")#
		}#
		if(input$input_type=="Word Cloud") {#
			return("wordcloud")#
		}#
		if(input$input_type=="Many Eyes") {#
			return("manyeyes")#
		}#
	})#
	getbooks <- reactive ({#
		results <- c(input$Inferno, input$Purgatory, input$Paradise)#
		return(results)#
	})#
	getcolor <- reactive({#
		return(input$colorScheme)#
	})#
	getcloudtype <- reactive({#
		return(input$cloudtype)#
	})#
	getimagetype <- reactive({#
		return(input$image)#
	})#
	output$plotResults <- renderPlot ({#
		plotResults <- plot_function(getdata(), getplottype(), #
		getcloudtype(), getbooks(), input$wordcount, getcolor(), "black")#
		print(plotResults)#
	}, width = 700, height = 600)#
})
runApp()
library(wordcloud)#
library(ggplot2)#
library(reshape2)#
library(grid)#
library(shiny)#
#
setwd("/Users/jg/Documents/DataVis/msan622/homework4/")#
#
source("dante.r")#
source("ibm.r")#
#
corp_df <- data.frame(#
    Inferno = dante_matrix[, "danteinferno.txt"],#
    Purgatory = dante_matrix[, "dantepurgatory.txt"],#
    Paradise = dante_matrix[, "danteparadise.txt"],#
    stringsAsFactors = FALSE)#
#
corp_matrix <- as.matrix(corp_df)#
#
ibm_df <- data.frame(#
	ibm = ibm_matrix[, "ibmuse.txt"],#
	stringAsFactors = FALSE)#
ibm_matrix <- as.matrix(ibm_df)#
#ibm_df$word <- rownames(ibm_df)#
#
common_corp_df <- corp_df#
common_corp_df[corp_df==0] <- NA#
common_corp_df <- common_corp_df[!is.na(common_corp_df[1]) & !is.na(common_corp_df[2]) & !is.na(common_corp_df[3]),]#
#
common_corp_df$wordsums <- rowSums(common_corp_df)#
common_corp_df <- common_corp_df[with(common_corp_df, order(-wordsums)),]#
#
common_corp_df <- common_corp_df[1:3]#
#
plot_list <- list()#
#
plot_function <- function(data, plot_type, cloudtype, books, wordcount, colorScheme, bg) {#
	palette <- rev(brewer.pal(3,colorScheme))#
	corp_m <- as.matrix(data)#
	par(mfrow=c(1,1), bg=bg)#
	if(plot_type=="bar") {#
		bar_df <- head(data[books], wordcount)#
		bar_df$word <- rownames(bar_df)#
		bar_df <- melt(bar_df, id.vars = "word")#
		for(i in bar_df$word) {#
			p <- ggplot(bar_df, aes("i", value)) +#
			geom_bar(aes(fill=variable),#
			position ="dodge",#
			stat="identity",#
			width=.25) +#
			theme(panel.grid.major = element_blank(),#
			panel.grid.minor = element_blank(),#
			panel.background = element_rect(fill="white"),#
			plot.background = element_blank(),#
			axis.ticks = element_blank(),#
			axis.text.x = element_blank(),#
			axis.text.y = element_blank(),#
			axis.title.x = element_blank(),#
			axis.title.y = element_blank(),#
			legend.title = element_blank(),#
			legend.text = element_text(size=14, face="bold")) +#
			ggtitle(expression(bold("Frequent Word Stems\n"))) +#
			scale_fill_manual(values=palette[books]) + # or [1:3]#
			facet_wrap( ~ word, ncol=3) +#
			theme(strip.background = element_rect(fill = "white"),#
			panel.margin = unit(2,"lines"),#
			strip.text = element_text(size = 12, face="bold")) #
#
			plot_list<- p#
			return(plot_list)#
		}#
	}#
	if(cloudtype=="comparison") {#
		comparison.cloud(corp_m, max.words=200,#
		random.order=FALSE,colors=palette,#
		title.size = .001,#
		main="Differences Between Inferno, Purgatory and Paradise")#
	}#
	if(cloudtype=="commonality") {#
		commonality.cloud(corp_m, max.words=200, #
		random.order=FALSE, color=palette,#
		main="Commonality Between Inferno, Purgatory, and Paradise")#
	}#
	if(cloudtype=="inferno") {#
		inferno_df <- corp_df[1]#
		inferno_matrix <- as.matrix(inferno_df)#
		commonality.cloud(inferno_matrix, max.words=100,#
		random.order=FALSE,color=palette[1],main="Inferno")#
	}#
	if(cloudtype=="purgatory") {#
		purgatory_df <- corp_df[2]#
		purgatory_matrix <- as.matrix(purgatory_df)#
		commonality.cloud(purgatory_matrix, max.words=100,#
		random.order=FALSE,color=palette[2],main="Purgatory")#
	}#
	if(cloudtype=="paradise") {#
		paradise_df <- corp_df[3]#
		paradise_matrix <- as.matrix(paradise_df)#
		commonality.cloud(paradise_matrix, max.words=100,#
		random.order=FALSE,color=palette[3],main="Paradise")#
	}#
	if(input_type=="manyeyes") {#
		commonality.cloud(ibm_df, max.words=50, #
		random.order=TRUE, color=palette,#
		main="Commonality Between Inferno, Purgatory, and Paradise")#
	}#
}#
#
###
#
shinyServer(function(input, output) {#
	cat("Press \"ESC\" to exit...\n")#
#
	output$ui <- renderUI({#
		if (is.null(input$input_type))#
			return()#
		switch(input$input_type,#
			"Word Use" = fluidRow(#
				column(6, h5("Books"),#
					checkboxInput("Inferno", "Inferno",#
									value = TRUE#
					),#
					checkboxInput("Purgatory", "Purgatory",#
									value = TRUE#
					),#
					checkboxInput("Paradise", "Paradise",#
									value = TRUE#
					)#
					),#
				column(6,#
					sliderInput(inputId = "wordcount", #
						label = h5("Number of Words"), #
						min = 1, max = 24, value = 12, step = 1#
					)),#
					br(),#
					br(),#
					includeHTML("aboutwordstems.html")#
				),#
			"Word Cloud" = fluidRow(#
				column(12, "Please be patient.  Some plots load slowly.",#
					br(),#
					radioButtons("cloudtype", h5("Type of Cloud"),#
						choices = c("Commonality Cloud" = "commonality",#
									"Comparison Cloud" = "comparison",#
									"Inferno Only" = "inferno",#
									"Purgatory Only" = "purgatory",#
									"Paradise Only" = "paradise"),#
						selected = "commonality"#
					),#
					includeHTML("aboutclouds.html")#
				)#
			),#
			"Many Eyes" = fluidRow(#
				column(12,#
					includeHTML("aboutmanyeyes.html"),#
#
					h5("Click below to go to Many Eyes:"),#
					helpText( a("Word Tree of The Divine Comedy", href="http://www.manyeyes.com/software/analytics/manyeyes/visualizations/dantes-the-divine-comedy-word-tree", target="_blank")),#
					helpText( a("Phrase Net of The Divine Comedy", href="http://www.manyeyes.com/software/analytics/manyeyes/visualizations/dantes-the-divine-comedy-phrase-ne", target="_blank"))#
#
				)#
				)#
		)#
	})#
	getdata <- reactive({#
		if(input$input_type=="Word Use") {#
			return(common_corp_df)#
		}#
		if(input$input_type=="Word Cloud") {#
			return(corp_df)#
		}#
		if(input$input_type=="Many Eyes") {#
			return(corp_df)#
		}#
	})#
	getplottype <- reactive({#
		if(input$input_type=="Word Use") {#
			return("bar")#
		}#
		if(input$input_type=="Word Cloud") {#
			return("wordcloud")#
		}#
		if(input$input_type=="Many Eyes") {#
			return("manyeyes")#
		}#
	})#
	getbooks <- reactive ({#
		results <- c(input$Inferno, input$Purgatory, input$Paradise)#
		return(results)#
	})#
	getcolor <- reactive({#
		return(input$colorScheme)#
	})#
	getcloudtype <- reactive({#
		return(input$cloudtype)#
	})#
	getimagetype <- reactive({#
		return(input$image)#
	})#
	output$plotResults <- renderPlot ({#
		plotResults <- plot_function(getdata(), getplottype(), #
		getcloudtype(), getbooks(), input$wordcount, getcolor(), "black")#
		print(plotResults)#
	}, width = 700, height = 600)#
})
runApp()
library(wordcloud)#
library(ggplot2)#
library(reshape2)#
library(grid)#
library(shiny)#
#
setwd("/Users/jg/Documents/DataVis/msan622/homework4/")#
#
source("dante.r")#
source("ibm.r")#
#
corp_df <- data.frame(#
    Inferno = dante_matrix[, "danteinferno.txt"],#
    Purgatory = dante_matrix[, "dantepurgatory.txt"],#
    Paradise = dante_matrix[, "danteparadise.txt"],#
    stringsAsFactors = FALSE)#
#
corp_matrix <- as.matrix(corp_df)#
#
ibm_df <- data.frame(#
	ibm = ibm_matrix[, "ibmuse.txt"],#
	stringAsFactors = FALSE)#
ibm_matrix <- as.matrix(ibm_df)#
#ibm_df$word <- rownames(ibm_df)#
#
common_corp_df <- corp_df#
common_corp_df[corp_df==0] <- NA#
common_corp_df <- common_corp_df[!is.na(common_corp_df[1]) & !is.na(common_corp_df[2]) & !is.na(common_corp_df[3]),]#
#
common_corp_df$wordsums <- rowSums(common_corp_df)#
common_corp_df <- common_corp_df[with(common_corp_df, order(-wordsums)),]#
#
common_corp_df <- common_corp_df[1:3]#
#
plot_list <- list()#
#
plot_function <- function(data, plot_type, cloudtype, books, wordcount, colorScheme, bg) {#
	palette <- rev(brewer.pal(3,colorScheme))#
	corp_m <- as.matrix(data)#
	par(mfrow=c(1,1), bg=bg)#
	if(plot_type=="bar") {#
		bar_df <- head(data[books], wordcount)#
		bar_df$word <- rownames(bar_df)#
		bar_df <- melt(bar_df, id.vars = "word")#
		for(i in bar_df$word) {#
			p <- ggplot(bar_df, aes("i", value)) +#
			geom_bar(aes(fill=variable),#
			position ="dodge",#
			stat="identity",#
			width=.25) +#
			theme(panel.grid.major = element_blank(),#
			panel.grid.minor = element_blank(),#
			panel.background = element_rect(fill="white"),#
			plot.background = element_blank(),#
			axis.ticks = element_blank(),#
			axis.text.x = element_blank(),#
			axis.text.y = element_blank(),#
			axis.title.x = element_blank(),#
			axis.title.y = element_blank(),#
			legend.title = element_blank(),#
			legend.text = element_text(size=14, face="bold")) +#
			ggtitle(expression(bold("Frequent Word Stems\n"))) +#
			scale_fill_manual(values=palette[books]) + # or [1:3]#
			facet_wrap( ~ word, ncol=3) +#
			theme(strip.background = element_rect(fill = "white"),#
			panel.margin = unit(2,"lines"),#
			strip.text = element_text(size = 12, face="bold")) #
#
			plot_list<- p#
			return(plot_list)#
		}#
	}#
	if(cloudtype=="comparison") {#
		comparison.cloud(corp_m, max.words=200,#
		random.order=FALSE,colors=palette,#
		title.size = .001,#
		main="Differences Between Inferno, Purgatory and Paradise")#
	}#
	if(cloudtype=="commonality") {#
		commonality.cloud(corp_m, max.words=200, #
		random.order=FALSE, color=palette,#
		main="Commonality Between Inferno, Purgatory, and Paradise")#
	}#
	if(cloudtype=="inferno") {#
		inferno_df <- corp_df[1]#
		inferno_matrix <- as.matrix(inferno_df)#
		commonality.cloud(inferno_matrix, max.words=100,#
		random.order=FALSE,color=palette[1],main="Inferno")#
	}#
	if(cloudtype=="purgatory") {#
		purgatory_df <- corp_df[2]#
		purgatory_matrix <- as.matrix(purgatory_df)#
		commonality.cloud(purgatory_matrix, max.words=100,#
		random.order=FALSE,color=palette[2],main="Purgatory")#
	}#
	if(cloudtype=="paradise") {#
		paradise_df <- corp_df[3]#
		paradise_matrix <- as.matrix(paradise_df)#
		commonality.cloud(paradise_matrix, max.words=100,#
		random.order=FALSE,color=palette[3],main="Paradise")#
	}#
	if(plot_type=="manyeyes") {#
		commonality.cloud(ibm_df, max.words=50, #
		random.order=TRUE, color=palette,#
		main="Commonality Between Inferno, Purgatory, and Paradise")#
	}#
}#
#
###
#
shinyServer(function(input, output) {#
	cat("Press \"ESC\" to exit...\n")#
#
	output$ui <- renderUI({#
		if (is.null(input$input_type))#
			return()#
		switch(input$input_type,#
			"Word Use" = fluidRow(#
				column(6, h5("Books"),#
					checkboxInput("Inferno", "Inferno",#
									value = TRUE#
					),#
					checkboxInput("Purgatory", "Purgatory",#
									value = TRUE#
					),#
					checkboxInput("Paradise", "Paradise",#
									value = TRUE#
					)#
					),#
				column(6,#
					sliderInput(inputId = "wordcount", #
						label = h5("Number of Words"), #
						min = 1, max = 24, value = 12, step = 1#
					)),#
					br(),#
					br(),#
					includeHTML("aboutwordstems.html")#
				),#
			"Word Cloud" = fluidRow(#
				column(12, "Please be patient.  Some plots load slowly.",#
					br(),#
					radioButtons("cloudtype", h5("Type of Cloud"),#
						choices = c("Commonality Cloud" = "commonality",#
									"Comparison Cloud" = "comparison",#
									"Inferno Only" = "inferno",#
									"Purgatory Only" = "purgatory",#
									"Paradise Only" = "paradise"),#
						selected = "commonality"#
					),#
					includeHTML("aboutclouds.html")#
				)#
			),#
			"Many Eyes" = fluidRow(#
				column(12,#
					includeHTML("aboutmanyeyes.html"),#
#
					h5("Click below to go to Many Eyes:"),#
					helpText( a("Word Tree of The Divine Comedy", href="http://www.manyeyes.com/software/analytics/manyeyes/visualizations/dantes-the-divine-comedy-word-tree", target="_blank")),#
					helpText( a("Phrase Net of The Divine Comedy", href="http://www.manyeyes.com/software/analytics/manyeyes/visualizations/dantes-the-divine-comedy-phrase-ne", target="_blank"))#
#
				)#
				)#
		)#
	})#
	getdata <- reactive({#
		if(input$input_type=="Word Use") {#
			return(common_corp_df)#
		}#
		if(input$input_type=="Word Cloud") {#
			return(corp_df)#
		}#
		if(input$input_type=="Many Eyes") {#
			return(corp_df)#
		}#
	})#
	getplottype <- reactive({#
		if(input$input_type=="Word Use") {#
			return("bar")#
		}#
		if(input$input_type=="Word Cloud") {#
			return("wordcloud")#
		}#
		if(input$input_type=="Many Eyes") {#
			return("manyeyes")#
		}#
	})#
	getbooks <- reactive ({#
		results <- c(input$Inferno, input$Purgatory, input$Paradise)#
		return(results)#
	})#
	getcolor <- reactive({#
		return(input$colorScheme)#
	})#
	getcloudtype <- reactive({#
		return(input$cloudtype)#
	})#
	getimagetype <- reactive({#
		return(input$image)#
	})#
	output$plotResults <- renderPlot ({#
		plotResults <- plot_function(getdata(), getplottype(), #
		getcloudtype(), getbooks(), input$wordcount, getcolor(), "black")#
		print(plotResults)#
	}, width = 700, height = 600)#
})
runApp()
library(wordcloud)#
library(ggplot2)#
library(reshape2)#
library(grid)#
library(shiny)#
#
setwd("/Users/jg/Documents/DataVis/msan622/homework4/")#
#
source("dante.r")#
source("ibm.r")#
#
corp_df <- data.frame(#
    Inferno = dante_matrix[, "danteinferno.txt"],#
    Purgatory = dante_matrix[, "dantepurgatory.txt"],#
    Paradise = dante_matrix[, "danteparadise.txt"],#
    stringsAsFactors = FALSE)#
#
corp_matrix <- as.matrix(corp_df)#
#
ibm_df <- data.frame(#
	ibm = ibm_matrix[, "ibmuse.txt"],#
	stringAsFactors = FALSE)#
ibm_matrix <- as.matrix(ibm_df)#
#ibm_df$word <- rownames(ibm_df)#
#
common_corp_df <- corp_df#
common_corp_df[corp_df==0] <- NA#
common_corp_df <- common_corp_df[!is.na(common_corp_df[1]) & !is.na(common_corp_df[2]) & !is.na(common_corp_df[3]),]#
#
common_corp_df$wordsums <- rowSums(common_corp_df)#
common_corp_df <- common_corp_df[with(common_corp_df, order(-wordsums)),]#
#
common_corp_df <- common_corp_df[1:3]#
#
plot_list <- list()#
#
plot_function <- function(data, plot_type, cloudtype, books, wordcount, colorScheme, bg) {#
	palette <- rev(brewer.pal(3,colorScheme))#
	corp_m <- as.matrix(data)#
	par(mfrow=c(1,1), bg=bg)#
	if(plot_type=="bar") {#
		bar_df <- head(data[books], wordcount)#
		bar_df$word <- rownames(bar_df)#
		bar_df <- melt(bar_df, id.vars = "word")#
		for(i in bar_df$word) {#
			p <- ggplot(bar_df, aes("i", value)) +#
			geom_bar(aes(fill=variable),#
			position ="dodge",#
			stat="identity",#
			width=.25) +#
			theme(panel.grid.major = element_blank(),#
			panel.grid.minor = element_blank(),#
			panel.background = element_rect(fill="white"),#
			plot.background = element_blank(),#
			axis.ticks = element_blank(),#
			axis.text.x = element_blank(),#
			axis.text.y = element_blank(),#
			axis.title.x = element_blank(),#
			axis.title.y = element_blank(),#
			legend.title = element_blank(),#
			legend.text = element_text(size=14, face="bold")) +#
			ggtitle(expression(bold("Frequent Word Stems\n"))) +#
			scale_fill_manual(values=palette[books]) + # or [1:3]#
			facet_wrap( ~ word, ncol=3) +#
			theme(strip.background = element_rect(fill = "white"),#
			panel.margin = unit(2,"lines"),#
			strip.text = element_text(size = 12, face="bold")) #
#
			plot_list<- p#
			return(plot_list)#
		}#
	}#
	if(cloudtype=="comparison") {#
		comparison.cloud(corp_m, max.words=200,#
		random.order=FALSE,colors=palette,#
		title.size = .001,#
		main="Differences Between Inferno, Purgatory and Paradise")#
	}#
	if(cloudtype=="commonality") {#
		commonality.cloud(corp_m, max.words=200, #
		random.order=FALSE, color=palette,#
		main="Commonality Between Inferno, Purgatory, and Paradise")#
	}#
	if(cloudtype=="inferno") {#
		inferno_df <- corp_df[1]#
		inferno_matrix <- as.matrix(inferno_df)#
		commonality.cloud(inferno_matrix, max.words=100,#
		random.order=FALSE,color=palette[1],main="Inferno")#
	}#
	if(cloudtype=="purgatory") {#
		purgatory_df <- corp_df[2]#
		purgatory_matrix <- as.matrix(purgatory_df)#
		commonality.cloud(purgatory_matrix, max.words=100,#
		random.order=FALSE,color=palette[2],main="Purgatory")#
	}#
	if(cloudtype=="paradise") {#
		paradise_df <- corp_df[3]#
		paradise_matrix <- as.matrix(paradise_df)#
		commonality.cloud(paradise_matrix, max.words=100,#
		random.order=FALSE,color=palette[3],main="Paradise")#
	}#
	if(plot_type=="manyeyes") {#
		commonality.cloud(corp_m, max.words=100, #
		random.order=TRUE, color=palette,#
		main="Commonality Between Inferno, Purgatory, and Paradise")#
	}#
}#
#
###
#
shinyServer(function(input, output) {#
	cat("Press \"ESC\" to exit...\n")#
#
	output$ui <- renderUI({#
		if (is.null(input$input_type))#
			return()#
		switch(input$input_type,#
			"Word Use" = fluidRow(#
				column(6, h5("Books"),#
					checkboxInput("Inferno", "Inferno",#
									value = TRUE#
					),#
					checkboxInput("Purgatory", "Purgatory",#
									value = TRUE#
					),#
					checkboxInput("Paradise", "Paradise",#
									value = TRUE#
					)#
					),#
				column(6,#
					sliderInput(inputId = "wordcount", #
						label = h5("Number of Words"), #
						min = 1, max = 24, value = 12, step = 1#
					)),#
					br(),#
					br(),#
					includeHTML("aboutwordstems.html")#
				),#
			"Word Cloud" = fluidRow(#
				column(12, "Please be patient.  Some plots load slowly.",#
					br(),#
					radioButtons("cloudtype", h5("Type of Cloud"),#
						choices = c("Commonality Cloud" = "commonality",#
									"Comparison Cloud" = "comparison",#
									"Inferno Only" = "inferno",#
									"Purgatory Only" = "purgatory",#
									"Paradise Only" = "paradise"),#
						selected = "commonality"#
					),#
					includeHTML("aboutclouds.html")#
				)#
			),#
			"Many Eyes" = fluidRow(#
				column(12,#
					includeHTML("aboutmanyeyes.html"),#
#
					h5("Click below to go to Many Eyes:"),#
					helpText( a("Word Tree of The Divine Comedy", href="http://www.manyeyes.com/software/analytics/manyeyes/visualizations/dantes-the-divine-comedy-word-tree", target="_blank")),#
					helpText( a("Phrase Net of The Divine Comedy", href="http://www.manyeyes.com/software/analytics/manyeyes/visualizations/dantes-the-divine-comedy-phrase-ne", target="_blank"))#
#
				)#
				)#
		)#
	})#
	getdata <- reactive({#
		if(input$input_type=="Word Use") {#
			return(common_corp_df)#
		}#
		if(input$input_type=="Word Cloud") {#
			return(corp_df)#
		}#
		if(input$input_type=="Many Eyes") {#
			return(corp_df)#
		}#
	})#
	getplottype <- reactive({#
		if(input$input_type=="Word Use") {#
			return("bar")#
		}#
		if(input$input_type=="Word Cloud") {#
			return("wordcloud")#
		}#
		if(input$input_type=="Many Eyes") {#
			return("manyeyes")#
		}#
	})#
	getbooks <- reactive ({#
		results <- c(input$Inferno, input$Purgatory, input$Paradise)#
		return(results)#
	})#
	getcolor <- reactive({#
		return(input$colorScheme)#
	})#
	getcloudtype <- reactive({#
		return(input$cloudtype)#
	})#
	getimagetype <- reactive({#
		return(input$image)#
	})#
	output$plotResults <- renderPlot ({#
		plotResults <- plot_function(getdata(), getplottype(), #
		getcloudtype(), getbooks(), input$wordcount, getcolor(), "black")#
		print(plotResults)#
	}, width = 700, height = 600)#
})
runApp()
