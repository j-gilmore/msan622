voteRts
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.35  ## cost to the democrats#
costR<- 0.35 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 0 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities#
#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	} #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
#
voteDts[nPeriods]#
voteRts[nPeriods]#
mean(actions)#
#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes")#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes")#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual
voteDts
voteRts
plot(elections, primaryparticipation)
plot(elections, primarytotalvotes)
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.35  ## cost to the democrats#
costR<- 0.35 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 0 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities#
#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	} #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
#
voteDts[nPeriods]#
voteRts[nPeriods]#
mean(actions)#
#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes")#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes")#
plot(elections, (voteRts+voteDts), cex=.3, xlab="Elections", ylab="Democratic Votes")#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.35  ## cost to the democrats#
costR<- 0.35 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 0 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities#
#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	} #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
#
voteDts[nPeriods]#
voteRts[nPeriods]#
mean(actions)#
#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteR, cex=.3, xlab="Elections", ylab="Republican Votes")#
plot(elections, voteD, cex=.3, xlab="Elections", ylab="Democratic Votes")#
plot(elections, (voteR+voteD), cex=.3, xlab="Elections", ylab="Democratic Votes")#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.35  ## cost to the democrats#
costR<- 0.35 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 0 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities#
#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	} #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
#
voteDts[nPeriods]#
voteRts[nPeriods]#
mean(actions)#
#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes")#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes")#
plot(elections, (voteRts+voteDts), cex=.3, xlab="Elections", ylab="Democratic Votes")#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual
voteD
voteDts
primaryparticipation
primarytotalvotes
actions
mean(actions)
voteDts[nPeriods]#
voteRts[nPeriods]
mean((voteRts+voteDts))
mean(voteRts+voteDts)
mean(voteRts[nPeriods]+voteDts[nPeriods])
mean((voteRts[nPeriods]+voteDts[nPeriods]))
((voteRts[nPeriods]+voteDts[nPeriods]))/2
voteRts
participation<-(voteRts+voteDts)/2
participation
plot(elections, participation)
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.35  ## cost to the democrats#
costR<- 0.35 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 0 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities#
#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	} #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
participation<-(voteRts+voteDts)/2#
#
voteDts[nPeriods]#
voteRts[nPeriods]#
mean(actions)#
#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes")#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes")#
plot(elections, (voteRts+voteDts), cex=.3, xlab="Elections", ylab="Democratic Votes")#
plot(elections, participation, cex=.3, xlab="Elections", ylab="Total Participation")#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.35  ## cost to the democrats#
costR<- 0.35 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 0 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities#
#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	} #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
participation<-(voteRts+voteDts)/2#
#
voteDts[nPeriods]#
voteRts[nPeriods]#
mean(actions)#
#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes")#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes")#
plot(elections, participation, cex=.3, xlab="Elections", ylab="Total Participation")#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual
actions
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.35  ## cost to the democrats#
costR<- 0.35 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 0 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  particmatrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities#
#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	} #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	particmatrixj<-list(particmatrixj,actions)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
meanparticipation<-(voteRts+voteDts)/2#
#
voteDts[nPeriods]#
voteRts[nPeriods]#
mean(actions)#
#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes")#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes")#
plot(elections, meanparticipation, cex=.3, xlab="Elections", ylab="Total Participation")#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
#
##Voting Trends#
particframej <- data.frame(matrix(unlist(list(particmatrixj)), nrow=n, byrow=TRUE))#
particSums<- colSums(particframej)#
particMeans<- colMeans(particframej)#
partictotalvotes<-rowSums(particframej)#
participation<-table(partictotalvotes)#
participation
partictotalvotes
particframej
particSums
particMeans
mean(particMeans)
particframej
particSums
particMeans
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.35  ## cost to the democrats#
costR<- 0.35 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 0 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  particmatrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities#
#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	} #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	particmatrixj<-list(particmatrixj,actions)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
meanparticipation<-(voteRts+voteDts)/2#
#
voteDts[nPeriods]#
voteRts[nPeriods]#
mean(actions)#
#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes")#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes")#
plot(elections, particMeans, cex=.3, xlab="Elections", ylab="Mean Participation")#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
#
##Voting Trends#
particframej <- data.frame(matrix(unlist(list(particmatrixj)), nrow=n, byrow=TRUE))#
particSums<- colSums(particframej)#
particMeans<- colMeans(particframej)#
mean(particMeans) ## Mean of Actions over all j elections#
partictotalvotes<-rowSums(particframej)
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.35  ## cost to the democrats#
costR<- 0.35 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 0 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  particmatrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities#
#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	} #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	particmatrixj<-list(particmatrixj,actions)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
meanparticipation<-(voteRts+voteDts)/2#
#
voteDts[nPeriods]#
voteRts[nPeriods]#
mean(actions)#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
#
##Voting Trends#
particframej <- data.frame(matrix(unlist(list(particmatrixj)), nrow=n, byrow=TRUE))#
particSums<- colSums(particframej)#
particMeans<- colMeans(particframej)#
mean(particMeans) ## Mean of Actions over all j elections#
partictotalvotes<-rowSums(particframej)#
#
## Plots#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes")#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes")#
plot(elections, particMeans, cex=.3, xlab="Elections", ylab="Mean Participation")
actions
particmatrixj
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.35  ## cost to the democrats#
costR<- 0.35 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 0 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  particmatrixj<-matrix()#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities#
#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	} #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	particmatrixj<-list(particmatrixj,actions)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
meanparticipation<-(voteRts+voteDts)/2#
#
voteDts[nPeriods]#
voteRts[nPeriods]#
mean(actions)#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
#
##Voting Trends#
particframej <- data.frame(matrix(unlist(list(particmatrixj)), nrow=n, byrow=TRUE))#
particSums<- colSums(particframej)#
particMeans<- colMeans(particframej)#
mean(particMeans) ## Mean of Actions over all j elections#
partictotalvotes<-rowSums(particframej)#
#
## Plots#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes")#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes")#
plot(elections, particMeans, cex=.3, xlab="Elections", ylab="Mean Participation")
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.35  ## cost to the democrats#
costR<- 0.35 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 0 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  particmatrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities#
#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	} #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	particmatrixj<-list(particmatrixj,actions)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
meanparticipation<-(voteRts+voteDts)/2#
#
voteDts[nPeriods]#
voteRts[nPeriods]#
mean(actions)#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
#
##Voting Trends#
particframej <- data.frame(matrix(unlist(list(particmatrixj)), nrow=n, byrow=TRUE))#
particSums<- colSums(particframej)#
particMeans<- colMeans(particframej)#
mean(particMeans) ## Mean of Actions over all j elections#
partictotalvotes<-rowSums(particframej)#
#
## Plots#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes")#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes")#
plot(elections, particMeans, cex=.3, xlab="Elections", ylab="Mean Participation")
actions
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.35  ## cost to the democrats#
costR<- 0.35 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 0 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  particmatrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities#
#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	} #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	particmatrixj<-list(particmatrixj,actions)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
meanparticipation<-(voteRts+voteDts)/2#
#
voteDts[nPeriods]#
voteRts[nPeriods]#
mean(actions) ## For last election only#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
#
##Voting Trends#
particframej <- data.frame(matrix(unlist(list(particmatrixj)), nrow=n, byrow=TRUE))#
particSums<- colSums(particframej)#
particMeans<- colMeans(particframej)#
mean(particMeans) ## Mean of Actions over all j elections#
partictotalvotes<-rowSums(particframej)#
#
## Plots#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes")#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes")#
plot(elections, particMeans, cex=.3, xlab="Elections", ylab="Mean Participation")
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.40  ## cost to the democrats#
costR<- 0.40 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 0 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  particmatrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities#
#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	} #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	particmatrixj<-list(particmatrixj,actions)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
meanparticipation<-(voteRts+voteDts)/2#
#
voteDts[nPeriods]#
voteRts[nPeriods]#
mean(actions) ## For last election only#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
#
##Voting Trends#
particframej <- data.frame(matrix(unlist(list(particmatrixj)), nrow=n, byrow=TRUE))#
particSums<- colSums(particframej)#
particMeans<- colMeans(particframej)#
mean(particMeans) ## Mean of Actions over all j elections#
partictotalvotes<-rowSums(particframej)#
#
## Plots#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes")#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes")#
plot(elections, particMeans, cex=.3, xlab="Elections", ylab="Mean Participation")
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.50  ## cost to the democrats#
costR<- 0.50 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 0 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  particmatrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities#
#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	} #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	particmatrixj<-list(particmatrixj,actions)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
meanparticipation<-(voteRts+voteDts)/2#
#
voteDts[nPeriods]#
voteRts[nPeriods]#
mean(actions) ## For last election only#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
#
##Voting Trends#
particframej <- data.frame(matrix(unlist(list(particmatrixj)), nrow=n, byrow=TRUE))#
particSums<- colSums(particframej)#
particMeans<- colMeans(particframej)#
mean(particMeans) ## Mean of Actions over all j elections#
partictotalvotes<-rowSums(particframej)#
#
## Plots#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes")#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes")#
plot(elections, particMeans, cex=.3, xlab="Elections", ylab="Mean Participation")
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.60  ## cost to the democrats#
costR<- 0.60 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 0 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  particmatrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities#
#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	} #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	particmatrixj<-list(particmatrixj,actions)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
meanparticipation<-(voteRts+voteDts)/2#
#
voteDts[nPeriods]#
voteRts[nPeriods]#
mean(actions) ## For last election only#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
#
##Voting Trends#
particframej <- data.frame(matrix(unlist(list(particmatrixj)), nrow=n, byrow=TRUE))#
particSums<- colSums(particframej)#
particMeans<- colMeans(particframej)#
mean(particMeans) ## Mean of Actions over all j elections#
partictotalvotes<-rowSums(particframej)#
#
## Plots#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes")#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes")#
plot(elections, particMeans, cex=.3, xlab="Elections", ylab="Mean Participation")
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.55  ## cost to the democrats#
costR<- 0.55 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 0 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  particmatrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities#
#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	} #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	particmatrixj<-list(particmatrixj,actions)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
meanparticipation<-(voteRts+voteDts)/2#
#
voteDts[nPeriods]#
voteRts[nPeriods]#
mean(actions) ## For last election only#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
#
##Voting Trends#
particframej <- data.frame(matrix(unlist(list(particmatrixj)), nrow=n, byrow=TRUE))#
particSums<- colSums(particframej)#
particMeans<- colMeans(particframej)#
mean(particMeans) ## Mean of Actions over all j elections#
partictotalvotes<-rowSums(particframej)#
#
## Plots#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes")#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes")#
plot(elections, particMeans, cex=.3, xlab="Elections", ylab="Mean Participation")
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.50  ## cost to the democrats#
costR<- 0.50 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 0 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  particmatrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities#
#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	} #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	particmatrixj<-list(particmatrixj,actions)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
meanparticipation<-(voteRts+voteDts)/2#
#
voteDts[nPeriods]#
voteRts[nPeriods]#
mean(actions) ## For last election only#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
#
##Voting Trends#
particframej <- data.frame(matrix(unlist(list(particmatrixj)), nrow=n, byrow=TRUE))#
particSums<- colSums(particframej)#
particMeans<- colMeans(particframej)#
mean(particMeans) ## Mean of Actions over all j elections#
partictotalvotes<-rowSums(particframej)#
#
## Plots#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes")#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes")#
plot(elections, particMeans, cex=.3, xlab="Elections", ylab="Mean Participation")
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.47 ## cost to the democrats#
costR<- 0.47 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 0 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  particmatrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities#
#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	} #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	particmatrixj<-list(particmatrixj,actions)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
meanparticipation<-(voteRts+voteDts)/2#
#
voteDts[nPeriods]#
voteRts[nPeriods]#
mean(actions) ## For last election only#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
#
##Voting Trends#
particframej <- data.frame(matrix(unlist(list(particmatrixj)), nrow=n, byrow=TRUE))#
particSums<- colSums(particframej)#
particMeans<- colMeans(particframej)#
mean(particMeans) ## Mean of Actions over all j elections#
partictotalvotes<-rowSums(particframej)#
#
## Plots#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes")#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes")#
plot(elections, particMeans, cex=.3, xlab="Elections", ylab="Mean Participation")
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.47 ## cost to the democrats#
costR<- 0.47 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  particmatrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities#
#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	} #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	particmatrixj<-list(particmatrixj,actions)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
meanparticipation<-(voteRts+voteDts)/2#
#
voteDts[nPeriods]#
voteRts[nPeriods]#
mean(actions) ## For last election only#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
#
##Voting Trends#
particframej <- data.frame(matrix(unlist(list(particmatrixj)), nrow=n, byrow=TRUE))#
particSums<- colSums(particframej)#
particMeans<- colMeans(particframej)#
mean(particMeans) ## Mean of Actions over all j elections#
partictotalvotes<-rowSums(particframej)#
#
## Plots#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes")#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes")#
plot(elections, particMeans, cex=.3, xlab="Elections", ylab="Mean Participation")
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.47 ## cost to the democrats#
costR<- 0.47 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 0 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  particmatrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities#
#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	} #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	particmatrixj<-list(particmatrixj,actions)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
meanparticipation<-(voteRts+voteDts)/2#
#
voteDts[nPeriods]#
voteRts[nPeriods]#
mean(actions) ## For last election only#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
#
##Voting Trends#
particframej <- data.frame(matrix(unlist(list(particmatrixj)), nrow=n, byrow=TRUE))#
particSums<- colSums(particframej)#
particMeans<- colMeans(particframej)#
mean(particMeans) ## Mean of Actions over all j elections#
partictotalvotes<-rowSums(particframej)#
#
## Plots#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes")#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes")#
plot(elections, particMeans, cex=.3, xlab="Elections", ylab="Mean Participation")
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.5 ## cost to the democrats#
costR<- 0.5 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 0 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  particmatrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities#
#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	} #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	particmatrixj<-list(particmatrixj,actions)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
meanparticipation<-(voteRts+voteDts)/2#
#
voteDts[nPeriods]#
voteRts[nPeriods]#
mean(actions) ## For last election only#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
#
##Voting Trends#
particframej <- data.frame(matrix(unlist(list(particmatrixj)), nrow=n, byrow=TRUE))#
particSums<- colSums(particframej)#
particMeans<- colMeans(particframej)#
mean(particMeans) ## Mean of Actions over all j elections#
partictotalvotes<-rowSums(particframej)#
#
## Plots#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes")#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes")#
plot(elections, particMeans, cex=.3, xlab="Elections", ylab="Mean Participation")
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.55 ## cost to the democrats#
costR<- 0.55 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 0 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  particmatrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities#
#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	} #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	particmatrixj<-list(particmatrixj,actions)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
meanparticipation<-(voteRts+voteDts)/2#
#
voteDts[nPeriods]#
voteRts[nPeriods]#
mean(actions) ## For last election only#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
#
##Voting Trends#
particframej <- data.frame(matrix(unlist(list(particmatrixj)), nrow=n, byrow=TRUE))#
particSums<- colSums(particframej)#
particMeans<- colMeans(particframej)#
mean(particMeans) ## Mean of Actions over all j elections#
partictotalvotes<-rowSums(particframej)#
#
## Plots#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes")#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes")#
plot(elections, particMeans, cex=.3, xlab="Elections", ylab="Mean Participation")
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.55 ## cost to the democrats#
costR<- 0.55 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  particmatrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities#
#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	} #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	particmatrixj<-list(particmatrixj,actions)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
meanparticipation<-(voteRts+voteDts)/2#
#
voteDts[nPeriods]#
voteRts[nPeriods]#
mean(actions) ## For last election only#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
#
##Voting Trends#
particframej <- data.frame(matrix(unlist(list(particmatrixj)), nrow=n, byrow=TRUE))#
particSums<- colSums(particframej)#
particMeans<- colMeans(particframej)#
mean(particMeans) ## Mean of Actions over all j elections#
partictotalvotes<-rowSums(particframej)#
#
## Plots#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes")#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes")#
plot(elections, particMeans, cex=.3, xlab="Elections", ylab="Mean Participation")
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.55 ## cost to the democrats#
costR<- 0.55 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 0 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  particmatrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities#
#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	} #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	particmatrixj<-list(particmatrixj,actions)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
meanparticipation<-(voteRts+voteDts)/2#
#
voteDts[nPeriods]#
voteRts[nPeriods]#
mean(actions) ## For last election only#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
#
##Voting Trends#
particframej <- data.frame(matrix(unlist(list(particmatrixj)), nrow=n, byrow=TRUE))#
particSums<- colSums(particframej)#
particMeans<- colMeans(particframej)#
mean(particMeans) ## Mean of Actions over all j elections#
partictotalvotes<-rowSums(particframej)#
#
## Plots#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes")#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes")#
plot(elections, particMeans, cex=.3, xlab="Elections", ylab="Mean Participation")
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.8 ## cost to the democrats#
costR<- 0.8 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  particmatrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities#
#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	} #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	particmatrixj<-list(particmatrixj,actions)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
meanparticipation<-(voteRts+voteDts)/2#
#
voteDts[nPeriods]#
voteRts[nPeriods]#
mean(actions) ## For last election only#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
#
##Voting Trends#
particframej <- data.frame(matrix(unlist(list(particmatrixj)), nrow=n, byrow=TRUE))#
particSums<- colSums(particframej)#
particMeans<- colMeans(particframej)#
mean(particMeans) ## Mean of Actions over all j elections#
partictotalvotes<-rowSums(particframej)#
#
## Plots#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes")#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes")#
plot(elections, particMeans, cex=.3, xlab="Elections", ylab="Mean Participation")
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.9 ## cost to the democrats#
costR<- 0.9 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  particmatrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities#
#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	} #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	particmatrixj<-list(particmatrixj,actions)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
meanparticipation<-(voteRts+voteDts)/2#
#
voteDts[nPeriods]#
voteRts[nPeriods]#
mean(actions) ## For last election only#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
#
##Voting Trends#
particframej <- data.frame(matrix(unlist(list(particmatrixj)), nrow=n, byrow=TRUE))#
particSums<- colSums(particframej)#
particMeans<- colMeans(particframej)#
mean(particMeans) ## Mean of Actions over all j elections#
partictotalvotes<-rowSums(particframej)#
#
## Plots#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes")#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes")#
plot(elections, particMeans, cex=.3, xlab="Elections", ylab="Mean Participation")
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.95 ## cost to the democrats#
costR<- 0.95 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  particmatrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities#
#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	} #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	particmatrixj<-list(particmatrixj,actions)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
meanparticipation<-(voteRts+voteDts)/2#
#
voteDts[nPeriods]#
voteRts[nPeriods]#
mean(actions) ## For last election only#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
#
##Voting Trends#
particframej <- data.frame(matrix(unlist(list(particmatrixj)), nrow=n, byrow=TRUE))#
particSums<- colSums(particframej)#
particMeans<- colMeans(particframej)#
mean(particMeans) ## Mean of Actions over all j elections#
partictotalvotes<-rowSums(particframej)#
#
## Plots#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes")#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes")#
plot(elections, particMeans, cex=.3, xlab="Elections", ylab="Mean Participation")
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  particmatrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities#
#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	} #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	particmatrixj<-list(particmatrixj,actions)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
meanparticipation<-(voteRts+voteDts)/2#
#
voteDts[nPeriods]#
voteRts[nPeriods]#
mean(actions) ## For last election only#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
#
##Voting Trends#
particframej <- data.frame(matrix(unlist(list(particmatrixj)), nrow=n, byrow=TRUE))#
particSums<- colSums(particframej)#
particMeans<- colMeans(particframej)#
mean(particMeans) ## Mean of Actions over all j elections#
partictotalvotes<-rowSums(particframej)#
#
## Plots#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes")#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes")#
plot(elections, particMeans, cex=.3, xlab="Elections", ylab="Mean Participation")
meanParticipation
meanparticipation
mean(meanparticipation)
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  particmatrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities#
#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	} #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	particmatrixj<-list(particmatrixj,actions)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
meanparticipation<-(voteRts+voteDts)/2#
#
voteDts[nPeriods]#
voteRts[nPeriods]#
mean(actions) ## For last election only#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
#
##Voting Trends [Play with this]#
particframej <- data.frame(matrix(unlist(list(particmatrixj)), nrow=n, byrow=TRUE))#
particSums<- colSums(particframej)#
particMeans<- colMeans(particframej)#
mean(particMeans) ## Mean of Actions over all j elections#
partictotalvotes<-rowSums(particframej)#
#
## Plots#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes")#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes")#
plot(elections, particMeans, cex=.3, xlab="Elections", ylab="Mean Participation")
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  particmatrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities#
#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	} #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
meanparticipation<-(voteRts+voteDts)/2#
#
voteDts[nPeriods]#
voteRts[nPeriods]#
mean(actions) ## For last election only#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
#
## Plots#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes")#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes")
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  particmatrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities#
#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	} #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
meanparticipation<-(voteRts+voteDts)/2#
#
voteDts[nPeriods-7:nPeriods]#
voteRts[nPeriods]#
mean(actions) ## For last election only#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
#
## Plots#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes")#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes")
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  particmatrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities#
#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	} #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
meanparticipation<-(voteRts+voteDts)/2#
#
mean(voteDts[nPeriods])#
voteRts[nPeriods]#
mean(actions) ## For last election only#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
#
## Plots#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes")#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes")
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  particmatrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities#
#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	} #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
meanparticipation<-(voteRts+voteDts)/2#
#
mean(voteDts[nPeriods])#
voteDts[nPeriods]#
voteRts[nPeriods]#
mean(actions) ## For last election only#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
#
## Plots#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes")#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes")
voteD
voteR
mean(voteDts)
voteDts
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  rmatrixj<-matrix(nrow=(0), ncol=(0))#
  dmatrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
    meanvoteDts<-mean(voteDts)#
    meanvoteRts<-mean(voteRts)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	rmatrixj<- list(rmatrixj, meanvoteRts)#
	dmatrixj<- list(dmatrixj, meanvoteDts)#
	}#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
meanparticipation<-(voteRts+voteDts)/2#
#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## For last election only#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
#
## Plots#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes")#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes")
rmatrixj
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  rmatrixj<-matrix(nrow=(0), ncol=(0))#
  dmatrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
    meanvoteDts<-mean(voteDts)#
    meanvoteRts<-mean(voteRts)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
	rmatrixj<- list(rmatrixj, meanvoteRts)#
	dmatrixj<- list(dmatrixj, meanvoteDts)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
meanparticipation<-(voteRts+voteDts)/2#
#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## For last election only#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
#
## Plots#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes")#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes")
rmatrixj
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  rmatrixj<-matrix(nrow=(0), ncol=(0))#
  dmatrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
    meanvoteDts<-mean(voteDts)#
    meanvoteRts<-mean(voteRts)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
	rmatrixj<- list(rmatrixj, meanvoteRts)#
	dmatrixj<- list(dmatrixj, meanvoteDts)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
meanparticipation<-(voteRts+voteDts)/2#
#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## For last election only#
mean(rmatrixj)#
mean(dmatrixj)#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
#
## Plots#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes")#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes")
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  rmatrixj<-matrix(nrow=(0), ncol=(0))#
  dmatrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
    meanvoteDts<-mean(voteDts)#
    meanvoteRts<-mean(voteRts)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
	rmatrixj<- list(rmatrixj, meanvoteRts)#
	dmatrixj<- list(dmatrixj, meanvoteDts)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
meanparticipation<-(voteRts+voteDts)/2#
#
rframej <- data.frame(matrix(unlist(list(rmatrixj)), nrow=n, byrow=TRUE))#
dframej <- data.frame(matrix(unlist(list(dmatrixj)), nrow=n, byrow=TRUE))#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## For last election only#
mean(rmatrixj)#
mean(dmatrixj)#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
#
## Plots#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes")#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes")
rmatrixj
rframej
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  rmatrixj<-matrix(nrow=(0), ncol=(0))#
  dmatrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
    meanvoteDts<-mean(voteDts)#
    meanvoteRts<-mean(voteRts)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
	rmatrixj<- list(rmatrixj, meanvoteRts)#
	dmatrixj<- list(dmatrixj, meanvoteDts)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
meanparticipation<-(voteRts+voteDts)/2#
#
rframej <- data.frame(matrix(unlist(list(rmatrixj)), nrow=n, byrow=FALSE))#
dframej <- data.frame(matrix(unlist(list(dmatrixj)), nrow=n, byrow=FALSE))#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## For last election only#
mean(rmatrixj)#
mean(dmatrixj)#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
#
## Plots#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes")#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes")
rmatrixj
rframej
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  rmatrixj<-matrix(nrow=(0), ncol=(0))#
  dmatrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
    meanvoteDts<-mean(voteDts)#
    meanvoteRts<-mean(voteRts)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
	rmatrixj<- list(rmatrixj, meanvoteRts)#
	dmatrixj<- list(dmatrixj, meanvoteDts)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
meanparticipation<-(voteRts+voteDts)/2#
#
rframej <- data.frame(matrix(unlist(list(rmatrixj)), nrow=nPeriods, byrow=TRUE))#
dframej <- data.frame(matrix(unlist(list(dmatrixj)), nrow=nPeriods, byrow=TRUE))#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## For last election only#
mean(rmatrixj)#
mean(dmatrixj)#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
#
## Plots#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes")#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes")
rframej
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  rmatrixj<-matrix(nrow=(0), ncol=(0))#
  dmatrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
    meanvoteDts<-mean(voteDts)#
    meanvoteRts<-mean(voteRts)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
	rmatrixj<- list(rmatrixj, meanvoteRts)#
	dmatrixj<- list(dmatrixj, meanvoteDts)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
meanparticipation<-(voteRts+voteDts)/2#
#
rframej <- data.frame(matrix(unlist(list(rmatrixj)), nrow=nPeriods, byrow=TRUE))#
dframej <- data.frame(matrix(unlist(list(dmatrixj)), nrow=nPeriods, byrow=TRUE))#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## For last election only#
colMeans(rmatrixj)#
colMeans(dmatrixj)#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
#
## Plots#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes")#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes")
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  rmatrixj<-matrix(nrow=(0), ncol=(0))#
  dmatrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
    meanvoteDts<-mean(voteDts)#
    meanvoteRts<-mean(voteRts)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
	rmatrixj<- list(rmatrixj, meanvoteRts)#
	dmatrixj<- list(dmatrixj, meanvoteDts)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
meanparticipation<-(voteRts+voteDts)/2#
#
rframej <- data.frame(matrix(unlist(list(rmatrixj)), nrow=nPeriods, byrow=TRUE))#
dframej <- data.frame(matrix(unlist(list(dmatrixj)), nrow=nPeriods, byrow=TRUE))#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## For last election only#
rowMeans(rmatrixj)#
rowMeans(dmatrixj)#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
#
## Plots#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes")#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes")
rframej
sum(rframej[1])
mean(rframej[1])
mean(rmatrixj[1])
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  ##rmatrixj<-matrix(nrow=(0), ncol=(0))#
  ##dmatrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
    ##meanvoteDts<-mean(voteDts)#
    ##meanvoteRts<-mean(voteRts)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
	##rmatrixj<- list(rmatrixj, meanvoteRts)#
	##dmatrixj<- list(dmatrixj, meanvoteDts)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
meanparticipation<-(voteRts+voteDts)/2#
#
rframej <- data.frame(matrix(unlist(list(rmatrixj)), nrow=nPeriods, byrow=TRUE))#
dframej <- data.frame(matrix(unlist(list(dmatrixj)), nrow=nPeriods, byrow=TRUE))#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## For last election only#
## rowMeans(rmatrixj)#
## rowMeans(dmatrixj)#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
#
## Plots#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes")#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes")
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  ##rmatrixj<-matrix(nrow=(0), ncol=(0))#
  ##dmatrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
    ##meanvoteDts<-mean(voteDts)#
    ##meanvoteRts<-mean(voteRts)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
	##rmatrixj<- list(rmatrixj, meanvoteRts)#
	##dmatrixj<- list(dmatrixj, meanvoteDts)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
meanparticipation<-(voteRts+voteDts)/2#
#
## rframej <- data.frame(matrix(unlist(list(rmatrixj)), nrow=nPeriods, byrow=TRUE))#
## dframej <- data.frame(matrix(unlist(list(dmatrixj)), nrow=nPeriods, byrow=TRUE))#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## For last election only#
## rowMeans(rmatrixj)#
## rowMeans(dmatrixj)#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
#
## Plots#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes")#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes")
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  ##rmatrixj<-matrix(nrow=(0), ncol=(0))#
  ##dmatrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
    ##meanvoteDts<-mean(voteDts)#
    ##meanvoteRts<-mean(voteRts)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
	##rmatrixj<- list(rmatrixj, meanvoteRts)#
	##dmatrixj<- list(dmatrixj, meanvoteDts)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
meanparticipation<-(voteRts+voteDts)/2#
#
## rframej <- data.frame(matrix(unlist(list(rmatrixj)), nrow=nPeriods, byrow=TRUE))#
## dframej <- data.frame(matrix(unlist(list(dmatrixj)), nrow=nPeriods, byrow=TRUE))#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## For last election only#
## rowMeans(rmatrixj)#
## rowMeans(dmatrixj)#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
#
## Plots#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot((elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes", col="Red"), (elections, voteDts))#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes")
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  ##rmatrixj<-matrix(nrow=(0), ncol=(0))#
  ##dmatrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
    ##meanvoteDts<-mean(voteDts)#
    ##meanvoteRts<-mean(voteRts)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
	##rmatrixj<- list(rmatrixj, meanvoteRts)#
	##dmatrixj<- list(dmatrixj, meanvoteDts)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
meanparticipation<-(voteRts+voteDts)/2#
#
## rframej <- data.frame(matrix(unlist(list(rmatrixj)), nrow=nPeriods, byrow=TRUE))#
## dframej <- data.frame(matrix(unlist(list(dmatrixj)), nrow=nPeriods, byrow=TRUE))#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## For last election only#
## rowMeans(rmatrixj)#
## rowMeans(dmatrixj)#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
#
## Plots#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot((elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes", col="Red") (elections, voteDts))#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes")
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  ##rmatrixj<-matrix(nrow=(0), ncol=(0))#
  ##dmatrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
    ##meanvoteDts<-mean(voteDts)#
    ##meanvoteRts<-mean(voteRts)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
	##rmatrixj<- list(rmatrixj, meanvoteRts)#
	##dmatrixj<- list(dmatrixj, meanvoteDts)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
meanparticipation<-(voteRts+voteDts)/2#
#
## rframej <- data.frame(matrix(unlist(list(rmatrixj)), nrow=nPeriods, byrow=TRUE))#
## dframej <- data.frame(matrix(unlist(list(dmatrixj)), nrow=nPeriods, byrow=TRUE))#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## For last election only#
## rowMeans(rmatrixj)#
## rowMeans(dmatrixj)#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
#
## Plots#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot((elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes" col="Red") (elections, voteDts))#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes")
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  ##rmatrixj<-matrix(nrow=(0), ncol=(0))#
  ##dmatrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
    ##meanvoteDts<-mean(voteDts)#
    ##meanvoteRts<-mean(voteRts)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
	##rmatrixj<- list(rmatrixj, meanvoteRts)#
	##dmatrixj<- list(dmatrixj, meanvoteDts)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
meanparticipation<-(voteRts+voteDts)/2#
#
## rframej <- data.frame(matrix(unlist(list(rmatrixj)), nrow=nPeriods, byrow=TRUE))#
## dframej <- data.frame(matrix(unlist(list(dmatrixj)), nrow=nPeriods, byrow=TRUE))#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## For last election only#
## rowMeans(rmatrixj)#
## rowMeans(dmatrixj)#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
#
## Plots#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes")#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes")
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  ##rmatrixj<-matrix(nrow=(0), ncol=(0))#
  ##dmatrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
    ##meanvoteDts<-mean(voteDts)#
    ##meanvoteRts<-mean(voteRts)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
	##rmatrixj<- list(rmatrixj, meanvoteRts)#
	##dmatrixj<- list(dmatrixj, meanvoteDts)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
meanparticipation<-(voteRts+voteDts)/2#
#
## rframej <- data.frame(matrix(unlist(list(rmatrixj)), nrow=nPeriods, byrow=TRUE))#
## dframej <- data.frame(matrix(unlist(list(dmatrixj)), nrow=nPeriods, byrow=TRUE))#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## For last election only#
## rowMeans(rmatrixj)#
## rowMeans(dmatrixj)#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
#
## Plots#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes")#
par(new=T)#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes")#
par(new=F)
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  ##rmatrixj<-matrix(nrow=(0), ncol=(0))#
  ##dmatrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
    ##meanvoteDts<-mean(voteDts)#
    ##meanvoteRts<-mean(voteRts)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
	##rmatrixj<- list(rmatrixj, meanvoteRts)#
	##dmatrixj<- list(dmatrixj, meanvoteDts)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
meanparticipation<-(voteRts+voteDts)/2#
#
## rframej <- data.frame(matrix(unlist(list(rmatrixj)), nrow=nPeriods, byrow=TRUE))#
## dframej <- data.frame(matrix(unlist(list(dmatrixj)), nrow=nPeriods, byrow=TRUE))#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## For last election only#
## rowMeans(rmatrixj)#
## rowMeans(dmatrixj)#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
#
## Plots#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes")#
par(new=T)#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes", col="Red")#
par(new=F)
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  ##rmatrixj<-matrix(nrow=(0), ncol=(0))#
  ##dmatrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
    ##meanvoteDts<-mean(voteDts)#
    ##meanvoteRts<-mean(voteRts)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
	##rmatrixj<- list(rmatrixj, meanvoteRts)#
	##dmatrixj<- list(dmatrixj, meanvoteDts)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
meanparticipation<-(voteRts+voteDts)/2#
#
## rframej <- data.frame(matrix(unlist(list(rmatrixj)), nrow=nPeriods, byrow=TRUE))#
## dframej <- data.frame(matrix(unlist(list(dmatrixj)), nrow=nPeriods, byrow=TRUE))#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## For last election only#
## rowMeans(rmatrixj)#
## rowMeans(dmatrixj)#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
#
## Plots#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes", col="Red")#
par(new=T)#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes", col="Blue")#
par(new=F)
help packages
installed.packages
library()
install.packages("ggplot2")
library()
install.packages("shiny")
library()
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=FALSE))#
primarySums<- colSums(primaryframej) ## Participation in Primary#
primaryMeans<- colMeans(primaryframej) ## Participation Rate#
primaryMeans#
nPeriodthPrimaryMean<-primaryMeans[7]#
nPeriodthPrimaryMean#
primarytotalvotes<-rowSums(primaryframej) ## Individual Participation by number of votes#
primaryparticipation<-table(primarytotalvotes) ## Summary of number of times respondents voted#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
## meanparticipation<-(voteRts+voteDts)/2 ## For each of nPeriods#
#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## Voting rate for last election only#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
#
## Plots#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes", col="Red")#
##par(new=T)#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes", col="Blue")#
##par(new=F)#
#
sum(actions)#
primarySums[7]
actions
primaryframej[7]
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primarySums<- colSums(primaryframej) ## Participation in Primary#
primaryMeans<- colMeans(primaryframej) ## Participation Rate#
primaryMeans#
nPeriodthPrimaryMean<-primaryMeans[7]#
nPeriodthPrimaryMean#
primarytotalvotes<-rowSums(primaryframej) ## Individual Participation by number of votes#
primaryparticipation<-table(primarytotalvotes) ## Summary of number of times respondents voted#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
## meanparticipation<-(voteRts+voteDts)/2 ## For each of nPeriods#
#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## Voting rate for last election only#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
#
## Plots#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes", col="Red")#
##par(new=T)#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes", col="Blue")#
##par(new=F)#
#
sum(actions)#
primarySums[7]
meanparticipation<-(voteRts+voteDts)/2 ## For each of nPeriods
meanparticipation
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primarySums<- colSums(primaryframej) ## Participation in Primary#
primaryMeans<- colMeans(primaryframej) ## Participation Rate#
primaryMeans#
nPeriodthPrimaryMean<-primaryMeans[7]#
nPeriodthPrimaryMean#
primarytotalvotes<-rowSums(primaryframej) ## Individual Participation by number of votes#
primaryparticipation<-table(primarytotalvotes) ## Summary of number of times respondents voted#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
## meanparticipation<-(voteRts+voteDts)/2 ## For each of nPeriods#
#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## Voting rate for last election only#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
#
## Plots#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes", col="Red")#
##par(new=T)#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes", col="Blue")#
##par(new=F)#
#
sum(actions)#
primarySums[7]
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primarySums<- colSums(primaryframej) ## Participation in Primary#
primaryMeans<- colMeans(primaryframej) ## Participation Rate#
## primaryMeans#
nPeriodthPrimaryMean<-primaryMeans[7]#
nPeriodthPrimaryMean#
#
primaryIndVotes<-rowSums(primaryframej) ## Individual Participation by number of votes#
primaryIndParticipation<-table(primaryIndVotes) ## Summary of number of times respondents voted#
primaryIndParticipation#
barplot(primaryIndParticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
## meanparticipation<-(voteRts+voteDts)/2 ## For each of nPeriods#
#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## Voting rate for last election only#
#
##Habitual Voting Behavior#
primaryHabitual<-(((primaryIndParticipation["0"])+(primaryIndParticipation["7"]))/n)#
primaryHabitual#
#
## Plots#
% par(mfrow=c(2,2))#
% barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
% plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes", col="Red")#
% ##par(new=T)#
% plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes", col="Blue")#
##par(new=F)#
#
sum(actions)#
primarySums[7]
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primarySums<- colSums(primaryframej) ## Participation in Primary#
primaryMeans<- colMeans(primaryframej) ## Participation Rate#
## primaryMeans#
nPeriodthPrimaryMean<-primaryMeans[7]#
nPeriodthPrimaryMean#
#
primaryIndVotes<-rowSums(primaryframej) ## Individual Participation by number of votes#
primaryIndParticipation<-table(primaryIndVotes) ## Summary of number of times respondents voted#
primaryIndParticipation#
## barplot(primaryIndParticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
## meanparticipation<-(voteRts+voteDts)/2 ## For each of nPeriods#
#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## Voting rate for last election only#
#
##Habitual Voting Behavior#
primaryHabitual<-(((primaryIndParticipation["0"])+(primaryIndParticipation["7"]))/n)#
primaryHabitual#
#
## Plots#
## par(mfrow=c(2,2))#
## barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
## plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes", col="Red")#
##par(new=T)#
## plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes", col="Blue")#
##par(new=F)#
#
sum(actions)#
primarySums[7]
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primarySums<- colSums(primaryframej) ## Participation in Primary#
primaryMeans<- colMeans(primaryframej) ## Participation Rate#
## primaryMeans#
nPeriodthPrimaryMean<-primaryMeans[7]#
nPeriodthPrimaryMean#
#
primaryIndVotes<-rowSums(primaryframej) ## Individual Participation by number of votes#
primaryIndParticipation<-table(primaryIndVotes) ## Summary of number of times respondents voted (mode)#
primaryIndParticipation#
## barplot(primaryIndParticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
## meanparticipation<-(voteRts+voteDts)/2 ## For each of nPeriods#
#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## Voting rate for last election only#
#
##Habitual Voting Behavior#
primaryHabitual<-(((primaryIndParticipation["0"])+(primaryIndParticipation["7"]))/n)#
primaryHabitual#
#
## Plots#
## par(mfrow=c(2,2))#
## barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
## plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes", col="Red")#
##par(new=T)#
## plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes", col="Blue")#
##par(new=F)#
#
sum(actions)#
primarySums[7]
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primarySums<- colSums(primaryframej) ## Participation in Primary#
primaryMeans<- colMeans(primaryframej) ## Participation Rate#
## primaryMeans#
nPeriodthPrimaryMean<-primaryMeans[7]#
nPeriodthPrimaryMean#
#
primaryIndVotes<-rowSums(primaryframej) ## Individual Participation by number of votes#
primaryIndParticipation<-table(primaryIndVotes) ## Summary of number of times respondents voted (mode)#
primaryIndParticipation#
## barplot(primaryIndParticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
## meanparticipation<-(voteRts+voteDts)/2 ## For each of nPeriods#
#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## Voting rate for last election only#
#
##Habitual Voting Behavior#
primaryHabitual<-(((primaryIndParticipation["0"])+(primaryIndParticipation["7"]))/n)#
primaryHabitual#
#
## Plots#
## par(mfrow=c(2,2))#
## barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
## plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes", col="Red")#
##par(new=T)#
## plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes", col="Blue")#
##par(new=F)#
#
sum(actions)#
primarySums[7]#
##}
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-10 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  votematrixi<-matrix(nrow=(0), ncol=(0))#
  habitmatrixi<-matrix(nrow=(0), ncol=(0))#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primarySums<- colSums(primaryframej) ## Participation in Primary#
primaryMeans<- colMeans(primaryframej) ## Participation Rate#
## primaryMeans#
nPeriodthPrimaryMean<-primaryMeans[7]#
nPeriodthPrimaryMean#
#
primaryIndVotes<-rowSums(primaryframej) ## Individual Participation by number of votes#
primaryIndParticipation<-table(primaryIndVotes) ## Summary of number of times respondents voted (mode)#
primaryIndParticipation#
## barplot(primaryIndParticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
## meanparticipation<-(voteRts+voteDts)/2 ## For each of nPeriods#
#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## Voting rate for last election only#
#
##Habitual Voting Behavior#
primaryHabitual<-(((primaryIndParticipation["0"])+(primaryIndParticipation["7"]))/n) ## For consistent voters and abstainers#
primaryHabitual#
#
## Plots#
## par(mfrow=c(2,2))#
## barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
## plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes", col="Red")#
##par(new=T)#
## plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes", col="Blue")#
##par(new=F)#
#
sum(actions)#
primarySums[7]#
#
votematrixi<- list(votematrixi, mean(actions))#
habitmatrixi<- list(habitmatrixi, primaryHabitual)#
}
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-10 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  votematrixi<-matrix(nrow=(0), ncol=(0))#
  habitmatrixi<-matrix(nrow=(0), ncol=(0))#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primarySums<- colSums(primaryframej) ## Participation in Primary#
primaryMeans<- colMeans(primaryframej) ## Participation Rate#
## primaryMeans#
nPeriodthPrimaryMean<-primaryMeans[7]#
nPeriodthPrimaryMean#
#
primaryIndVotes<-rowSums(primaryframej) ## Individual Participation by number of votes#
primaryIndParticipation<-table(primaryIndVotes) ## Summary of number of times respondents voted (mode)#
primaryIndParticipation#
## barplot(primaryIndParticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
## meanparticipation<-(voteRts+voteDts)/2 ## For each of nPeriods#
#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## Voting rate for last election only#
#
##Habitual Voting Behavior#
primaryHabitual<-(((primaryIndParticipation["0"])+(primaryIndParticipation["7"]))/n) ## For consistent voters and abstainers#
primaryHabitual#
#
## Plots#
## par(mfrow=c(2,2))#
## barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
## plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes", col="Red")#
##par(new=T)#
## plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes", col="Blue")#
##par(new=F)#
#
sum(actions)#
primarySums[7]#
#
votematrixi<- list(votematrixi, mean(actions))#
habitmatrixi<- list(habitmatrixi, primaryHabitual)#
}
votematrixi
habitmatrixi
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-10 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
votematrixi<-matrix(nrow=(0), ncol=(0))#
habitmatrixi<-matrix(nrow=(0), ncol=(0))#
#
for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primarySums<- colSums(primaryframej) ## Participation in Primary#
primaryMeans<- colMeans(primaryframej) ## Participation Rate#
## primaryMeans#
nPeriodthPrimaryMean<-primaryMeans[7]#
nPeriodthPrimaryMean#
#
primaryIndVotes<-rowSums(primaryframej) ## Individual Participation by number of votes#
primaryIndParticipation<-table(primaryIndVotes) ## Summary of number of times respondents voted (mode)#
primaryIndParticipation#
## barplot(primaryIndParticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
## meanparticipation<-(voteRts+voteDts)/2 ## For each of nPeriods#
#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## Voting rate for last election only#
#
##Habitual Voting Behavior#
primaryHabitual<-(((primaryIndParticipation["0"])+(primaryIndParticipation["7"]))/n) ## For consistent voters and abstainers#
primaryHabitual#
#
## Plots#
## par(mfrow=c(2,2))#
## barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
## plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes", col="Red")#
##par(new=T)#
## plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes", col="Blue")#
##par(new=F)#
#
sum(actions)#
primarySums[7]#
#
votematrixi<- list(votematrixi, mean(actions))#
habitmatrixi<- list(habitmatrixi, primaryHabitual)#
}
votematrixi
habitmatrixi
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-10 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
votematrixi<-matrix(nrow=(0), ncol=(0))#
habitmatrixi<-matrix(nrow=(0), ncol=(0))#
#
for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##Primary Election Data#
primaryVoteFramej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primaryVoteSumsj<- colSums(primaryVoteFramej) ## Participation in Primary#
primaryVoteMeansj<- colMeans(primaryVoteFramej) ## Participation Rate#
## primaryVoteMeansj#
nPeriodthPrimaryMeanj<-primaryVoteMeansj[7]#
nPeriodthPrimaryMeanj#
#
primaryIndVotesj<-rowSums(primaryVoteFramej) ## Individual Participation by number of votes#
primaryIndParticipationj<-table(primaryIndVotesj) ## Summary of number of times respondents voted (mode)#
primaryIndParticipationj#
## barplot(primaryIndParticipationj, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
electionsj<-c(1:nPeriods)#
## meanparticipationj<-(voteRts+voteDts)/2 ## For each of nPeriods#
#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## Voting rate for last election only#
#
##Habitual Voting Behavior#
primaryHabitualj<-(((primaryIndParticipationj["0"])+(primaryIndParticipationj["7"]))/n) ## For consistent voters and abstainers#
primaryHabitualj#
#
## Plots#
## par(mfrow=c(2,2))#
## barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
## plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes", col="Red")#
##par(new=T)#
## plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes", col="Blue")#
##par(new=F)#
#
sum(actions)#
primarySums[7]#
#
votematrixi<- list(votematrixi, mean(actions))#
habitmatrixi<- list(habitmatrixi, primaryHabitualj)#
#
}#
#
primaryVoteFramei <- data.frame(matrix(unlist(list(votematrixi)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primaryHabitFramei <- data.frame(matrix(unlist(list(habitmatrixi)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
#
primaryVoteSumsi<- colSums(primaryVoteFramei) ## Participation in Primary#
primaryVoteMeansi<- colMeans(primaryVoteFramei) ## Participation Rate#
## primaryVoteMeansi#
nPeriodthPrimaryMean<-primaryVoteMeansi[7]#
nPeriodthPrimaryMeani#
#
primaryIndVotes<-rowSums(primaryVoteFramej) ## Individual Participation by number of votes#
primaryIndParticipation<-table(primaryIndVotes) ## Summary of number of times respondents voted (mode)#
primaryIndParticipation#
## barplot(primaryIndParticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
## meanparticipation<-(voteRts+voteDts)/2 ## For each of nPeriods#
#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## Voting rate for last election only#
#
##Habitual Voting Behavior#
primaryHabitual<-(((primaryIndParticipation["0"])+(primaryIndParticipation["7"]))/n) ## For consistent voters and abstainers#
primaryHabitual
primaryVoteFramei
votematrixi
habitmatrixi
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-10 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  votematrixi<-matrix(nrow=(0), ncol=(0))#
  habitmatrixi<-matrix(nrow=(0), ncol=(0))#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##Primary Election Data#
primaryVoteFramej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primaryVoteSumsj<- colSums(primaryVoteFramej) ## Participation in Primary#
primaryVoteMeansj<- colMeans(primaryVoteFramej) ## Participation Rate#
## primaryVoteMeansj#
nPeriodthPrimaryMeanj<-primaryVoteMeansj[7]#
nPeriodthPrimaryMeanj#
#
primaryIndVotesj<-rowSums(primaryVoteFramej) ## Individual Participation by number of votes#
primaryIndParticipationj<-table(primaryIndVotesj) ## Summary of number of times respondents voted (mode)#
primaryIndParticipationj#
## barplot(primaryIndParticipationj, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
electionsj<-c(1:nPeriods)#
## meanparticipationj<-(voteRts+voteDts)/2 ## For each of nPeriods#
#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## Voting rate for last election only#
#
##Habitual Voting Behavior#
primaryHabitualj<-(((primaryIndParticipationj["0"])+(primaryIndParticipationj["7"]))/n) ## For consistent voters and abstainers#
primaryHabitualj#
#
## Plots#
## par(mfrow=c(2,2))#
## barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
## plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes", col="Red")#
##par(new=T)#
## plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes", col="Blue")#
##par(new=F)#
#
sum(actions)#
primarySumsj[7]#
#
votematrixi<- list(votematrixi, mean(actions))#
habitmatrixi<- list(habitmatrixi, primaryHabitualj)#
#
}#
#
primaryVoteFramei <- data.frame(matrix(unlist(list(votematrixi)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primaryHabitFramei <- data.frame(matrix(unlist(list(habitmatrixi)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
#
primaryVoteSumsi<- colSums(primaryVoteFramei) ## Participation in Primary#
primaryVoteMeansi<- colMeans(primaryVoteFramei) ## Participation Rate#
## primaryVoteMeansi#
nPeriodthPrimaryMeani<-primaryVoteMeansi[7]#
nPeriodthPrimaryMeani#
#
primaryIndVotes<-rowSums(primaryVoteFramej) ## Individual Participation by number of votes#
primaryIndParticipation<-table(primaryIndVotes) ## Summary of number of times respondents voted (mode)#
primaryIndParticipation#
## barplot(primaryIndParticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
## meanparticipation<-(voteRts+voteDts)/2 ## For each of nPeriods#
#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## Voting rate for last election only#
#
##Habitual Voting Behavior#
primaryHabitual<-(((primaryIndParticipation["0"])+(primaryIndParticipation["7"]))/n) ## For consistent voters and abstainers#
primaryHabitual
votematrixi
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-10 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  votematrixi<-matrix(nrow=(0), ncol=(0))#
  habitmatrixi<-matrix(nrow=(0), ncol=(0))#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##Primary Election Data#
primaryVoteFramej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primaryVoteSumsj<- colSums(primaryVoteFramej) ## Participation in Primary#
primaryVoteMeansj<- colMeans(primaryVoteFramej) ## Participation Rate#
## primaryVoteMeansj#
nPeriodthPrimaryMeanj<-primaryVoteMeansj[7]#
nPeriodthPrimaryMeanj#
#
primaryIndVotesj<-rowSums(primaryVoteFramej) ## Individual Participation by number of votes#
primaryIndParticipationj<-table(primaryIndVotesj) ## Summary of number of times respondents voted (mode)#
primaryIndParticipationj#
## barplot(primaryIndParticipationj, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
electionsj<-c(1:nPeriods)#
## meanparticipationj<-(voteRts+voteDts)/2 ## For each of nPeriods#
#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## Voting rate for last election only#
#
##Habitual Voting Behavior#
primaryHabitualj<-(((primaryIndParticipationj["0"])+(primaryIndParticipationj["7"]))/n) ## For consistent voters and abstainers#
primaryHabitualj#
#
## Plots#
## par(mfrow=c(2,2))#
## barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
## plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes", col="Red")#
##par(new=T)#
## plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes", col="Blue")#
##par(new=F)#
#
sum(actions)#
primarySumsj[7]#
#
  votematrixi<- list(votematrixi, mean(actions))#
  habitmatrixi<- list(habitmatrixi, primaryHabitualj)#
#
}#
#
primaryVoteFramei <- data.frame(matrix(unlist(list(votematrixi)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primaryHabitFramei <- data.frame(matrix(unlist(list(habitmatrixi)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
#
primaryVoteSumsi<- colSums(primaryVoteFramei) ## Participation in Primary#
primaryVoteMeansi<- colMeans(primaryVoteFramei) ## Participation Rate#
## primaryVoteMeansi#
nPeriodthPrimaryMeani<-primaryVoteMeansi[7]#
nPeriodthPrimaryMeani#
#
primaryIndVotes<-rowSums(primaryVoteFramej) ## Individual Participation by number of votes#
primaryIndParticipation<-table(primaryIndVotes) ## Summary of number of times respondents voted (mode)#
primaryIndParticipation#
## barplot(primaryIndParticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
## meanparticipation<-(voteRts+voteDts)/2 ## For each of nPeriods#
#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## Voting rate for last election only#
#
##Habitual Voting Behavior#
primaryHabitual<-(((primaryIndParticipation["0"])+(primaryIndParticipation["7"]))/n) ## For consistent voters and abstainers#
primaryHabitual
votematrixi
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-10 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  votematrixi<-matrix(nrow=(0), ncol=(0))#
  habitmatrixi<-matrix(nrow=(0), ncol=(0))#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##Primary Election Data#
primaryVoteFramej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primaryVoteSumsj<- colSums(primaryVoteFramej) ## Participation in Primary#
primaryVoteMeansj<- colMeans(primaryVoteFramej) ## Participation Rate#
## primaryVoteMeansj#
nPeriodthPrimaryMeanj<-primaryVoteMeansj[7]#
nPeriodthPrimaryMeanj#
#
primaryIndVotesj<-rowSums(primaryVoteFramej) ## Individual Participation by number of votes#
primaryIndParticipationj<-table(primaryIndVotesj) ## Summary of number of times respondents voted (mode)#
primaryIndParticipationj#
## barplot(primaryIndParticipationj, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
electionsj<-c(1:nPeriods)#
## meanparticipationj<-(voteRts+voteDts)/2 ## For each of nPeriods#
#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## Voting rate for last election only#
#
##Habitual Voting Behavior#
primaryHabitualj<-(((primaryIndParticipationj["0"])+(primaryIndParticipationj["7"]))/n) ## For consistent voters and abstainers#
primaryHabitualj#
#
## Plots#
## par(mfrow=c(2,2))#
## barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
## plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes", col="Red")#
##par(new=T)#
## plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes", col="Blue")#
##par(new=F)#
#
sum(actions)#
primarySumsj[7]#
#
votematrixi<- list(votematrixi, mean(actions))#
habitmatrixi<- list(habitmatrixi, primaryHabitualj)#
#
}
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-10 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  votematrixi<-matrix(nrow=(0), ncol=(0))#
  habitmatrixi<-matrix(nrow=(0), ncol=(0))#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##Primary Election Data#
primaryVoteFramej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primaryVoteSumsj<- colSums(primaryVoteFramej) ## Participation in Primary#
primaryVoteMeansj<- colMeans(primaryVoteFramej) ## Participation Rate#
## primaryVoteMeansj#
nPeriodthPrimaryMeanj<-primaryVoteMeansj[7]#
nPeriodthPrimaryMeanj#
#
primaryIndVotesj<-rowSums(primaryVoteFramej) ## Individual Participation by number of votes#
primaryIndParticipationj<-table(primaryIndVotesj) ## Summary of number of times respondents voted (mode)#
primaryIndParticipationj#
## barplot(primaryIndParticipationj, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
electionsj<-c(1:nPeriods)#
## meanparticipationj<-(voteRts+voteDts)/2 ## For each of nPeriods#
#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## Voting rate for last election only#
#
##Habitual Voting Behavior#
primaryHabitualj<-(((primaryIndParticipationj["0"])+(primaryIndParticipationj["7"]))/n) ## For consistent voters and abstainers#
primaryHabitualj#
#
## Plots#
## par(mfrow=c(2,2))#
## barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
## plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes", col="Red")#
##par(new=T)#
## plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes", col="Blue")#
##par(new=F)#
#
sum(actions)#
primaryVoteSumsj[7]#
#
votematrixi<- list(votematrixi, mean(actions))#
habitmatrixi<- list(habitmatrixi, primaryHabitualj)#
#
}
votematrixi
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-10 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
votematrixi<-matrix(nrow=(0), ncol=(0))#
habitmatrixi<-matrix(nrow=(0), ncol=(0))#
#
for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##Primary Election Data#
primaryVoteFramej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primaryVoteSumsj<- colSums(primaryVoteFramej) ## Participation in Primary#
primaryVoteMeansj<- colMeans(primaryVoteFramej) ## Participation Rate#
## primaryVoteMeansj#
nPeriodthPrimaryMeanj<-primaryVoteMeansj[7]#
nPeriodthPrimaryMeanj#
#
primaryIndVotesj<-rowSums(primaryVoteFramej) ## Individual Participation by number of votes#
primaryIndParticipationj<-table(primaryIndVotesj) ## Summary of number of times respondents voted (mode)#
primaryIndParticipationj#
## barplot(primaryIndParticipationj, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
electionsj<-c(1:nPeriods)#
## meanparticipationj<-(voteRts+voteDts)/2 ## For each of nPeriods#
#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## Voting rate for last election only#
#
##Habitual Voting Behavior#
primaryHabitualj<-(((primaryIndParticipationj["0"])+(primaryIndParticipationj["7"]))/n) ## For consistent voters and abstainers#
primaryHabitualj#
#
## Plots#
## par(mfrow=c(2,2))#
## barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
## plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes", col="Red")#
##par(new=T)#
## plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes", col="Blue")#
##par(new=F)#
#
sum(actions)#
primaryVoteSumsj[7]#
#
votematrixi<- list(votematrixi, mean(actions))#
habitmatrixi<- list(habitmatrixi, primaryHabitualj)#
#
}
votematrixi
habitmatrixi
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-10 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
votematrixi<-matrix(nrow=(0), ncol=(0))#
habitmatrixi<-matrix(nrow=(0), ncol=(0))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
#
## This section is for inner J loop only #
##Primary Election Data for j Periods#
primaryVoteFramej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primaryVoteSumsj<- colSums(primaryVoteFramej) ## Participation in Primary#
primaryVoteMeansj<- colMeans(primaryVoteFramej) ## Participation Rate#
## primaryVoteMeansj#
nPeriodthPrimaryMeanj<-primaryVoteMeansj[7]#
nPeriodthPrimaryMeanj#
#
primaryIndVotesj<-rowSums(primaryVoteFramej) ## Individual Participation by number of votes#
primaryIndParticipationj<-table(primaryIndVotesj) ## Summary of number of times respondents voted (mode)#
primaryIndParticipationj#
## barplot(primaryIndParticipationj, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
electionsj<-c(1:nPeriods)#
## meanparticipationj<-(voteRts+voteDts)/2 ## For each of nPeriods#
#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## Voting rate for last election only#
#
##Habitual Voting Behavior#
primaryHabitualj<-(((primaryIndParticipationj["0"])+(primaryIndParticipationj["7"]))/n) ## For consistent voters and abstainers#
primaryHabitualj#
#
## Plots#
## par(mfrow=c(2,2))#
## barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
## plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes", col="Red")#
##par(new=T)#
## plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes", col="Blue")#
##par(new=F)#
#
sum(actions)#
primaryVoteSumsj[7]#
#
votematrixi<- list(votematrixi, mean(actions))#
habitmatrixi<- list(habitmatrixi, primaryHabitualj)#
#
## }
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-10 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
votematrixi<-matrix(nrow=(0), ncol=(0))#
habitmatrixi<-matrix(nrow=(0), ncol=(0))#
#
for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
#
## This section is for inner J loop only #
##Primary Election Data for j Periods#
primaryVoteFramej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primaryVoteSumsj<- colSums(primaryVoteFramej) ## Participation in Primary#
primaryVoteMeansj<- colMeans(primaryVoteFramej) ## Participation Rate#
## primaryVoteMeansj#
nPeriodthPrimaryMeanj<-primaryVoteMeansj[7]#
nPeriodthPrimaryMeanj#
#
primaryIndVotesj<-rowSums(primaryVoteFramej) ## Individual Participation by number of votes#
primaryIndParticipationj<-table(primaryIndVotesj) ## Summary of number of times respondents voted (mode)#
primaryIndParticipationj#
## barplot(primaryIndParticipationj, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
electionsj<-c(1:nPeriods)#
## meanparticipationj<-(voteRts+voteDts)/2 ## For each of nPeriods#
#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## Voting rate for last election only#
#
##Habitual Voting Behavior#
primaryHabitualj<-(((primaryIndParticipationj["0"])+(primaryIndParticipationj["7"]))/n) ## For consistent voters and abstainers#
primaryHabitualj#
#
## Plots#
## par(mfrow=c(2,2))#
## barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
## plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes", col="Red")#
##par(new=T)#
## plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes", col="Blue")#
##par(new=F)#
#
sum(actions)#
primaryVoteSumsj[7]#
#
votematrixi<- list(votematrixi, mean(actions))#
habitmatrixi<- list(habitmatrixi, primaryHabitualj)#
#
}#
#
primaryVoteFramei <- data.frame(matrix(unlist(list(votematrixi)), nrow=n, byrow=FALSE))  ## Extracts data from matrix
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-10 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
votematrixi<-matrix(nrow=(0), ncol=(0))#
habitmatrixi<-matrix(nrow=(0), ncol=(0))#
#
for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
#
## This section is for inner J loop only #
##Primary Election Data for j Periods#
primaryVoteFramej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primaryVoteSumsj<- colSums(primaryVoteFramej) ## Participation in Primary#
primaryVoteMeansj<- colMeans(primaryVoteFramej) ## Participation Rate#
## primaryVoteMeansj#
nPeriodthPrimaryMeanj<-primaryVoteMeansj[7]#
nPeriodthPrimaryMeanj#
#
primaryIndVotesj<-rowSums(primaryVoteFramej) ## Individual Participation by number of votes#
primaryIndParticipationj<-table(primaryIndVotesj) ## Summary of number of times respondents voted (mode)#
primaryIndParticipationj#
## barplot(primaryIndParticipationj, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
electionsj<-c(1:nPeriods)#
## meanparticipationj<-(voteRts+voteDts)/2 ## For each of nPeriods#
#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## Voting rate for last election only#
#
##Habitual Voting Behavior#
primaryHabitualj<-(((primaryIndParticipationj["0"])+(primaryIndParticipationj["7"]))/n) ## For consistent voters and abstainers#
primaryHabitualj#
#
## Plots#
## par(mfrow=c(2,2))#
## barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
## plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes", col="Red")#
##par(new=T)#
## plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes", col="Blue")#
##par(new=F)#
#
sum(actions)#
primaryVoteSumsj[7]#
#
votematrixi<- list(votematrixi, mean(actions))#
habitmatrixi<- list(habitmatrixi, primaryHabitualj)#
#
}#
#
primaryVoteFramei <- data.frame(matrix(unlist(list(votematrixi)), nrow=nSims, byrow=FALSE))  ## Extracts data from matrix
primaryVoteFramei
colSums(primaryVoteFramei)
colMeans(primaryVoteFramei)
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-10 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
votematrixi<-matrix(nrow=(0), ncol=(0))#
habitmatrixi<-matrix(nrow=(0), ncol=(0))#
#
for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
#
## This section is for inner J loop only #
##Primary Election Data for j Periods#
primaryVoteFramej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primaryVoteSumsj<- colSums(primaryVoteFramej) ## Participation in Primary#
primaryVoteMeansj<- colMeans(primaryVoteFramej) ## Participation Rate#
## primaryVoteMeansj#
nPeriodthPrimaryMeanj<-primaryVoteMeansj[7]#
nPeriodthPrimaryMeanj#
#
primaryIndVotesj<-rowSums(primaryVoteFramej) ## Individual Participation by number of votes#
primaryIndParticipationj<-table(primaryIndVotesj) ## Summary of number of times respondents voted (mode)#
primaryIndParticipationj#
## barplot(primaryIndParticipationj, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
electionsj<-c(1:nPeriods)#
## meanparticipationj<-(voteRts+voteDts)/2 ## For each of nPeriods#
#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## Voting rate for last election only#
#
##Habitual Voting Behavior#
primaryHabitualj<-(((primaryIndParticipationj["0"])+(primaryIndParticipationj["7"]))/n) ## For consistent voters and abstainers#
primaryHabitualj#
#
## Plots#
## par(mfrow=c(2,2))#
## barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
## plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes", col="Red")#
##par(new=T)#
## plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes", col="Blue")#
##par(new=F)#
#
sum(actions)#
primaryVoteSumsj[7]#
#
votematrixi<- list(votematrixi, mean(actions))#
habitmatrixi<- list(habitmatrixi, primaryHabitualj)#
#
}#
#
primaryVoteFramei <- data.frame(matrix(unlist(list(votematrixi)), nrow=nSims, byrow=FALSE))  ## Extracts data from matrix#
primaryVoteMeansi<-colMeans(primaryVoteFramei) ## Vote Mean for nSims#
primaryVoteMeansi
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-10 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
votematrixi<-matrix(nrow=(0), ncol=(0))#
habitmatrixi<-matrix(nrow=(0), ncol=(0))#
#
for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
#
## This section is for inner J loop only #
##Primary Election Data for j Periods#
primaryVoteFramej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primaryVoteSumsj<- colSums(primaryVoteFramej) ## Participation in Primary#
primaryVoteMeansj<- colMeans(primaryVoteFramej) ## Participation Rate#
## primaryVoteMeansj#
nPeriodthPrimaryMeanj<-primaryVoteMeansj[7]#
nPeriodthPrimaryMeanj#
#
primaryIndVotesj<-rowSums(primaryVoteFramej) ## Individual Participation by number of votes#
primaryIndParticipationj<-table(primaryIndVotesj) ## Summary of number of times respondents voted (mode)#
primaryIndParticipationj#
## barplot(primaryIndParticipationj, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
electionsj<-c(1:nPeriods)#
## meanparticipationj<-(voteRts+voteDts)/2 ## For each of nPeriods#
#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## Voting rate for last election only#
#
##Habitual Voting Behavior#
primaryHabitualj<-(((primaryIndParticipationj["0"])+(primaryIndParticipationj["7"]))/n) ## For consistent voters and abstainers#
primaryHabitualj#
#
## Plots#
## par(mfrow=c(2,2))#
## barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
## plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes", col="Red")#
##par(new=T)#
## plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes", col="Blue")#
##par(new=F)#
#
sum(actions)#
primaryVoteSumsj[7]#
#
votematrixi<- list(votematrixi, actions)#
habitmatrixi<- list(habitmatrixi, primaryHabitualj)#
#
}#
#
primaryVoteFramei <- data.frame(matrix(unlist(list(votematrixi)), nrow=nSims, byrow=FALSE))  ## Extracts data from matrix#
primaryVoteMeansi<-colMeans(primaryVoteFramei) ## Vote Mean for nSims#
primaryVoteMeansi
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-10 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
votematrixi<-matrix(nrow=(0), ncol=(0))#
habitmatrixi<-matrix(nrow=(0), ncol=(0))#
#
for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
#
## This section is for inner J loop only #
##Primary Election Data for j Periods#
primaryVoteFramej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primaryVoteSumsj<- colSums(primaryVoteFramej) ## Participation in Primary#
primaryVoteMeansj<- colMeans(primaryVoteFramej) ## Participation Rate#
## primaryVoteMeansj#
nPeriodthPrimaryMeanj<-primaryVoteMeansj[7]#
nPeriodthPrimaryMeanj#
#
primaryIndVotesj<-rowSums(primaryVoteFramej) ## Individual Participation by number of votes#
primaryIndParticipationj<-table(primaryIndVotesj) ## Summary of number of times respondents voted (mode)#
primaryIndParticipationj#
## barplot(primaryIndParticipationj, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
electionsj<-c(1:nPeriods)#
## meanparticipationj<-(voteRts+voteDts)/2 ## For each of nPeriods#
#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## Voting rate for last election only#
#
##Habitual Voting Behavior#
primaryHabitualj<-(((primaryIndParticipationj["0"])+(primaryIndParticipationj["7"]))/n) ## For consistent voters and abstainers#
primaryHabitualj#
#
## Plots#
## par(mfrow=c(2,2))#
## barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
## plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes", col="Red")#
##par(new=T)#
## plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes", col="Blue")#
##par(new=F)#
#
sum(actions)#
primaryVoteSumsj[7]#
#
votematrixi<- list(votematrixi, actions)#
habitmatrixi<- list(habitmatrixi, primaryHabitualj)#
#
}#
#
primaryVoteFramei <- data.frame(matrix(unlist(list(votematrixi)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primaryVoteMeansi<-colMeans(primaryVoteFramei) ## Vote Mean for nSims#
primaryVoteMeansi
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-10 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
votematrixi<-matrix(nrow=(0), ncol=(0))#
habitmatrixi<-matrix(nrow=(0), ncol=(0))#
#
for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
#
## This section is for inner J loop only #
##Primary Election Data for j Periods#
primaryVoteFramej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primaryVoteSumsj<- colSums(primaryVoteFramej) ## Participation in Primary#
primaryVoteMeansj<- colMeans(primaryVoteFramej) ## Participation Rate#
## primaryVoteMeansj#
nPeriodthPrimaryMeanj<-primaryVoteMeansj[7]#
nPeriodthPrimaryMeanj#
#
primaryIndVotesj<-rowSums(primaryVoteFramej) ## Individual Participation by number of votes#
primaryIndParticipationj<-table(primaryIndVotesj) ## Summary of number of times respondents voted (mode)#
primaryIndParticipationj#
## barplot(primaryIndParticipationj, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
electionsj<-c(1:nPeriods)#
## meanparticipationj<-(voteRts+voteDts)/2 ## For each of nPeriods#
#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## Voting rate for last election only#
#
##Habitual Voting Behavior#
primaryHabitualj<-(((primaryIndParticipationj["0"])+(primaryIndParticipationj["7"]))/n) ## For consistent voters and abstainers#
primaryHabitualj#
#
## Plots#
## par(mfrow=c(2,2))#
## barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
## plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes", col="Red")#
##par(new=T)#
## plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes", col="Blue")#
##par(new=F)#
#
sum(actions)#
primaryVoteSumsj[7]#
#
votematrixi<- list(votematrixi, actions)#
habitmatrixi<- list(habitmatrixi, primaryHabitualj)#
#
}#
#
primaryVoteFramei <- data.frame(matrix(unlist(list(votematrixi)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primaryVoteMeansi<-colMeans(primaryVoteFramei) ## Vote Mean for each in nSims#
primaryVoteMeansi#
overallPrimaryMean<-rowMeans(primaryVoteMeansi)
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-10 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
votematrixi<-matrix(nrow=(0), ncol=(0))#
habitmatrixi<-matrix(nrow=(0), ncol=(0))#
#
for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
#
## This section is for inner J loop only #
##Primary Election Data for j Periods#
primaryVoteFramej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primaryVoteSumsj<- colSums(primaryVoteFramej) ## Participation in Primary#
primaryVoteMeansj<- colMeans(primaryVoteFramej) ## Participation Rate#
## primaryVoteMeansj#
nPeriodthPrimaryMeanj<-primaryVoteMeansj[7]#
nPeriodthPrimaryMeanj#
#
primaryIndVotesj<-rowSums(primaryVoteFramej) ## Individual Participation by number of votes#
primaryIndParticipationj<-table(primaryIndVotesj) ## Summary of number of times respondents voted (mode)#
primaryIndParticipationj#
## barplot(primaryIndParticipationj, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
electionsj<-c(1:nPeriods)#
## meanparticipationj<-(voteRts+voteDts)/2 ## For each of nPeriods#
#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## Voting rate for last election only#
#
##Habitual Voting Behavior#
primaryHabitualj<-(((primaryIndParticipationj["0"])+(primaryIndParticipationj["7"]))/n) ## For consistent voters and abstainers#
primaryHabitualj#
#
## Plots#
## par(mfrow=c(2,2))#
## barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
## plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes", col="Red")#
##par(new=T)#
## plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes", col="Blue")#
##par(new=F)#
#
sum(actions)#
primaryVoteSumsj[7]#
#
votematrixi<- list(votematrixi, actions)#
habitmatrixi<- list(habitmatrixi, primaryHabitualj)#
#
}#
#
primaryVoteFramei <- data.frame(matrix(unlist(list(votematrixi)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primaryVoteMeansi<-colMeans(primaryVoteFramei) ## Vote Mean for each in nSims#
primaryVoteMeansi#
overallPrimaryMean<-Mean(primaryVoteMeansi)
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-10 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
votematrixi<-matrix(nrow=(0), ncol=(0))#
habitmatrixi<-matrix(nrow=(0), ncol=(0))#
#
for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
#
## This section is for inner J loop only #
##Primary Election Data for j Periods#
primaryVoteFramej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primaryVoteSumsj<- colSums(primaryVoteFramej) ## Participation in Primary#
primaryVoteMeansj<- colMeans(primaryVoteFramej) ## Participation Rate#
## primaryVoteMeansj#
nPeriodthPrimaryMeanj<-primaryVoteMeansj[7]#
nPeriodthPrimaryMeanj#
#
primaryIndVotesj<-rowSums(primaryVoteFramej) ## Individual Participation by number of votes#
primaryIndParticipationj<-table(primaryIndVotesj) ## Summary of number of times respondents voted (mode)#
primaryIndParticipationj#
## barplot(primaryIndParticipationj, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
electionsj<-c(1:nPeriods)#
## meanparticipationj<-(voteRts+voteDts)/2 ## For each of nPeriods#
#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## Voting rate for last election only#
#
##Habitual Voting Behavior#
primaryHabitualj<-(((primaryIndParticipationj["0"])+(primaryIndParticipationj["7"]))/n) ## For consistent voters and abstainers#
primaryHabitualj#
#
## Plots#
## par(mfrow=c(2,2))#
## barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
## plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes", col="Red")#
##par(new=T)#
## plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes", col="Blue")#
##par(new=F)#
#
sum(actions)#
primaryVoteSumsj[7]#
#
votematrixi<- list(votematrixi, actions)#
habitmatrixi<- list(habitmatrixi, primaryHabitualj)#
#
}#
#
primaryVoteFramei <- data.frame(matrix(unlist(list(votematrixi)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primaryVoteMeansi<-colMeans(primaryVoteFramei) ## Vote Mean for each in nSims#
primaryVoteMeansi#
overallPrimaryMean<-mean(primaryVoteMeansi)
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-10 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
votematrixi<-matrix(nrow=(0), ncol=(0))#
habitmatrixi<-matrix(nrow=(0), ncol=(0))#
#
for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
#
## This section is for inner J loop only #
##Primary Election Data for j Periods#
primaryVoteFramej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primaryVoteSumsj<- colSums(primaryVoteFramej) ## Participation in Primary#
primaryVoteMeansj<- colMeans(primaryVoteFramej) ## Participation Rate#
## primaryVoteMeansj#
nPeriodthPrimaryMeanj<-primaryVoteMeansj[7]#
nPeriodthPrimaryMeanj#
#
primaryIndVotesj<-rowSums(primaryVoteFramej) ## Individual Participation by number of votes#
primaryIndParticipationj<-table(primaryIndVotesj) ## Summary of number of times respondents voted (mode)#
primaryIndParticipationj#
## barplot(primaryIndParticipationj, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
electionsj<-c(1:nPeriods)#
## meanparticipationj<-(voteRts+voteDts)/2 ## For each of nPeriods#
#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## Voting rate for last election only#
#
##Habitual Voting Behavior#
primaryHabitualj<-(((primaryIndParticipationj["0"])+(primaryIndParticipationj["7"]))/n) ## For consistent voters and abstainers#
primaryHabitualj#
#
## Plots#
## par(mfrow=c(2,2))#
## barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
## plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes", col="Red")#
##par(new=T)#
## plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes", col="Blue")#
##par(new=F)#
#
sum(actions)#
primaryVoteSumsj[7]#
#
votematrixi<- list(votematrixi, actions)#
habitmatrixi<- list(habitmatrixi, primaryHabitualj)#
#
}#
#
primaryVoteFramei <- data.frame(matrix(unlist(list(votematrixi)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primaryVoteMeansi<-colMeans(primaryVoteFramei) ## Vote Mean for each in nSims#
primaryVoteMeansi#
overallPrimaryMean<-mean(primaryVoteMeansi)#
overallPrimaryMean
votematrixi
actions
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-10 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
votematrixi<-matrix(nrow=(0), ncol=(0))#
habitmatrixi<-matrix(nrow=(0), ncol=(0))#
#
for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
#
## This section is for inner J loop only #
##Primary Election Data for j Periods#
primaryVoteFramej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primaryVoteSumsj<- colSums(primaryVoteFramej) ## Participation in Primary#
primaryVoteMeansj<- colMeans(primaryVoteFramej) ## Participation Rate#
## primaryVoteMeansj#
nPeriodthPrimaryMeanj<-primaryVoteMeansj[7]#
nPeriodthPrimaryMeanj#
#
primaryIndVotesj<-rowSums(primaryVoteFramej) ## Individual Participation by number of votes#
primaryIndParticipationj<-table(primaryIndVotesj) ## Summary of number of times respondents voted (mode)#
primaryIndParticipationj#
## barplot(primaryIndParticipationj, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
electionsj<-c(1:nPeriods)#
## meanparticipationj<-(voteRts+voteDts)/2 ## For each of nPeriods#
#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## Voting rate for last election only#
#
##Habitual Voting Behavior#
primaryHabitualj<-(((primaryIndParticipationj["0"])+(primaryIndParticipationj["7"]))/n) ## For consistent voters and abstainers#
primaryHabitualj#
#
## Plots#
## par(mfrow=c(2,2))#
## barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
## plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes", col="Red")#
##par(new=T)#
## plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes", col="Blue")#
##par(new=F)#
#
sum(actions)#
primaryVoteSumsj[7]#
#
votematrixi<- list(votematrixi, actions)#
habitmatrixi<- list(habitmatrixi, primaryHabitualj)#
#
}#
#
primaryVoteFramei <- data.frame(matrix(unlist(list(votematrixi)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primaryVoteMeansi<-colMeans(primaryVoteFramei) ## Vote Mean for each in nSims#
primaryVoteMeansi#
overallPrimaryMean<-mean(primaryVoteMeansi) ## Mean for nPeriodth in nSims#
overallPrimaryMean
habitmatrixi
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-10 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
votematrixi<-matrix(nrow=(0), ncol=(0))#
habitmatrixi<-matrix(nrow=(0), ncol=(0))#
#
for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
#
## This section is for inner J loop only #
##Primary Election Data for j Periods#
primaryVoteFramej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primaryVoteSumsj<- colSums(primaryVoteFramej) ## Participation in Primary#
primaryVoteMeansj<- colMeans(primaryVoteFramej) ## Participation Rate#
## primaryVoteMeansj#
nPeriodthPrimaryMeanj<-primaryVoteMeansj[7]#
nPeriodthPrimaryMeanj#
#
primaryIndVotesj<-rowSums(primaryVoteFramej) ## Individual Participation by number of votes#
primaryIndParticipationj<-table(primaryIndVotesj) ## Summary of number of times respondents voted (mode)#
primaryIndParticipationj#
## barplot(primaryIndParticipationj, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
electionsj<-c(1:nPeriods)#
## meanparticipationj<-(voteRts+voteDts)/2 ## For each of nPeriods#
#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## Voting rate for last election only#
#
##Habitual Voting Behavior#
primaryHabitualj<-(((primaryIndParticipationj["0"])+(primaryIndParticipationj["7"]))/n) ## For consistent voters and abstainers#
primaryHabitualj#
#
## Plots#
## par(mfrow=c(2,2))#
## barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
## plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes", col="Red")#
##par(new=T)#
## plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes", col="Blue")#
##par(new=F)#
#
sum(actions)#
primaryVoteSumsj[7]#
#
votematrixi<- list(votematrixi, actions)#
habitmatrixi<- list(habitmatrixi, primaryHabitualj)#
#
}#
#
primaryVoteFramei <- data.frame(matrix(unlist(list(votematrixi)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primaryVoteMeansi<-colMeans(primaryVoteFramei) ## Vote Mean for each in nSims#
primaryVoteMeansi#
overallPrimaryMean<-mean(primaryVoteMeansi) ## Mean for nPeriodth in nSims#
overallPrimaryMean#
#
primaryHabitFramei <- data.frame(matrix(unlist(list(habitmatrixi)), nrow=nSims, byrow=FALSE))  ## Extracts data from matrix
primaryHabitFramei
colMeans(primaryHabitFramei)
ls()
load("/Users/jg/Dropbox/Active USF/698 Genetics/Genetic Research/FowlerRworkspace")
ls()
actions
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-10 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
votematrixi<-matrix(nrow=(0), ncol=(0))#
habitmatrixi<-matrix(nrow=(0), ncol=(0))#
#
for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
#
## This section is for inner J loop only #
##Primary Election Data for j Periods#
primaryVoteFramej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primaryVoteSumsj<- colSums(primaryVoteFramej) ## Participation in Primary#
primaryVoteMeansj<- colMeans(primaryVoteFramej) ## Participation Rate#
## primaryVoteMeansj#
nPeriodthPrimaryMeanj<-primaryVoteMeansj[7]#
nPeriodthPrimaryMeanj#
#
primaryIndVotesj<-rowSums(primaryVoteFramej) ## Individual Participation by number of votes#
primaryIndParticipationj<-table(primaryIndVotesj) ## Summary of number of times respondents voted (mode)#
primaryIndParticipationj#
## barplot(primaryIndParticipationj, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
electionsj<-c(1:nPeriods)#
## meanparticipationj<-(voteRts+voteDts)/2 ## For each of nPeriods#
#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## Voting rate for last election only#
#
##Habitual Voting Behavior#
primaryHabitualj<-(((primaryIndParticipationj["0"])+(primaryIndParticipationj["7"]))/n) ## For consistent voters and abstainers#
primaryHabitualj#
#
## Plots#
## par(mfrow=c(2,2))#
## barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
## plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes", col="Red")#
##par(new=T)#
## plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes", col="Blue")#
##par(new=F)#
#
sum(actions)#
primaryVoteSumsj[7]#
#
votematrixi<- list(votematrixi, actions)#
habitmatrixi<- list(habitmatrixi, primaryHabitualj)#
#
}#
#
primaryVoteFramei <- data.frame(matrix(unlist(list(votematrixi)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primaryVoteMeansi<-colMeans(primaryVoteFramei) ## Vote Mean for each in nSims#
primaryVoteMeansi#
overallPrimaryMean<-mean(primaryVoteMeansi) ## Mean for nPeriodth in nSims#
overallPrimaryMean#
#
primaryHabitFramei <- data.frame(matrix(unlist(list(habitmatrixi)), nrow=nSims, byrow=FALSE))  ## Extracts data from matrix#
overallPrimaryHabitBehavior<- colMeans(primaryHabitFramei) ## Habitual Behavior for nPeriodth in nSims#
overallPrimaryHabitBehavior
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-10 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
votematrixi<-matrix(nrow=(0), ncol=(0))#
habitmatrixi<-matrix(nrow=(0), ncol=(0))#
#
for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
#
## This section is for inner J loop only #
##Primary Election Data for j Periods#
primaryVoteFramej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primaryVoteSumsj<- colSums(primaryVoteFramej) ## Participation in Primary#
primaryVoteMeansj<- colMeans(primaryVoteFramej) ## Participation Rate#
## primaryVoteMeansj#
nPeriodthPrimaryMeanj<-primaryVoteMeansj[7]#
nPeriodthPrimaryMeanj#
#
primaryIndVotesj<-rowSums(primaryVoteFramej) ## Individual Participation by number of votes#
primaryIndParticipationj<-table(primaryIndVotesj) ## Summary of number of times respondents voted (mode)#
primaryIndParticipationj#
## barplot(primaryIndParticipationj, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
electionsj<-c(1:nPeriods)#
## meanparticipationj<-(voteRts+voteDts)/2 ## For each of nPeriods#
#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## Voting rate for last election only#
#
##Habitual Voting Behavior#
primaryHabitualj<-(((primaryIndParticipationj["0"])+(primaryIndParticipationj["7"]))/n) ## For consistent voters and abstainers#
primaryHabitualj#
#
## Plots#
 par(mfrow=c(2,2))#
 barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
 plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes", col="Red")#
##par(new=T)#
 plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes", col="Blue")#
##par(new=F)#
#
sum(actions)#
primaryVoteSumsj[7]#
#
votematrixi<- list(votematrixi, actions)#
habitmatrixi<- list(habitmatrixi, primaryHabitualj)#
#
}#
#
primaryVoteFramei <- data.frame(matrix(unlist(list(votematrixi)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primaryVoteMeansi<-colMeans(primaryVoteFramei) ## Vote Mean for each in nSims#
primaryVoteMeansi#
overallPrimaryMean<-mean(primaryVoteMeansi) ## Mean for nPeriodth in nSims#
overallPrimaryMean#
#
primaryHabitFramei <- data.frame(matrix(unlist(list(habitmatrixi)), nrow=nSims, byrow=FALSE))  ## Extracts data from matrix#
overallPrimaryHabitBehavior<- colMeans(primaryHabitFramei) ## Habitual Behavior for nPeriodth in nSims#
overallPrimaryHabitBehavior
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-10 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
votematrixi<-matrix(nrow=(0), ncol=(0))#
habitmatrixi<-matrix(nrow=(0), ncol=(0))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
#
## This section is for inner J loop only #
##Primary Election Data for j Periods#
primaryVoteFramej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primaryVoteSumsj<- colSums(primaryVoteFramej) ## Participation in Primary#
primaryVoteMeansj<- colMeans(primaryVoteFramej) ## Participation Rate#
## primaryVoteMeansj#
nPeriodthPrimaryMeanj<-primaryVoteMeansj[7]#
nPeriodthPrimaryMeanj#
#
primaryIndVotesj<-rowSums(primaryVoteFramej) ## Individual Participation by number of votes#
primaryIndParticipationj<-table(primaryIndVotesj) ## Summary of number of times respondents voted (mode)#
primaryIndParticipationj#
## barplot(primaryIndParticipationj, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
electionsj<-c(1:nPeriods)#
## meanparticipationj<-(voteRts+voteDts)/2 ## For each of nPeriods#
#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## Voting rate for last election only#
#
##Habitual Voting Behavior#
primaryHabitualj<-(((primaryIndParticipationj["0"])+(primaryIndParticipationj["7"]))/n) ## For consistent voters and abstainers#
primaryHabitualj#
#
## Plots#
 par(mfrow=c(2,2))#
 barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
 plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes", col="Red")#
##par(new=T)#
 plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes", col="Blue")#
##par(new=F)#
#
sum(actions)#
primaryVoteSumsj[7]#
#
votematrixi<- list(votematrixi, actions)#
habitmatrixi<- list(habitmatrixi, primaryHabitualj)#
#
##}#
#
primaryVoteFramei <- data.frame(matrix(unlist(list(votematrixi)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primaryVoteMeansi<-colMeans(primaryVoteFramei) ## Vote Mean for each in nSims#
primaryVoteMeansi#
overallPrimaryMean<-mean(primaryVoteMeansi) ## Mean for nPeriodth in nSims#
overallPrimaryMean#
#
primaryHabitFramei <- data.frame(matrix(unlist(list(habitmatrixi)), nrow=nSims, byrow=FALSE))  ## Extracts data from matrix#
overallPrimaryHabitBehavior<- colMeans(primaryHabitFramei) ## Habitual Behavior for nPeriodth in nSims#
overallPrimaryHabitBehavior
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-10 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
votematrixi<-matrix(nrow=(0), ncol=(0))#
habitmatrixi<-matrix(nrow=(0), ncol=(0))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
#
## This section is for inner J loop only #
##Primary Election Data for j Periods#
primaryVoteFramej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primaryVoteSumsj<- colSums(primaryVoteFramej) ## Participation in Primary#
primaryVoteMeansj<- colMeans(primaryVoteFramej) ## Participation Rate#
## primaryVoteMeansj#
nPeriodthPrimaryMeanj<-primaryVoteMeansj[7]#
nPeriodthPrimaryMeanj#
#
primaryIndVotesj<-rowSums(primaryVoteFramej) ## Individual Participation by number of votes#
primaryIndParticipationj<-table(primaryIndVotesj) ## Summary of number of times respondents voted (mode)#
primaryIndParticipationj#
## barplot(primaryIndParticipationj, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
electionsj<-c(1:nPeriods)#
## meanparticipationj<-(voteRts+voteDts)/2 ## For each of nPeriods#
#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## Voting rate for last election only#
#
##Habitual Voting Behavior#
primaryHabitualj<-(((primaryIndParticipationj["0"])+(primaryIndParticipationj["7"]))/n) ## For consistent voters and abstainers#
primaryHabitualj#
#
## Plots#
 par(mfrow=c(2,2))#
 barplot(primaryIndParticipationj, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
 plot(electionsj, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes", col="Red")#
##par(new=T)#
 plot(electionsj, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes", col="Blue")#
##par(new=F)#
#
sum(actions)#
primaryVoteSumsj[7]#
#
votematrixi<- list(votematrixi, actions)#
habitmatrixi<- list(habitmatrixi, primaryHabitualj)#
#
##}#
#
primaryVoteFramei <- data.frame(matrix(unlist(list(votematrixi)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primaryVoteMeansi<-colMeans(primaryVoteFramei) ## Vote Mean for each in nSims#
primaryVoteMeansi#
overallPrimaryMean<-mean(primaryVoteMeansi) ## Mean for nPeriodth in nSims#
overallPrimaryMean#
#
primaryHabitFramei <- data.frame(matrix(unlist(list(habitmatrixi)), nrow=nSims, byrow=FALSE))  ## Extracts data from matrix#
overallPrimaryHabitBehavior<- colMeans(primaryHabitFramei) ## Habitual Behavior for nPeriodth in nSims#
overallPrimaryHabitBehavior
library(ggplot2)#
library(scales)#
#
##data(economics)#
##View(economics)#
#
scatterplot <- ggplot(economics,#
	aes(x=date, y= psavert)) +#
	geop_point() +#
	ggtitle("US Economic Time Series") +#
	xlab("Year") +#
	ylab("Personal Savings Rate")
library(ggplot2)#
library(scales)#
#
##data(economics)#
##View(economics)#
#
scatterplot <- ggplot(economics,#
	aes(x=date, y= psavert)) +#
	geom_point() +#
	ggtitle("US Economic Time Series") +#
	xlab("Year") +#
	ylab("Personal Savings Rate")
scatterplot
library(ggplot2)#
library(scales)#
#
##data(economics)#
##View(economics)#
#
scatterplot <- ggplot(economics,#
	aes(x=date, y= psavert)) +#
	geom_line() +#
	ggtitle("US Economic Time Series") +#
	xlab("Year") +#
	ylab("Personal Savings Rate")#
#
scatterplot
print(scatterplot)
library(ggplot2)#
library(scales)#
#
##data(economics)#
##View(economics)#
#
scatterplot <- ggplot(economics, aes(x=date, y= psavert)) + ##base#
	geom_line() +#
	ggtitle("US Economic Time Series") +#
	xlab("Year") +#
	ylab("Personal Savings Rate")#
#
print(scatterplot)#
#
help(geom_line)
scatterplot <- ggplot(economics, aes(x=date, y= psavert)) + ##base#
	geom_area() +#
	ggtitle("US Economic Time Series") +#
	xlab("Year") +#
	ylab("Personal Savings Rate")#
#
print(scatterplot)
library(ggplot2)#
library(scales)#
#
##data(economics)#
##View(economics)#
#
economics$year <- + as.POSIXlt(economics$date)$year#
economics$month <- + as.POSIXlt(economics$date)$mon#
#
p <- ggplot(subset(economics, year >= 2003), aes(x=date, y= psavert)) + ##base#
	geom_bar(stat="identity") +#
	ylim(-5,5)#
	ggtitle("US Economic Time Series") +#
	xlab("Year") +#
	ylab("Personal Savings Rate")#
print(p)#
#
##help(geom_line)
library(ggplot2)#
library(scales)#
#
##data(economics)#
##View(economics)#
#
economics$year <- + as.POSIXlt(economics$date)$year#
economics$month <- + as.POSIXlt(economics$date)$mon#
#
p <- ggplot(subset(economics, year >= 2003), aes(x=date, y= psavert)) + ##base#
	geom_bar(stat="identity") +#
	ylim(-5,5) +#
	ggtitle("US Economic Time Series") +#
	xlab("Year") +#
	ylab("Personal Savings Rate")#
print(p)#
#
##help(geom_line)
library(ggplot2)#
library(scales)#
#
##data(economics)#
##View(economics)#
#
economics$year <- 1900 + as.POSIXlt(economics$date)$year#
economics$mon <- 1 + as.POSIXlt(economics$date)$mon#
#
p <- ggplot(subset(economics, year >= 2003), aes(x=date, y= psavert)) + ##base#
	geom_bar(stat="identity") +#
	ylim(-5,5) +#
	ggtitle("US Economic Time Series") +#
	xlab("Year") +#
	ylab("Personal Savings Rate")#
print(p)#
#
##help(geom_line)
library(ggplot2)#
library(scales)#
#
##data(economics)#
##View(economics)#
#
economics$year <- 1900 + as.POSIXlt(economics$date)$year#
economics$mon <- 1 + as.POSIXlt(economics$date)$mon#
#
p <- ggplot(subset(economics, year <= 1990),#
	aes(x=factor(year), y= psavert)) + ##base#
	geom_bar(stat="identity") +#
	ylim(-5,5) +#
	ggtitle("US Economic Time Series") +#
	xlab("Year") +#
	ylab("Personal Savings Rate")#
#
print(p)#
#
##help(geom_line)
library(ggplot2)#
library(scales)#
#
##data(economics)#
##View(economics)#
#
economics$year <- 1900 + as.POSIXlt(economics$date)$year#
economics$mon <- 1 + as.POSIXlt(economics$date)$mon#
#
p <- ggplot(subset(economics, year <= 1990),#
	aes(x=factor(year), y= psavert)) + ##base#
	geom_boxplot() +#
	ylim(-5,5) +#
	ggtitle("US Economic Time Series") +#
	xlab("Year") +#
	ylab("Personal Savings Rate")#
#
print(p)#
#
##help(geom_line)
library(ggplot2)#
library(scales)#
#
##data(economics)#
##View(economics)#
#
economics$year <- 1900 + as.POSIXlt(economics$date)$year ##posix is date object#
economics$month <- 1 + as.POSIXlt(economics$date)$mon#
#
p <- ggplot(subset(economics, year <= 1990),#
	aes(x=factor(year), y= psavert)) + ##base#
	geom_bar(stat="identity") +#
	ylim(-5,5) +#
	ggtitle("US Economic Time Series") +#
	xlab("Year") +#
	ylab("Personal Savings Rate")#
#
print(p)#
#
##help(geom_line)
library(ggplot2)#
library(scales)#
#
##data(economics)#
##View(economics)#
#
economics$year <- 1900 + as.POSIXlt(economics$date)$year ##posix is date object#
economics$month <- 1 + as.POSIXlt(economics$date)$mon#
#
p <- ggplot(subset(economics, year %in% seq(1970, 2010, 5)),#
	aes(x=factor(year), y= psavert)) + ##base#
	geom_line(stat="identity") +#
	ylim(-5,5) +#
	ggtitle("US Economic Time Series") +#
	xlab("Year") +#
	ylab("Personal Savings Rate")#
#
print(p)#
#
##help(geom_line)
library(ggplot2)#
library(scales)#
#
##data(economics)#
##View(economics)#
#
economics$year <- 1900 + as.POSIXlt(economics$date)$year ##posix is date object#
economics$month <- 1 + as.POSIXlt(economics$date)$mon#
#
p <- ggplot(subset(economics, year %in% seq(1970, 2010, 5)),#
	aes(x=factor(month), y= psavert)) + ##base#
	geom_line() +#
	ylim(-5,5) +#
	ggtitle("US Economic Time Series") +#
	xlab("Year") +#
	ylab("Personal Savings Rate")#
#
print(p)#
#
##help(geom_line)
library(ggplot2)#
library(scales)#
#
##data(economics)#
##View(economics)#
#
economics$year <- 1900 + as.POSIXlt(economics$date)$year ##posix is date object#
economics$month <- 1 + as.POSIXlt(economics$date)$mon#
#
p <- ggplot(subset(economics, year %in% seq(1970, 2010, 5)),#
	aes(x=month, y= psavert)) + ##base#
	geom_line() +#
	ylim(-5,5) +#
	ggtitle("US Economic Time Series") +#
	xlab("Year") +#
	ylab("Personal Savings Rate")#
#
print(p)#
#
##help(geom_line)
library(ggplot2)#
library(scales)#
#
##data(economics)#
##View(economics)#
#
economics$year <- 1900 + as.POSIXlt(economics$date)$year ##posix is date object#
economics$month <- 1 + as.POSIXlt(economics$date)$mon#
#
d<-subset(economics, year %in% seq(1970, 2010, 5))#
#
p <- ggplot(d, #
	aes(x=month, y= psavert, #
	group = factor(year),#
	color = factor(year))) + ##base#
	geom_line() +#
	ylim(-5,5) +#
	ggtitle("US Economic Time Series") +#
	xlab("Year") +#
	ylab("Personal Savings Rate")#
#
print(p)#
#
##help(geom_line)
library(ggplot2)#
library(scales)#
#
##data(economics)#
##View(economics)#
#
economics$year <- 1900 + as.POSIXlt(economics$date)$year ##posix is date object#
economics$month <- 1 + as.POSIXlt(economics$date)$mon#
#
d<-subset(economics, year %in% seq(1970, 2010, 5))#
#
p <- ggplot(d, #
	aes(x=month, y= psavert, #
	group = factor(year),#
	color = factor(year))) + ##base#
	geom_line() +#
	ylim(-2,15) +#
	ggtitle("US Economic Time Series") +#
	xlab("Year") +#
	ylab("Personal Savings Rate")#
#
print(p)#
#
##help(geom_line)
library(ggplot2)#
library(scales)#
#
##data(economics)#
##View(economics)#
#
economics$year <- 1900 + as.POSIXlt(economics$date)$year ##posix is date object#
economics$month <- 1 + as.POSIXlt(economics$date)$mon#
#
d<-subset(economics, year %in% seq(1970, 2010, 5))#
#
p <- ggplot(d, #
	aes(x=month, y= psavert, #
	group = factor(year),#
	color = factor(year))) + ##base#
	geom_line() +#
	ylim(-5,15) +#
	ggtitle("US Economic Time Series") +#
	xlab("Year") +#
	ylab("Personal Savings Rate")#
#
print(p)#
#
##help(geom_line)
library(ggplot2)#
library(scales)#
#
##data(economics)#
##View(economics)#
#
economics$year <- 1900 + as.POSIXlt(economics$date)$year ##posix is date object#
economics$month <- 1 + as.POSIXlt(economics$date)$mon#
monthtext<- c("Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec")#
#
d<-subset(economics, year %in% seq(1970, 2010, 5))#
#
p <- ggplot(d, #
	aes(x=month, y= psavert, #
	group = factor(year),#
	color = factor(year))) + ##base#
	geom_line() +#
	ylim(-5,15) +#
	ggtitle("US Economic Time Series") +#
	xlab("Year") +#
	ylab("Personal Savings Rate")#
	scale_x_discrete(labels = monthtext)#
print(p)#
#
##help(geom_line)
library(ggplot2)#
library(scales)#
#
##data(economics)#
##View(economics)#
#
economics$year <- 1900 + as.POSIXlt(economics$date)$year ##posix is date object#
economics$month <- 1 + as.POSIXlt(economics$date)$mon#
monthtext<- c("Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec")#
#
d<-subset(economics, year %in% seq(1970, 2010, 5))#
#
p <- ggplot(d, #
	aes(x=month, y= psavert, #
	group = factor(year),#
	color = factor(year))) + ##base#
	geom_line() +#
	ylim(-5,15) +#
	ggtitle("US Economic Time Series") +#
	xlab("Year") +#
	ylab("Personal Savings Rate") +#
	scale_x_discrete(labels = monthtext) +#
	facet_wrap( ~year, ncol=3)#
#
print(p)#
#
##help(geom_line)
library(ggplot2)#
data(movies)#
data(EuStockMarkets)
movies
MSAN 622#
## Jeremy Gilmore#
## Homework 1#
#
library(ggplot2)#
data(movies)#
data(EuStockMarkets)#
#
## modify data: movies#
movies=movies[!(movies$budget<="0"),]#
genre <- rep(NA, nrow(movies))#
count <- rowSums(movies[, 18:24])#
genre[which(count > 1)] = "Mixed"#
genre[which(count < 1)] = "None"#
genre[which(count == 1 & movies$Action == 1)] = "Action"#
genre[which(count == 1 & movies$Animation == 1)] = "Animation"#
genre[which(count == 1 & movies$Comedy == 1)] = "Comedy"#
genre[which(count == 1 & movies$Drama == 1)] = "Drama"#
genre[which(count == 1 & movies$Documentary == 1)] = "Documentary"#
genre[which(count == 1 & movies$Romance == 1)] = "Romance"#
genre[which(count == 1 & movies$Short == 1)] = "Short"#
#
## modify data: EuStockMarkets#
eu <- transform(data.frame(EuStockMarkets), time = time(EuStockMarkets))
movies
MSAN 622#
## Jeremy Gilmore#
## Homework 1#
#
library(ggplot2)#
data(movies)#
data(EuStockMarkets)#
#
## modify data: movies#
movies=movies[(movies$budget<="0"),]#
##subset(dataframe, )#
genre <- rep(NA, nrow(movies))#
count <- rowSums(movies[, 18:24])#
genre[which(count > 1)] = "Mixed"#
genre[which(count < 1)] = "None"#
genre[which(count == 1 & movies$Action == 1)] = "Action"#
genre[which(count == 1 & movies$Animation == 1)] = "Animation"#
genre[which(count == 1 & movies$Comedy == 1)] = "Comedy"#
genre[which(count == 1 & movies$Drama == 1)] = "Drama"#
genre[which(count == 1 & movies$Documentary == 1)] = "Documentary"#
genre[which(count == 1 & movies$Romance == 1)] = "Romance"#
genre[which(count == 1 & movies$Short == 1)] = "Short"#
#
## modify data: EuStockMarkets#
eu <- transform(data.frame(EuStockMarkets), time = time(EuStockMarkets))
movies
MSAN 622#
## Jeremy Gilmore#
## Homework 1#
#
library(ggplot2)#
data(movies)#
data(EuStockMarkets)#
#
## modify data: movies#
movies=movies[!(movies$budget<=0),]#
##subset(dataframe, )#
genre <- rep(NA, nrow(movies))#
count <- rowSums(movies[, 18:24])#
genre[which(count > 1)] = "Mixed"#
genre[which(count < 1)] = "None"#
genre[which(count == 1 & movies$Action == 1)] = "Action"#
genre[which(count == 1 & movies$Animation == 1)] = "Animation"#
genre[which(count == 1 & movies$Comedy == 1)] = "Comedy"#
genre[which(count == 1 & movies$Drama == 1)] = "Drama"#
genre[which(count == 1 & movies$Documentary == 1)] = "Documentary"#
genre[which(count == 1 & movies$Romance == 1)] = "Romance"#
genre[which(count == 1 & movies$Short == 1)] = "Short"#
#
## modify data: EuStockMarkets#
eu <- transform(data.frame(EuStockMarkets), time = time(EuStockMarkets))
movies
library(ggplot2)#
data(movies)#
data(EuStockMarkets)
movies
movies=movies[!(movies$budget<=0 | movies$budget=="NA"),]
movies
MSAN 622#
## Jeremy Gilmore#
## Homework 1#
#
library(ggplot2)#
data(movies)#
data(EuStockMarkets)#
#
## modify data: movies#
movies=movies[(movies$budget>0),]#
##subset(dataframe, )#
genre <- rep(NA, nrow(movies))#
count <- rowSums(movies[, 18:24])#
genre[which(count > 1)] = "Mixed"#
genre[which(count < 1)] = "None"#
genre[which(count == 1 & movies$Action == 1)] = "Action"#
genre[which(count == 1 & movies$Animation == 1)] = "Animation"#
genre[which(count == 1 & movies$Comedy == 1)] = "Comedy"#
genre[which(count == 1 & movies$Drama == 1)] = "Drama"#
genre[which(count == 1 & movies$Documentary == 1)] = "Documentary"#
genre[which(count == 1 & movies$Romance == 1)] = "Romance"#
genre[which(count == 1 & movies$Short == 1)] = "Short"#
#
## modify data: EuStockMarkets#
eu <- transform(data.frame(EuStockMarkets), time = time(EuStockMarkets))
movies
library(ggplot2)#
data(movies)#
data(EuStockMarkets)
budget
movies$budget
MSAN 622#
## Jeremy Gilmore#
## Homework 1#
#
library(ggplot2)#
data(movies)#
data(EuStockMarkets)#
#
## modify data: movies#
##movies=movies[(movies$budget>0),]#
##subset(dataframe, )#
genre <- rep(NA, nrow(movies))#
count <- rowSums(movies[, 18:24])#
genre[which(count > 1)] = "Mixed"#
genre[which(count < 1)] = "None"#
genre[which(count == 1 & movies$Action == 1)] = "Action"#
genre[which(count == 1 & movies$Animation == 1)] = "Animation"#
genre[which(count == 1 & movies$Comedy == 1)] = "Comedy"#
genre[which(count == 1 & movies$Drama == 1)] = "Drama"#
genre[which(count == 1 & movies$Documentary == 1)] = "Documentary"#
genre[which(count == 1 & movies$Romance == 1)] = "Romance"#
genre[which(count == 1 & movies$Short == 1)] = "Short"#
#
## modify data: EuStockMarkets#
eu <- transform(data.frame(EuStockMarkets), time = time(EuStockMarkets))
budget
library(ggplot2)#
library(shiny)#
#
data("movies", package = "ggplot2")#
#
start <- which(colnames(movies) == "Action")#
#
end <- which (colnames(movies) == "Short")#
#
genres <- colnames(movies)[start:end]#
#
counts <- rep(0, lengeth(genres))#
#
for(i in 1:length(genres)) {#
	counts[i] <- sum(movies[, genres[i]])#
}#
#
df <- data.frame(factor(genres), counts)#
colnames(df) <- c("Genres", "Counts")#
#
p <- ggplot(df, aes(x = Genres, y = Counts, fill = Genres))#
#
p <- p + geom_bar(stat="identity")#
#
print(p)
library(ggplot2)#
library(shiny)#
#
data("movies", package = "ggplot2")#
#
start <- which(colnames(movies) == "Action")#
#
end <- which (colnames(movies) == "Short")#
#
genres <- colnames(movies)[start:end]#
#
counts <- rep(0, length(genres))#
#
for(i in 1:length(genres)) {#
	counts[i] <- sum(movies[, genres[i]])#
}#
#
df <- data.frame(factor(genres), counts)#
colnames(df) <- c("Genres", "Counts")#
#
p <- ggplot(df, aes(x = Genres, y = Counts, fill = Genres))#
#
p <- p + geom_bar(stat="identity")#
#
print(p)
library(ggplot2)#
library(shiny)#
#
data("movies", package = "ggplot2")#
#
start <- which(colnames(movies) == "Action")#
#
end <- which (colnames(movies) == "Short")#
#
genres <- colnames(movies)[start:end]#
#
counts <- rep(0, length(genres))#
#
for(i in 1:length(genres)) {#
	counts[i] <- sum(movies[, genres[i]])#
}#
#
df <- data.frame(factor(genres), counts)#
colnames(df) <- c("Genres", "Counts")#
#
## How to Sort by Bars#
sortOrder <- order(df$Counts, decreasing = FALSE)#
p <- ggplot(df, aes(x = Genres, y = Counts, fill = Genres))#
#
p <- p + geom_bar(stat="identity")#
#
print(p)
library(ggplot2)#
library(shiny)#
#
data("movies", package = "ggplot2")#
#
start <- which(colnames(movies) == "Action")#
#
end <- which (colnames(movies) == "Short")#
#
genres <- colnames(movies)[start:end]#
#
counts <- rep(0, length(genres))#
#
for(i in 1:length(genres)) {#
	counts[i] <- sum(movies[, genres[i]])#
}#
#
df <- data.frame(factor(genres), counts)#
colnames(df) <- c("Genres", "Counts")#
#
## How to Sort by Bars#
sortOrder <- order(df$Counts, decreasing = FALSE)#
df$Genres <- factor(df$Genres[sortOrder])#
#
p <- ggplot(df, aes(x = Genres, y = Counts, fill = Genres))#
#
p <- p + geom_bar(stat="identity")#
#
print(p)
library(ggplot2)#
library(shiny)#
#
data("movies", package = "ggplot2")#
#
start <- which(colnames(movies) == "Action")#
#
end <- which (colnames(movies) == "Short")#
#
genres <- colnames(movies)[start:end]#
#
counts <- rep(0, length(genres))#
#
for(i in 1:length(genres)) {#
	counts[i] <- sum(movies[, genres[i]])#
}#
#
df <- data.frame(factor(genres), counts)#
colnames(df) <- c("Genres", "Counts")#
#
## How to Sort by Bars#
sortOrder <- order(df$Counts, decreasing = FALSE)#
df$Genres <- factor(df$Genres, levels = df$Genres[sortOrder])#
#
p <- ggplot(df, aes(x = Genres, y = Counts, fill = Genres))#
#
p <- p + geom_bar(stat="identity")#
#
print(p)
library(ggplot2)#
library(shiny)#
#
data("movies", package = "ggplot2")#
#
start <- which(colnames(movies) == "Action")#
#
end <- which (colnames(movies) == "Short")#
#
genres <- colnames(movies)[start:end]#
#
counts <- rep(0, length(genres))#
#
for(i in 1:length(genres)) {#
	counts[i] <- sum(movies[, genres[i]])#
}#
#
df <- data.frame(factor(genres), counts)#
colnames(df) <- c("Genres", "Counts")#
#
## How to Sort by Bars#
sortOrder <- order(df$Counts, decreasing = FALSE)#
df$Genres <- factor(df$Genres, levels = df$Genres[sortOrder])#
#
p <- ggplot(df, aes(x = Genres, y = Counts, fill = Genres))#
#
p <- p + geom_bar(stat="identity")#
#
p <- p + xlab("Movie Genre")#
p <- p + ylab("Count in 1000s")#
p <- p + ggtitle("Movies by Genre")#
p <- p + labs(fill = "Movie Genres")#
#
thousand_formatter <- function(x) {#
	label <- x / 1000#
}#
#
p <- p + scale_y_continuous(#
	label = thousand_formatter#
	)#
#
print(p)
library(ggplot2)#
library(shiny)#
#
data("movies", package = "ggplot2")#
#
start <- which(colnames(movies) == "Action")#
#
end <- which (colnames(movies) == "Short")#
#
genres <- colnames(movies)[start:end]#
#
counts <- rep(0, length(genres))#
#
for(i in 1:length(genres)) {#
	counts[i] <- sum(movies[, genres[i]])#
}#
#
df <- data.frame(factor(genres), counts)#
colnames(df) <- c("Genres", "Counts")#
#
## How to Sort by Bars#
sortOrder <- order(df$Counts, decreasing = FALSE)#
df$Genres <- factor(df$Genres, levels = df$Genres[sortOrder])#
#
p <- ggplot(df, aes(x = Genres, y = Counts, fill = Genres))#
#
p <- p + geom_bar(stat="identity")#
#
p <- p + xlab("Movie Genre")#
p <- p + ylab("Count in 1000s")#
p <- p + ggtitle("Movies by Genre")#
p <- p + labs(fill = "Movie Genres")#
#
##thousand_formatter <- function(x) {#
##	label <- x / 1000#
##}#
#
thousand_formatter <- funciton(x) {#
	return(sprintf("%dk", round(x / 1000))) # d is digit, f would be floating#
}#
p <- p + scale_y_continuous(#
	label = thousand_formatter#
	)#
print(p)
library(ggplot2)#
library(shiny)#
#
data("movies", package = "ggplot2")#
#
start <- which(colnames(movies) == "Action")#
#
end <- which (colnames(movies) == "Short")#
#
genres <- colnames(movies)[start:end]#
#
counts <- rep(0, length(genres))#
#
for(i in 1:length(genres)) {#
	counts[i] <- sum(movies[, genres[i]])#
}#
#
df <- data.frame(factor(genres), counts)#
colnames(df) <- c("Genres", "Counts")#
#
## How to Sort by Bars#
sortOrder <- order(df$Counts, decreasing = FALSE)#
df$Genres <- factor(df$Genres, levels = df$Genres[sortOrder])#
#
p <- ggplot(df, aes(x = Genres, y = Counts, fill = Genres))#
#
p <- p + geom_bar(stat="identity")#
#
p <- p + xlab("Movie Genre")#
p <- p + ylab("Count in 1000s")#
p <- p + ggtitle("Movies by Genre")#
p <- p + labs(fill = "Movie Genres")#
#
##thousand_formatter <- function(x) {#
##	label <- x / 1000#
##}#
#
thousand_formatter <- function(x) {#
	return(sprintf("%dk", round(x / 1000))) # d is digit, f would be floating#
}#
p <- p + scale_y_continuous(#
	label = thousand_formatter#
	)#
print(p)
library(ggplot2)#
library(shiny)#
#
data("movies", package = "ggplot2")#
#
start <- which(colnames(movies) == "Action")#
#
end <- which (colnames(movies) == "Short")#
#
genres <- colnames(movies)[start:end]#
#
counts <- rep(0, length(genres))#
#
for(i in 1:length(genres)) {#
	counts[i] <- sum(movies[, genres[i]])#
}#
#
df <- data.frame(factor(genres), counts)#
colnames(df) <- c("Genres", "Counts")#
#
## How to Sort by Bars#
sortOrder <- order(df$Counts, decreasing = FALSE)#
df$Genres <- factor(df$Genres, levels = df$Genres[sortOrder])#
#
p <- ggplot(df, aes(x = Genres, y = Counts, fill = Genres))#
#
p <- p + geom_bar(stat="identity")#
#
p <- p + xlab("Movie Genre")#
p <- p + ylab("Count in 1000s")#
p <- p + ggtitle("Movies by Genre")#
p <- p + labs(fill = "Movie Genres")#
#
##thousand_formatter <- function(x) {#
##	label <- x / 1000#
##}#
#
thousand_formatter <- function(x) {#
	return(sprintf("%dk", round(x / 1000))) # d is digit, f would be floating#
}#
p <- p + scale_y_continuous(#
	expand = c(0,500),#
	label = thousand_formatter#
	)#
print(p)
library(ggplot2)#
library(shiny)#
#
data("movies", package = "ggplot2")#
#
start <- which(colnames(movies) == "Action")#
#
end <- which (colnames(movies) == "Short")#
#
genres <- colnames(movies)[start:end]#
#
counts <- rep(0, length(genres))#
#
for(i in 1:length(genres)) {#
	counts[i] <- sum(movies[, genres[i]])#
}#
#
df <- data.frame(factor(genres), counts)#
colnames(df) <- c("Genres", "Counts")#
#
## How to Sort by Bars#
sortOrder <- order(df$Counts, decreasing = FALSE)#
df$Genres <- factor(df$Genres, levels = df$Genres[sortOrder])#
#
p <- ggplot(df, aes(x = Genres, y = Counts, fill = Genres))#
#
p <- p + geom_bar(stat="identity")#
#
p <- p + xlab("Movie Genre")#
p <- p + ylab("Count in 1000s")#
p <- p + ggtitle("Movies by Genre")#
p <- p + labs(fill = "Movie Genres")#
#
##thousand_formatter <- function(x) {#
##	label <- x / 1000#
##}#
#
thousand_formatter <- function(x) {#
	return(sprintf("%dk", round(x / 1000))) # d is digit, f would be floating#
}#
p <- p + scale_y_continuous(#
	expand = c(0,0),#
	label = thousand_formatter#
	)#
print(p)
library(ggplot2)#
library(shiny)#
#
data("movies", package = "ggplot2")#
#
start <- which(colnames(movies) == "Action")#
#
end <- which (colnames(movies) == "Short")#
#
genres <- colnames(movies)[start:end]#
#
counts <- rep(0, length(genres))#
#
for(i in 1:length(genres)) {#
	counts[i] <- sum(movies[, genres[i]])#
}#
#
df <- data.frame(factor(genres), counts)#
colnames(df) <- c("Genres", "Counts")#
#
## How to Sort by Bars#
sortOrder <- order(df$Counts, decreasing = FALSE)#
df$Genres <- factor(df$Genres, levels = df$Genres[sortOrder])#
#
p <- ggplot(df, aes(x = Genres, y = Counts, fill = Genres))#
#
p <- p + geom_bar(stat="identity")#
#
p <- p + xlab("Movie Genre")#
p <- p + ylab("Count in 1000s")#
p <- p + ggtitle("Movies by Genre")#
p <- p + labs(fill = "Movie Genres")#
#
##thousand_formatter <- function(x) {#
##	label <- x / 1000#
##}#
#
thousand_formatter <- function(x) {#
	return(sprintf("%dk", round(x / 1000))) # d is digit, f would be floating#
}#
p <- p + scale_y_continuous(#
	expand = c(0,20), # removes padding at bottom#
	label = thousand_formatter#
	)#
print(p)
library(ggplot2)#
library(shiny)#
#
data("movies", package = "ggplot2")#
#
start <- which(colnames(movies) == "Action")#
#
end <- which (colnames(movies) == "Short")#
#
genres <- colnames(movies)[start:end]#
#
counts <- rep(0, length(genres))#
#
for(i in 1:length(genres)) {#
	counts[i] <- sum(movies[, genres[i]])#
}#
#
df <- data.frame(factor(genres), counts)#
colnames(df) <- c("Genres", "Counts")#
#
## How to Sort by Bars#
sortOrder <- order(df$Counts, decreasing = FALSE)#
df$Genres <- factor(df$Genres, levels = df$Genres[sortOrder])#
#
p <- ggplot(df, aes(x = Genres, y = Counts, fill = Genres))#
#
p <- p + geom_bar(stat="identity")#
#
p <- p + xlab("Movie Genre")#
p <- p + ylab("Count in 1000s")#
p <- p + ggtitle("Movies by Genre")#
p <- p + labs(fill = "Movie Genres")#
#
##thousand_formatter <- function(x) {#
##	label <- x / 1000#
##}#
#
thousand_formatter <- function(x) {#
	return(sprintf("%dk", round(x / 1000))) # d is digit, f would be floating#
}#
p <- p + scale_y_continuous(#
	expand = c(0,20), # removes padding at bottom#
	label = thousand_formatter#
	)#
#
p <- p + theme(axis.title.x = element())#
print(p)
library(ggplot2)#
library(shiny)#
#
data("movies", package = "ggplot2")#
#
start <- which(colnames(movies) == "Action")#
#
end <- which (colnames(movies) == "Short")#
#
genres <- colnames(movies)[start:end]#
#
counts <- rep(0, length(genres))#
#
for(i in 1:length(genres)) {#
	counts[i] <- sum(movies[, genres[i]])#
}#
#
df <- data.frame(factor(genres), counts)#
colnames(df) <- c("Genres", "Counts")#
#
## How to Sort by Bars#
sortOrder <- order(df$Counts, decreasing = FALSE)#
df$Genres <- factor(df$Genres, levels = df$Genres[sortOrder])#
#
p <- ggplot(df, aes(x = Genres, y = Counts, fill = Genres))#
#
p <- p + geom_bar(stat="identity")#
#
p <- p + xlab("Movie Genre")#
p <- p + ylab("Count in 1000s")#
p <- p + ggtitle("Movies by Genre")#
p <- p + labs(fill = "Movie Genres")#
#
##thousand_formatter <- function(x) {#
##	label <- x / 1000#
##}#
#
thousand_formatter <- function(x) {#
	return(sprintf("%dk", round(x / 1000))) # d is digit, f would be floating#
}#
p <- p + scale_y_continuous(#
	expand = c(0,20), # removes padding at bottom#
	label = thousand_formatter#
	)#
#
p <- p + theme(axis.title.x = element())#
p <- p + theme(axis.title.y = element())#
print(p)
library(ggplot2)#
library(shiny)#
#
data("movies", package = "ggplot2")#
#
start <- which(colnames(movies) == "Action")#
#
end <- which (colnames(movies) == "Short")#
#
genres <- colnames(movies)[start:end]#
#
counts <- rep(0, length(genres))#
#
for(i in 1:length(genres)) {#
	counts[i] <- sum(movies[, genres[i]])#
}#
#
df <- data.frame(factor(genres), counts)#
colnames(df) <- c("Genres", "Counts")#
#
## How to Sort by Bars#
sortOrder <- order(df$Counts, decreasing = FALSE)#
df$Genres <- factor(df$Genres, levels = df$Genres[sortOrder])#
#
p <- ggplot(df, aes(x = Genres, y = Counts, fill = Genres))#
#
p <- p + geom_bar(stat="identity")#
#
p <- p + xlab("Movie Genre")#
p <- p + ylab("Count in 1000s")#
p <- p + ggtitle("Movies by Genre")#
p <- p + labs(fill = "Movie Genres")#
#
##thousand_formatter <- function(x) {#
##	label <- x / 1000#
##}#
#
thousand_formatter <- function(x) {#
	return(sprintf("%dk", round(x / 1000))) # d is digit, f would be floating#
}#
p <- p + scale_y_continuous(#
	expand = c(0,20), # removes padding at bottom#
	label = thousand_formatter#
	)#
#
p <- p + theme(axis.title.x = element_blank())#
p <- p + theme(axis.title.y = element_blank())#
p <- p + theme(legend.position = "none")#
print(p)
library(ggplot2)#
library(shiny)#
#
data("movies", package = "ggplot2")#
#
start <- which(colnames(movies) == "Action")#
#
end <- which (colnames(movies) == "Short")#
#
genres <- colnames(movies)[start:end]#
#
counts <- rep(0, length(genres))#
#
for(i in 1:length(genres)) {#
	counts[i] <- sum(movies[, genres[i]])#
}#
#
df <- data.frame(factor(genres), counts)#
colnames(df) <- c("Genres", "Counts")#
#
## How to Sort by Bars#
sortOrder <- order(df$Counts, decreasing = FALSE)#
df$Genres <- factor(df$Genres, levels = df$Genres[sortOrder])#
#
p <- ggplot(df, aes(x = Genres, y = Counts, fill = Genres))#
#
p <- p + geom_bar(stat="identity")#
#
p <- p + xlab("Movie Genre")#
p <- p + ylab("Count in 1000s")#
p <- p + ggtitle("Movies by Genre")#
p <- p + labs(fill = "Movie Genres")#
#
##thousand_formatter <- function(x) {#
##	label <- x / 1000#
##}#
#
thousand_formatter <- function(x) {#
	return(sprintf("%dk", round(x / 1000))) # d is digit, f would be floating#
}#
p <- p + scale_y_continuous(#
	expand = c(0,20), # removes padding at bottom#
	label = thousand_formatter#
	)#
#
p <- p + theme(axis.title.x = element_blank())#
p <- p + theme(axis.title.y = element_blank())#
p <- p + theme(legend.position = "none")#
p <- p + theme(axis.ticks.x = element_blank())#
print(p)
library(ggplot2)#
library(shiny)#
#
data("movies", package = "ggplot2")#
#
start <- which(colnames(movies) == "Action")#
#
end <- which (colnames(movies) == "Short")#
#
genres <- colnames(movies)[start:end]#
#
counts <- rep(0, length(genres))#
#
for(i in 1:length(genres)) {#
	counts[i] <- sum(movies[, genres[i]])#
}#
#
df <- data.frame(factor(genres), counts)#
colnames(df) <- c("Genres", "Counts")#
#
## How to Sort by Bars#
sortOrder <- order(df$Counts, decreasing = FALSE)#
df$Genres <- factor(df$Genres, levels = df$Genres[sortOrder])#
#
p <- ggplot(df, aes(x = Genres, y = Counts, fill = Genres))#
#
p <- p + geom_bar(stat="identity")#
#
p <- p + xlab("Movie Genre")#
p <- p + ylab("Count in 1000s")#
p <- p + ggtitle("Movies by Genre")#
p <- p + labs(fill = "Movie Genres")#
#
##thousand_formatter <- function(x) {#
##	label <- x / 1000#
##}#
#
thousand_formatter <- function(x) {#
	return(sprintf("%dk", round(x / 1000))) # d is digit, f would be floating#
}#
p <- p + scale_y_continuous(#
	expand = c(0,20), # removes padding at bottom#
	label = thousand_formatter#
	)#
#
p <- p + theme(axis.title.x = element_blank())#
p <- p + theme(axis.title.y = element_blank())#
p <- p + theme(legend.position = "none")#
p <- p + theme(axis.ticks.x = element_blank())#
p <- p + theme(panel.grid.major.x = element_blank())#
print(p)
library(ggplot2)#
library(shiny)#
#
data("movies", package = "ggplot2")#
#
start <- which(colnames(movies) == "Action")#
#
end <- which (colnames(movies) == "Short")#
#
genres <- colnames(movies)[start:end]#
#
counts <- rep(0, length(genres))#
#
for(i in 1:length(genres)) {#
	counts[i] <- sum(movies[, genres[i]])#
}#
#
df <- data.frame(factor(genres), counts)#
colnames(df) <- c("Genres", "Counts")#
#
## How to Sort by Bars#
sortOrder <- order(df$Counts, decreasing = FALSE)#
df$Genres <- factor(df$Genres, levels = df$Genres[sortOrder])#
#
p <- ggplot(df, aes(x = Genres, y = Counts, fill = Genres))#
#
p <- p + geom_bar(stat="identity")#
#
p <- p + xlab("Movie Genre")#
p <- p + ylab("Count in 1000s")#
p <- p + ggtitle("Movies by Genre")#
p <- p + labs(fill = "Movie Genres")#
#
##thousand_formatter <- function(x) {#
##	label <- x / 1000#
##}#
#
thousand_formatter <- function(x) {#
	return(sprintf("%dk", round(x / 1000))) # d is digit, f would be floating#
}#
p <- p + scale_y_continuous(#
	expand = c(0,20), # removes padding at bottom#
	label = thousand_formatter#
	)#
#
p <- p + theme(axis.title.x = element_blank())#
p <- p + theme(axis.title.y = element_blank())#
p <- p + theme(legend.position = "none")#
p <- p + theme(axis.ticks.x = element_blank())#
p <- p + theme(panel.grid.major.x = element_blank())#
p <- p + theme(panel.grid.minor.y = element_blank())#
print(p)
library(ggplot2)#
library(shiny)#
#
data("movies", package = "ggplot2")#
#
start <- which(colnames(movies) == "Action")#
#
end <- which (colnames(movies) == "Short")#
#
genres <- colnames(movies)[start:end]#
#
counts <- rep(0, length(genres))#
#
for(i in 1:length(genres)) {#
	counts[i] <- sum(movies[, genres[i]])#
}#
#
df <- data.frame(factor(genres), counts)#
colnames(df) <- c("Genres", "Counts")#
#
## How to Sort by Bars#
sortOrder <- order(df$Counts, decreasing = FALSE)#
df$Genres <- factor(df$Genres, levels = df$Genres[sortOrder])#
#
p <- ggplot(df, aes(x = Genres, y = Counts, fill = Genres))#
#
p <- p + geom_bar(stat="identity")#
#
p <- p + xlab("Movie Genre")#
p <- p + ylab("Count in 1000s")#
p <- p + ggtitle("Movies by Genre")#
p <- p + labs(fill = "Movie Genres")#
#
##thousand_formatter <- function(x) {#
##	label <- x / 1000#
##}#
#
thousand_formatter <- function(x) {#
	return(sprintf("%dk", round(x / 1000))) # d is digit, f would be floating#
}#
p <- p + scale_y_continuous(#
	expand = c(0,40), # removes padding at bottom#
	label = thousand_formatter#
	)#
#
p <- p + theme(axis.title.x = element_blank())#
p <- p + theme(axis.title.y = element_blank())#
p <- p + theme(legend.position = "none")#
p <- p + theme(axis.ticks.x = element_blank())#
p <- p + theme(panel.grid.major.x = element_blank())#
p <- p + theme(panel.grid.minor.y = element_blank())#
print(p)
library(ggplot2)#
library(shiny)#
#
data("movies", package = "ggplot2")#
#
start <- which(colnames(movies) == "Action")#
#
end <- which (colnames(movies) == "Short")#
#
genres <- colnames(movies)[start:end]#
#
counts <- rep(0, length(genres))#
#
for(i in 1:length(genres)) {#
	counts[i] <- sum(movies[, genres[i]])#
}#
#
df <- data.frame(factor(genres), counts)#
colnames(df) <- c("Genres", "Counts")#
#
## How to Sort by Bars#
sortOrder <- order(df$Counts, decreasing = FALSE)#
df$Genres <- factor(df$Genres, levels = df$Genres[sortOrder])#
#
p <- ggplot(df, aes(x = Genres, y = Counts, fill = Genres))#
#
p <- p + geom_bar(stat="identity")#
#
p <- p + xlab("Movie Genre")#
p <- p + ylab("Count in 1000s")#
p <- p + ggtitle("Movies by Genre")#
p <- p + labs(fill = "Movie Genres")#
#
##thousand_formatter <- function(x) {#
##	label <- x / 1000#
##}#
#
thousand_formatter <- function(x) {#
	return(sprintf("%dk", round(x / 1000))) # d is digit, f would be floating#
}#
p <- p + scale_y_continuous(#
	expand = c(0,500), # removes padding at bottom#
	label = thousand_formatter#
	)#
#
p <- p + theme(axis.title.x = element_blank())#
p <- p + theme(axis.title.y = element_blank())#
p <- p + theme(legend.position = "none")#
p <- p + theme(axis.ticks.x = element_blank())#
p <- p + theme(panel.grid.major.x = element_blank())#
p <- p + theme(panel.grid.minor.y = element_blank())#
p <- p + theme(axis.text.x = element_text(size=12))#
print(p)
library(ggplot2)#
library(shiny)#
#
data("movies", package = "ggplot2")#
#
start <- which(colnames(movies) == "Action")#
#
end <- which (colnames(movies) == "Short")#
#
genres <- colnames(movies)[start:end]#
#
counts <- rep(0, length(genres))#
#
for(i in 1:length(genres)) {#
	counts[i] <- sum(movies[, genres[i]])#
}#
#
df <- data.frame(factor(genres), counts)#
colnames(df) <- c("Genres", "Counts")#
#
## How to Sort by Bars#
sortOrder <- order(df$Counts, decreasing = FALSE)#
df$Genres <- factor(df$Genres, levels = df$Genres[sortOrder])#
#
p <- ggplot(df, aes(x = Genres, y = Counts, fill = Genres))#
#
p <- p + geom_bar(stat="identity")#
#
p <- p + xlab("Movie Genre")#
p <- p + ylab("Count in 1000s")#
p <- p + ggtitle("Movies by Genre")#
p <- p + labs(fill = "Movie Genres")#
#
##thousand_formatter <- function(x) {#
##	label <- x / 1000#
##}#
#
thousand_formatter <- function(x) {#
	return(sprintf("%dk", round(x / 1000))) # d is digit, f would be floating#
}#
p <- p + scale_y_continuous(#
	expand = c(0,200), # removes padding at bottom#
	label = thousand_formatter#
	)#
#
p <- p + theme(axis.title.x = element_blank())#
p <- p + theme(axis.title.y = element_blank())#
p <- p + theme(legend.position = "none")#
p <- p + theme(axis.ticks.x = element_blank())#
p <- p + theme(panel.grid.major.x = element_blank())#
p <- p + theme(panel.grid.minor.y = element_blank())#
p <- p + theme(axis.text.x = element_text(size=12))#
print(p)
library(ggplot2)#
library(shiny)#
#
data("movies", package = "ggplot2")#
#
start <- which(colnames(movies) == "Action")#
#
end <- which (colnames(movies) == "Short")#
#
genres <- colnames(movies)[start:end]#
#
counts <- rep(0, length(genres))#
#
for(i in 1:length(genres)) {#
	counts[i] <- sum(movies[, genres[i]])#
}#
#
df <- data.frame(factor(genres), counts)#
colnames(df) <- c("Genres", "Counts")#
#
## How to Sort by Bars#
sortOrder <- order(df$Counts, decreasing = FALSE)#
df$Genres <- factor(df$Genres, levels = df$Genres[sortOrder])#
#
p <- ggplot(df, aes(x = Genres, y = Counts, fill = Genres))#
#
p <- p + geom_bar(stat="identity")#
#
p <- p + xlab("Movie Genre")#
p <- p + ylab("Count in 1000s")#
p <- p + ggtitle("Movies by Genre")#
p <- p + labs(fill = "Movie Genres")#
#
##thousand_formatter <- function(x) {#
##	label <- x / 1000#
##}#
#
thousand_formatter <- function(x) {#
	return(sprintf("%dk", round(x / 1000))) # d is digit, f would be floating#
}#
p <- p + scale_y_continuous(#
	expand = c(0,200), # removes padding at bottom#
	label = thousand_formatter#
	)#
#
p <- p + theme(axis.title.x = element_blank())#
p <- p + theme(axis.title.y = element_blank())#
p <- p + theme(legend.position = "none")#
p <- p + theme(axis.ticks.x = element_blank())#
p <- p + theme(panel.grid.major.x = element_blank())#
p <- p + theme(panel.grid.minor.y = element_blank())#
p <- p + theme(axis.text.x = element_text(size=12))#
p <- p + scale_color_brewer(type = "qual", palette = "Set3")#
print(p)
library(ggplot2)#
library(shiny)#
#
data("movies", package = "ggplot2")#
#
start <- which(colnames(movies) == "Action")#
#
end <- which (colnames(movies) == "Short")#
#
genres <- colnames(movies)[start:end]#
#
counts <- rep(0, length(genres))#
#
for(i in 1:length(genres)) {#
	counts[i] <- sum(movies[, genres[i]])#
}#
#
df <- data.frame(factor(genres), counts)#
colnames(df) <- c("Genres", "Counts")#
#
## How to Sort by Bars#
sortOrder <- order(df$Counts, decreasing = FALSE)#
df$Genres <- factor(df$Genres, levels = df$Genres[sortOrder])#
#
p <- ggplot(df, aes(x = Genres, y = Counts, fill = Genres))#
#
p <- p + geom_bar(stat="identity")#
#
p <- p + xlab("Movie Genre")#
p <- p + ylab("Count in 1000s")#
p <- p + ggtitle("Movies by Genre")#
p <- p + labs(fill = "Movie Genres")#
#
##thousand_formatter <- function(x) {#
##	label <- x / 1000#
##}#
#
thousand_formatter <- function(x) {#
	return(sprintf("%dk", round(x / 1000))) # d is digit, f would be floating#
}#
p <- p + scale_y_continuous(#
	expand = c(0,200), # removes padding at bottom#
	label = thousand_formatter#
	)#
#
p <- p + theme(axis.title.x = element_blank())#
p <- p + theme(axis.title.y = element_blank())#
p <- p + theme(legend.position = "none")#
p <- p + theme(axis.ticks.x = element_blank())#
p <- p + theme(panel.grid.major.x = element_blank())#
p <- p + theme(panel.grid.minor.y = element_blank())#
p <- p + theme(axis.text.x = element_text(size=12))#
p <- p + scale_fill_brewer(type = "qual", palette = "Set3")#
print(p)
library(ggplot2)#
library(shiny)#
#
data("movies", package = "ggplot2")#
#
start <- which(colnames(movies) == "Action")#
#
end <- which (colnames(movies) == "Short")#
#
genres <- colnames(movies)[start:end]#
#
counts <- rep(0, length(genres))#
#
for(i in 1:length(genres)) {#
	counts[i] <- sum(movies[, genres[i]])#
}#
#
df <- data.frame(factor(genres), counts)#
colnames(df) <- c("Genres", "Counts")#
#
## How to Sort by Bars#
sortOrder <- order(df$Counts, decreasing = FALSE)#
df$Genres <- factor(df$Genres, levels = df$Genres[sortOrder])#
#
p <- ggplot(df, aes(x = Genres, y = Counts, fill = Genres, color = "red"))#
#
p <- p + geom_bar(stat="identity")#
#
p <- p + xlab("Movie Genre")#
p <- p + ylab("Count in 1000s")#
p <- p + ggtitle("Movies by Genre")#
p <- p + labs(fill = "Movie Genres")#
#
##thousand_formatter <- function(x) {#
##	label <- x / 1000#
##}#
#
thousand_formatter <- function(x) {#
	return(sprintf("%dk", round(x / 1000))) # d is digit, f would be floating#
}#
p <- p + scale_y_continuous(#
	expand = c(0,200), # removes padding at bottom#
	label = thousand_formatter#
	)#
#
p <- p + theme(axis.title.x = element_blank())#
p <- p + theme(axis.title.y = element_blank())#
p <- p + theme(legend.position = "none")#
p <- p + theme(axis.ticks.x = element_blank())#
p <- p + theme(panel.grid.major.x = element_blank())#
p <- p + theme(panel.grid.minor.y = element_blank())#
p <- p + theme(axis.text.x = element_text(size=12))#
p <- p + scale_fill_brewer(type = "qual", palette = "Set3")#
#
palette1 <- c("...")#
p <- p + scale_fill_manual(value = "palette1")#
#
p <- p + scale_fill_grey(start = 0.4 end 0.4)#
print(p)
if (!require("devtools"))#
  install.packages("devtools")#
devtools::install_github("shiny", "rstudio")
library()
Server File#
# library(ggplot2)#
# library(shiny)#
#
# shinyServer(function(input, output) {#
	# localFrame <- globalData #copy of global#
	# sortOrder <- reactive({#
		# if (input$sortColumn == "Genre") {#
			# return(#
				# order(localFrame$Genre,#
					# descending = input$sortDescending))#
		# }#
		# else {#
			# return(#
				# )#
		# }#
	# })#
	# output$scatterPlot <- renderPlot({#
		# scatterPlot <- getPlot(localFrame, sortOrder(), ""None"") #getPlot function#
		# print(scatterPlot)#
	# })#
## Jeremy Gilmore#
## MSAN 622#
#
## Homework 2#
#
library(ggplot2)#
library(scales)#
data(movies)#
#
## modify data: movies#
movies=movies[which(!movies$budget<=0 & !movies$mpaa==""),]#
genre <- rep(NA, nrow(movies))#
count <- rowSums(movies[, 18:24])#
genre[which(count > 1)] = "Mixed"#
genre[which(count < 1)] = "None"#
genre[which(count == 1 & movies$Action == 1)] = "Action"#
genre[which(count == 1 & movies$Animation == 1)] = "Animation"#
genre[which(count == 1 & movies$Comedy == 1)] = "Comedy"#
genre[which(count == 1 & movies$Drama == 1)] = "Drama"#
genre[which(count == 1 & movies$Documentary == 1)] = "Documentary"#
genre[which(count == 1 & movies$Romance == 1)] = "Romance"#
genre[which(count == 1 & movies$Short == 1)] = "Short"#
movies$Genre<-genre#
#
million_formatter <- function(x) {#
	#label <- round(x / 1000000)#
	return(sprintf("$%sM", round(x / 1000000)))#
}#
#
getPlot <- function(alphaVal,genreVal,mpaaVal,pointVal,colorScheme) {#
	subMovies <- subset(movies, (movies$Genre %in% genreVal) & (movies$mpaa %in% mpaaVal), c(budget, mpaa, rating))#
	MPAA <- factor(subMovies$mpaa, levels=c("PG", "PG-13", "R", "NC-17"))#
#
	assign("subMovies", subMovies, envir=globalenv())#
	assign("MPAA", MPAA, envir=globalenv())#
	p <- ggplot(subMovies,#
		aes(x= subMovies$budget, y= subMovies$rating,#
		colour=MPAA)) +#
		geom_point(alpha=alphaVal, shape=20, size=pointVal) +#
		scale_y_continuous(breaks=seq(0,10,1), labels=seq(0,10,1)) +#
		scale_x_continuous(label = million_formatter) +#
		theme(legend.position="bottom") +#
		ggtitle("IMDB Movies Data") +#
		xlab("Budget in Millions of USD") +#
		ylab("IMDB Ratings")#
#
	if (colorScheme == "Default") {#
		p <- p#
	}#
	else {#
		p <- p + scale_color_brewer(palette = colorScheme)#
	}#
	return(p)#
}#
shinyServer(function(input, output) {#
	cat("Press \"ESC\" to exit...\n")#
#
	alphaVal <- reactive ({#
		input$alphaVals#
	})#
	genreVal <- reactive ({#
		input$genreVals#
	})#
	mpaaVal <- reactive ({#
		input$mpaaVals#
	})#
	pointVal <- reactive ({#
		input$pointVals#
	})#
	colorScheme <- reactive ({#
		input$colorSchemes#
	})#
#
	output$scatterPlot <- renderPlot ({#
		print(getPlot(alphaVal,genreVal,mpaaVal,pointVal,colorScheme))#
	})#
})
Iris dataset#
#
# Shiny example 3#
#
data("iris")#
#
p <- ggplot(iris, aes(x = Sepal.Length,#
						y = Sepal.Width,#
						color = Species))#
p <- geom_point(size=4)#
print(p)
p <- ggplot(iris, aes(x = Sepal.Length,
Iris dataset#
#
# Shiny example 3#
#
data("iris")#
#
p <- ggplot(iris, aes(x = Sepal.Length,#
						y = Sepal.Width,#
						color = Species))#
p <- geom_point(size=4)#
print(p)
Iris dataset#
#
# Shiny example 3#
#
data("iris")#
#
p <- ggplot(iris, aes(x = Sepal.Length,#
						y = Sepal.Width,#
						color = Species)))#
p <- geom_point(size=4)#
print(p)
Iris dataset#
#
# Shiny example 3#
#
data("iris")#
#
p <- ggplot(iris, aes(x = Sepal.Length,#
						y = Sepal.Width,#
						color = Species))#
p <- geom_point(size=4)#
print(p)
Iris dataset#
#
# Shiny example 3#
#
data("iris")#
#
p <- ggplot(iris, aes(x = Sepal.Length,#
						y = Sepal.Width,#
						color = Species))#
p <- p + geom_point(size=4)#
print(p)
Iris dataset#
#
# Shiny example 3#
library(ggplot2)#
#
data("iris")#
#
p <- ggplot(iris, aes(x = Sepal.Length,#
						y = Sepal.Width,#
						color = Species))#
p <- p + geom_point(size=4)#
print(p)
Jeremy Gilmore#
## MSAN 622#
#
## Homework 2#
#
library(ggplot2)#
library(shiny)#
library(scales)#
data(movies)#
movies=movies[which(!movies$budget<=0 & !movies$mpaa==""),]#
genre <- rep(NA, nrow(movies))#
count <- rowSums(movies[, 18:24])#
genre[which(count > 1)] = "Mixed"#
genre[which(count < 1)] = "None"#
genre[which(count == 1 & movies$Action == 1)] = "Action"#
genre[which(count == 1 & movies$Animation == 1)] = "Animation"#
genre[which(count == 1 & movies$Comedy == 1)] = "Comedy"#
genre[which(count == 1 & movies$Drama == 1)] = "Drama"#
genre[which(count == 1 & movies$Documentary == 1)] = "Documentary"#
genre[which(count == 1 & movies$Romance == 1)] = "Romance"#
genre[which(count == 1 & movies$Short == 1)] = "Short"#
movies$Genre<-genre#
#
million_formatter <- function(x) {#
	#label <- round(x / 1000000)#
	return(sprintf("$%sM", round(x / 1000000)))#
}#
#
getPlot <- function(alphaVal,genreVal,mpaaVal,pointVal,colorScheme) {#
	subMovies <- subset(movies, (movies$Genre %in% genreVal) & (movies$mpaa %in% mpaaVal), c(budget, mpaa, rating))#
	MPAA <- factor(subMovies$mpaa, levels=c("PG", "PG-13", "R", "NC-17"))#
#
	assign("subMovies", subMovies, envir=globalenv())#
	assign("MPAA", MPAA, envir=globalenv())#
	p <- ggplot(subMovies,#
		aes(x= subMovies$budget, y= subMovies$rating,#
		colour=MPAA)) +#
		geom_point(alpha=alphaVal, shape=20, size=pointVal) +#
		scale_y_continuous(breaks=seq(0,10,1), labels=seq(0,10,1)) +#
		scale_x_continuous(label = million_formatter) +#
		theme(legend.position="bottom") +#
		ggtitle("IMDB Movies Data") +#
		xlab("Budget in Millions of USD") +#
		ylab("IMDB Ratings")#
#
	if (colorScheme == "Default") {#
		p <- p#
	}#
	else {#
		p <- p + scale_color_brewer(palette = colorScheme)#
	}#
	return(p)#
}#
#
shinyServer(function(input, output) {#
	cat("Press \"ESC\" to exit...\n")#
#
	mpaaValS <- reactive ({#
		if (input$mpaaVal == "All") {#
			result <- c("PG", "PG-13", "R", "NC-17")#
			return(result)#
		}#
		else {#
			return(input$mpaaVal)#
		}#
	})#
#
	genreValS <- reactive ({#
		if(length(input$genreVal) == 0) {#
			result <- c("Action", "Animation", "Comedy", "Documentary", 					"Drama", "Romance", "Short")#
			return(result)#
		}#
		else {#
			return(input$genreVal)#
		}#
	})#
#
	# mpaaVal <- reactive ({#
		# input$mpaaVals#
	# })#
	# pointVal <- reactive ({#
		# input$pointVals#
	# })#
	# colorScheme <- reactive ({#
		# input$colorSchemes#
	# })#
#
	output$scatterPlot <- renderPlot ({#
		scatterPlot <- getPlot(input$alphaVal, (genreValS()), (mpaaValS()), 			input$pointVal, input$colorScheme)#
		print(scatterPlot)#
	})#
})
runApp()
Jeremy Gilmore#
## MSAN 622#
#
## Homework 2#
#
library(ggplot2)#
library(shiny)#
library(scales)#
data(movies)#
movies=movies[which(!movies$budget<=0 & !movies$mpaa==""),]#
genre <- rep(NA, nrow(movies))#
count <- rowSums(movies[, 18:24])#
genre[which(count > 1)] = "Mixed"#
genre[which(count < 1)] = "None"#
genre[which(count == 1 & movies$Action == 1)] = "Action"#
genre[which(count == 1 & movies$Animation == 1)] = "Animation"#
genre[which(count == 1 & movies$Comedy == 1)] = "Comedy"#
genre[which(count == 1 & movies$Drama == 1)] = "Drama"#
genre[which(count == 1 & movies$Documentary == 1)] = "Documentary"#
genre[which(count == 1 & movies$Romance == 1)] = "Romance"#
genre[which(count == 1 & movies$Short == 1)] = "Short"#
movies$Genre<-genre#
#
million_formatter <- function(x) {#
	#label <- round(x / 1000000)#
	return(sprintf("$%sM", round(x / 1000000)))#
}#
#
getPlot <- function(alphaVal,genreVal,mpaaVal,pointVal,colorScheme,jitterVal) {#
	subMovies <- subset(movies, (movies$Genre %in% genreVal) & (movies$mpaa %in% mpaaVal), c(budget, mpaa, rating))#
	MPAA <- factor(subMovies$mpaa, levels=c("PG", "PG-13", "R", "NC-17"))#
#
	assign("subMovies", subMovies, envir=globalenv())#
	assign("MPAA", MPAA, envir=globalenv())#
	p <- ggplot(subMovies,#
		aes(x= subMovies$budget, y= subMovies$rating,#
		colour=MPAA)) +#
		geom_point(alpha=alphaVal, shape=20, size=pointVal, position=jitterVal) +#
		scale_y_continuous(breaks=seq(0,10,1), labels=seq(0,10,1)) +#
		scale_x_continuous(label = million_formatter) +#
		theme(legend.position="bottom") +#
		ggtitle("IMDb Ratings and Budget") +#
		theme(plot.title = element_text(face="bold")) +#
		xlab("Budget in Millions of USD") +#
		ylab("IMDB Ratings")#
#
	if (colorScheme == "Default") {#
		p <- p#
	}#
	else {#
		p <- p + scale_color_brewer(palette = colorScheme)#
	}#
	return(p)#
}#
#
shinyServer(function(input, output) {#
	cat("Press \"ESC\" to exit...\n")#
#
	mpaaValS <- reactive ({#
		if (input$mpaaVal == "All") {#
			result <- c("PG", "PG-13", "R", "NC-17")#
			return(result)#
		}#
		else {#
			return(input$mpaaVal)#
		}#
	})#
#
	genreValS <- reactive ({#
		if(length(input$genreVal) == 0) {#
			result <- c("Action", "Animation", "Comedy", "Documentary", 					"Drama", "Romance", "Short")#
			return(result)#
		}#
		else {#
			return(input$genreVal)#
		}#
	})#
	alphaValS <- reactive ({#
		result <- (1-input$alphaVal)#
		return(result)#
	})#
	jitterValS <- reactive ({#
		if(input$jitterVal == "Yes") {#
			result <- "jitter"#
			return(result)#
		}#
		else {#
			return("identity")#
		}#
	})#
#
	output$scatterPlot <- renderPlot ({#
		scatterPlot <- getPlot((alphaValS()), (genreValS()), (mpaaValS()), 			input$pointVal, input$colorScheme, (jitterValS()))#
		print(scatterPlot)#
	}, width = 500, height = 500)#
})
runApp()
setwd("/Users/jg/Documents/DataVis/msan622/Homework2")
Jeremy Gilmore#
## MSAN 622#
#
## Homework 2#
#
library(ggplot2)#
library(shiny)#
library(scales)#
data(movies)#
movies=movies[which(!movies$budget<=0 & !movies$mpaa==""),]#
genre <- rep(NA, nrow(movies))#
count <- rowSums(movies[, 18:24])#
genre[which(count > 1)] = "Mixed"#
genre[which(count < 1)] = "None"#
genre[which(count == 1 & movies$Action == 1)] = "Action"#
genre[which(count == 1 & movies$Animation == 1)] = "Animation"#
genre[which(count == 1 & movies$Comedy == 1)] = "Comedy"#
genre[which(count == 1 & movies$Drama == 1)] = "Drama"#
genre[which(count == 1 & movies$Documentary == 1)] = "Documentary"#
genre[which(count == 1 & movies$Romance == 1)] = "Romance"#
genre[which(count == 1 & movies$Short == 1)] = "Short"#
movies$Genre<-genre#
#
million_formatter <- function(x) {#
	#label <- round(x / 1000000)#
	return(sprintf("$%sM", round(x / 1000000)))#
}#
#
getPlot <- function(alphaVal,genreVal,mpaaVal,pointVal,colorScheme,jitterVal) {#
	subMovies <- subset(movies, (movies$Genre %in% genreVal) & (movies$mpaa %in% mpaaVal), c(budget, mpaa, rating))#
	MPAA <- factor(subMovies$mpaa, levels=c("PG", "PG-13", "R", "NC-17"))#
#
	assign("subMovies", subMovies, envir=globalenv())#
	assign("MPAA", MPAA, envir=globalenv())#
	p <- ggplot(subMovies,#
		aes(x= subMovies$budget, y= subMovies$rating,#
		colour=MPAA)) +#
		geom_point(alpha=alphaVal, shape=20, size=pointVal, position=jitterVal) +#
		scale_y_continuous(breaks=seq(0,10,1), labels=seq(0,10,1)) +#
		scale_x_continuous(label = million_formatter) +#
		theme(legend.position="bottom") +#
		ggtitle("IMDb Ratings and Budget") +#
		theme(plot.title = element_text(face="bold")) +#
		xlab("Budget in Millions of USD") +#
		ylab("IMDB Ratings")#
#
	if (colorScheme == "Default") {#
		p <- p#
	}#
	else {#
		p <- p + scale_color_brewer(palette = colorScheme)#
	}#
	return(p)#
}#
#
shinyServer(function(input, output) {#
	cat("Press \"ESC\" to exit...\n")#
#
	mpaaValS <- reactive ({#
		if (input$mpaaVal == "All") {#
			result <- c("PG", "PG-13", "R", "NC-17")#
			return(result)#
		}#
		else {#
			return(input$mpaaVal)#
		}#
	})#
#
	genreValS <- reactive ({#
		if(length(input$genreVal) == 0) {#
			result <- c("Action", "Animation", "Comedy", "Documentary", 					"Drama", "Romance", "Short")#
			return(result)#
		}#
		else {#
			return(input$genreVal)#
		}#
	})#
	alphaValS <- reactive ({#
		result <- (1-input$alphaVal)#
		return(result)#
	})#
	jitterValS <- reactive ({#
		if(input$jitterVal == "Yes") {#
			result <- "jitter"#
			return(result)#
		}#
		else {#
			return("identity")#
		}#
	})#
#
	output$scatterPlot <- renderPlot ({#
		scatterPlot <- getPlot((alphaValS()), (genreValS()), (mpaaValS()), 			input$pointVal, input$colorScheme, (jitterValS()))#
		print(scatterPlot)#
	}, width = 500, height = 500)#
})
runApp()
