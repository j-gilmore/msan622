generalhabitual<-(((min(generalparticipation))+(max(generalparticipation)))/n)
generalhabitual
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<-1000 ## number of Democrats#
nReps<-1000 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25  ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities#
#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	} #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
##General Election Data#
generalframej <- primaryframej[2:7]#
generalSums<- colSums(generalframej)#
generalMeans<- colMeans(generalframej)#
generaltotalvotes<-rowSums(generalframej)#
generalparticipation<-table(generaltotalvotes)#
generalparticipation#
barplot(generalparticipation, main="BDT General Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
plot(elections, voteRts)#
plot(elections, voteDts)#
#
mean(voteDts)#
mean(voteRts)#
mean(voteD)#
mean(voteR)#
mean(actions)#
#
par(mfrow=c(1,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
barplot(generalparticipation, main="BDT General Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
generalhabitual<-(((generalparticipation["0"])+(generalparticipation["6"]))/n)#
generalhabitual
voteDts
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-500 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<-1000 ## number of Democrats#
nReps<-1000 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25  ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities#
#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	} #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
##General Election Data#
generalframej <- primaryframej[2:7]#
generalSums<- colSums(generalframej)#
generalMeans<- colMeans(generalframej)#
generaltotalvotes<-rowSums(generalframej)#
generalparticipation<-table(generaltotalvotes)#
generalparticipation#
barplot(generalparticipation, main="BDT General Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
plot(elections, voteRts)#
plot(elections, voteDts)#
#
mean(voteDts)#
mean(voteRts)#
mean(voteD)#
mean(voteR)#
mean(actions)#
#
par(mfrow=c(1,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
barplot(generalparticipation, main="BDT General Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
generalhabitual<-(((generalparticipation["0"])+(generalparticipation["6"]))/n)#
generalhabitual
voteDts
ls()
voteDts[1000]
voteDts[500]
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<-1000 ## number of Democrats#
nReps<-1000 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25  ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities#
#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	} #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
##General Election Data#
generalframej <- primaryframej[2:7]#
generalSums<- colSums(generalframej)#
generalMeans<- colMeans(generalframej)#
generaltotalvotes<-rowSums(generalframej)#
generalparticipation<-table(generaltotalvotes)#
generalparticipation#
barplot(generalparticipation, main="BDT General Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
plot(elections, voteRts)#
plot(elections, voteDts)#
#
voteDts[nPeriods]#
voteRts[nPeriods]#
mean(actions)#
#
par(mfrow=c(1,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
barplot(generalparticipation, main="BDT General Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
generalhabitual<-(((generalparticipation["0"])+(generalparticipation["6"]))/n)#
generalhabitual
voteDts[1000]
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<-999 ## number of Democrats#
nReps<-1000 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25  ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities#
#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	} #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
##General Election Data#
generalframej <- primaryframej[2:7]#
generalSums<- colSums(generalframej)#
generalMeans<- colMeans(generalframej)#
generaltotalvotes<-rowSums(generalframej)#
generalparticipation<-table(generaltotalvotes)#
generalparticipation#
barplot(generalparticipation, main="BDT General Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
plot(elections, voteRts)#
plot(elections, voteDts)#
#
voteDts[nPeriods]#
voteRts[nPeriods]#
mean(actions)#
#
par(mfrow=c(1,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
barplot(generalparticipation, main="BDT General Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
generalhabitual<-(((generalparticipation["0"])+(generalparticipation["6"]))/n)#
generalhabitual
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<-999 ## number of Democrats#
nReps<-1000 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25  ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities#
#
	## individual voting habits#
	if(j > nPeriods-6){#
	votematrixj<- list(votematrixj, actions)#
	} #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##General Election Data#
generalframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
generalSums<- colSums(generalframej)#
generalMeans<- colMeans(generalframej)#
generaltotalvotes<-rowSums(generalframej)#
generalparticipation<-table(generaltotalvotes)#
generalparticipation#
barplot(generalparticipation, main="BDT General Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
#
voteDts[nPeriods]#
voteRts[nPeriods]#
mean(actions)#
#
par(mfrow=c(2,2))#
barplot(generalparticipation, main="BDT General Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts)#
plot(elections, voteDts)#
#
##Habitual Voting Behavior#
generalhabitual<-(((generalparticipation["0"])+(generalparticipation["6"]))/n)#
generalhabitual
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<-999 ## number of Democrats#
nReps<-1000 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25  ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 0 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities#
#
	## individual voting habits#
	if(j > nPeriods-6){#
	votematrixj<- list(votematrixj, actions)#
	} #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##General Election Data#
generalframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
generalSums<- colSums(generalframej)#
generalMeans<- colMeans(generalframej)#
generaltotalvotes<-rowSums(generalframej)#
generalparticipation<-table(generaltotalvotes)#
generalparticipation#
barplot(generalparticipation, main="BDT General Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
#
voteDts[nPeriods]#
voteRts[nPeriods]#
mean(actions)#
#
par(mfrow=c(2,2))#
barplot(generalparticipation, main="BDT General Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts)#
plot(elections, voteDts)#
#
##Habitual Voting Behavior#
generalhabitual<-(((generalparticipation["0"])+(generalparticipation["6"]))/n)#
generalhabitual
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<-999 ## number of Democrats#
nReps<-1000 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25  ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 0 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities#
#
	## individual voting habits#
	if(j > nPeriods-6){#
	votematrixj<- list(votematrixj, actions)#
	} #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##General Election Data#
generalframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
generalSums<- colSums(generalframej)#
generalMeans<- colMeans(generalframej)#
generaltotalvotes<-rowSums(generalframej)#
generalparticipation<-table(generaltotalvotes)#
generalparticipation#
barplot(generalparticipation, main="BDT General Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
#
voteDts[nPeriods]#
voteRts[nPeriods]#
mean(actions)#
#
par(mfrow=c(2,2))#
barplot(generalparticipation, main="BDT General Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, xlab="Elections", ylab="Republican Votes")#
plot(elections, voteDts)#
#
##Habitual Voting Behavior#
generalhabitual<-(((generalparticipation["0"])+(generalparticipation["6"]))/n)#
generalhabitual
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<-999 ## number of Democrats#
nReps<-1000 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25  ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 0 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities#
#
	## individual voting habits#
	if(j > nPeriods-6){#
	votematrixj<- list(votematrixj, actions)#
	} #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##General Election Data#
generalframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
generalSums<- colSums(generalframej)#
generalMeans<- colMeans(generalframej)#
generaltotalvotes<-rowSums(generalframej)#
generalparticipation<-table(generaltotalvotes)#
generalparticipation#
barplot(generalparticipation, main="BDT General Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
#
voteDts[nPeriods]#
voteRts[nPeriods]#
mean(actions)#
#
par(mfrow=c(2,2))#
barplot(generalparticipation, main="BDT General Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, xlab="Elections", ylab="Republican Votes")#
plot(elections, voteDts, xlab="Elections", ylab="Democratic Votes")#
#
##Habitual Voting Behavior#
generalhabitual<-(((generalparticipation["0"])+(generalparticipation["6"]))/n)#
generalhabitual
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<-999 ## number of Democrats#
nReps<-1000 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25  ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities#
#
	## individual voting habits#
	if(j > nPeriods-6){#
	votematrixj<- list(votematrixj, actions)#
	} #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##General Election Data#
generalframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
generalSums<- colSums(generalframej)#
generalMeans<- colMeans(generalframej)#
generaltotalvotes<-rowSums(generalframej)#
generalparticipation<-table(generaltotalvotes)#
generalparticipation#
barplot(generalparticipation, main="BDT General Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
#
voteDts[nPeriods]#
voteRts[nPeriods]#
mean(actions)#
#
par(mfrow=c(2,2))#
barplot(generalparticipation, main="BDT General Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, xlab="Elections", ylab="Republican Votes")#
plot(elections, voteDts, xlab="Elections", ylab="Democratic Votes")#
#
##Habitual Voting Behavior#
generalhabitual<-(((generalparticipation["0"])+(generalparticipation["6"]))/n)#
generalhabitual
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<-999 ## number of Democrats#
nReps<-1000 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25  ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 0 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities#
#
	## individual voting habits#
	if(j > nPeriods-6){#
	votematrixj<- list(votematrixj, actions)#
	} #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##General Election Data#
generalframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
generalSums<- colSums(generalframej)#
generalMeans<- colMeans(generalframej)#
generaltotalvotes<-rowSums(generalframej)#
generalparticipation<-table(generaltotalvotes)#
generalparticipation#
barplot(generalparticipation, main="BDT General Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
#
voteDts[nPeriods]#
voteRts[nPeriods]#
mean(actions)#
#
par(mfrow=c(2,2))#
barplot(generalparticipation, main="BDT General Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, xlab="Elections", ylab="Republican Votes")#
plot(elections, voteDts, xlab="Elections", ylab="Democratic Votes")#
#
##Habitual Voting Behavior#
generalhabitual<-(((generalparticipation["0"])+(generalparticipation["6"]))/n)#
generalhabitual
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<-999 ## number of Democrats#
nReps<-1000 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25  ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 0 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities#
#
	## individual voting habits#
	if(j > nPeriods-6){#
	votematrixj<- list(votematrixj, actions)#
	} #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##General Election Results#
generalframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
generalSums<- colSums(generalframej)#
generalMeans<- colMeans(generalframej)#
generaltotalvotes<-rowSums(generalframej)#
generalparticipation<-table(generaltotalvotes)#
generalparticipation#
barplot(generalparticipation, main="BDT General Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
#
voteDts[nPeriods]#
voteRts[nPeriods]#
mean(actions)#
#
par(mfrow=c(2,2))#
barplot(generalparticipation, main="BDT General Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, xlab="Elections", ylab="Republican Votes")#
plot(elections, voteDts, xlab="Elections", ylab="Democratic Votes")#
#
##Habitual Voting Behavior#
generalhabitual<-(((generalparticipation["0"])+(generalparticipation["6"]))/n)#
generalhabitual
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.6  ## cost to the democrats#
costR<- 0.6 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities#
#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	} #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
#
voteDts[nPeriods]#
voteRts[nPeriods]#
mean(actions)#
#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, xlab="Elections", ylab="Republican Votes")#
plot(elections, voteDts, xlab="Elections", ylab="Democratic Votes")#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.6  ## cost to the democrats#
costR<- 0.6 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities#
#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	} #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
#
voteDts[nPeriods]#
voteRts[nPeriods]#
mean(actions)#
#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, pch=19, cex=.9, voteRts, xlab="Elections", ylab="Republican Votes")#
plot(elections, voteDts, xlab="Elections", ylab="Democratic Votes")#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.6  ## cost to the democrats#
costR<- 0.6 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities#
#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	} #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
#
voteDts[nPeriods]#
voteRts[nPeriods]#
mean(actions)#
#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, pch=19, cex=.2, voteRts, xlab="Elections", ylab="Republican Votes")#
plot(elections, voteDts, xlab="Elections", ylab="Democratic Votes")#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.6  ## cost to the democrats#
costR<- 0.6 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities#
#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	} #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
#
voteDts[nPeriods]#
voteRts[nPeriods]#
mean(actions)#
#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, cex=.2, voteRts, xlab="Elections", ylab="Republican Votes")#
plot(elections, voteDts, xlab="Elections", ylab="Democratic Votes")#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.6  ## cost to the democrats#
costR<- 0.6 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities#
#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	} #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
#
voteDts[nPeriods]#
voteRts[nPeriods]#
mean(actions)#
#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, cex=.2, voteRts, xlab="Elections", ylab="Republican Votes")#
plot(elections, cex=.2, voteDts, xlab="Elections", ylab="Democratic Votes")#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.6  ## cost to the democrats#
costR<- 0.6 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities#
#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	} #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
#
voteDts[nPeriods]#
voteRts[nPeriods]#
mean(actions)#
#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
lines(elections, voteRts, cex=.2, xlab="Elections", ylab="Republican Votes")#
plot(elections, voteDts, cex=.2, xlab="Elections", ylab="Democratic Votes")#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.6  ## cost to the democrats#
costR<- 0.6 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities#
#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	} #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
#
voteDts[nPeriods]#
voteRts[nPeriods]#
mean(actions)#
#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.2, xlab="Elections", ylab="Republican Votes")#
plot(elections, voteDts, cex=.2, xlab="Elections", ylab="Democratic Votes")#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.6  ## cost to the democrats#
costR<- 0.6 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities#
#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	} #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
#
voteDts[nPeriods]#
voteRts[nPeriods]#
mean(actions)#
#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes")#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes")#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.8  ## cost to the democrats#
costR<- 0.8 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities#
#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	} #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
#
voteDts[nPeriods]#
voteRts[nPeriods]#
mean(actions)#
#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes")#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes")#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25  ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities#
#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	} #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
#
voteDts[nPeriods]#
voteRts[nPeriods]#
mean(actions)#
#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes")#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes")#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25  ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 0 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities#
#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	} #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
#
voteDts[nPeriods]#
voteRts[nPeriods]#
mean(actions)#
#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes")#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes")#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.35  ## cost to the democrats#
costR<- 0.35 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 0 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities#
#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	} #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
#
voteDts[nPeriods]#
voteRts[nPeriods]#
mean(actions)#
#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes")#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes")#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.30  ## cost to the democrats#
costR<- 0.30 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 0 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities#
#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	} #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
#
voteDts[nPeriods]#
voteRts[nPeriods]#
mean(actions)#
#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes")#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes")#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.32  ## cost to the democrats#
costR<- 0.32 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 0 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities#
#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	} #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
#
voteDts[nPeriods]#
voteRts[nPeriods]#
mean(actions)#
#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes")#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes")#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual
primaryparticipation
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.31  ## cost to the democrats#
costR<- 0.31 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 0 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities#
#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	} #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
#
voteDts[nPeriods]#
voteRts[nPeriods]#
mean(actions)#
#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes")#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes")#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.35  ## cost to the democrats#
costR<- 0.35 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 0 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities#
#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	} #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
#
voteDts[nPeriods]#
voteRts[nPeriods]#
mean(actions)#
#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes")#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes")#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual
voteDts
voteRts
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.35  ## cost to the democrats#
costR<- 0.35 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 0 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities#
#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	} #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
#
voteDts[nPeriods]#
voteRts[nPeriods]#
mean(actions)#
#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes")#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes")#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual
voteDts
voteRts
plot(elections, primaryparticipation)
plot(elections, primarytotalvotes)
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.35  ## cost to the democrats#
costR<- 0.35 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 0 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities#
#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	} #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
#
voteDts[nPeriods]#
voteRts[nPeriods]#
mean(actions)#
#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes")#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes")#
plot(elections, (voteRts+voteDts), cex=.3, xlab="Elections", ylab="Democratic Votes")#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.35  ## cost to the democrats#
costR<- 0.35 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 0 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities#
#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	} #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
#
voteDts[nPeriods]#
voteRts[nPeriods]#
mean(actions)#
#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteR, cex=.3, xlab="Elections", ylab="Republican Votes")#
plot(elections, voteD, cex=.3, xlab="Elections", ylab="Democratic Votes")#
plot(elections, (voteR+voteD), cex=.3, xlab="Elections", ylab="Democratic Votes")#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.35  ## cost to the democrats#
costR<- 0.35 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 0 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities#
#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	} #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
#
voteDts[nPeriods]#
voteRts[nPeriods]#
mean(actions)#
#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes")#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes")#
plot(elections, (voteRts+voteDts), cex=.3, xlab="Elections", ylab="Democratic Votes")#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual
voteD
voteDts
primaryparticipation
primarytotalvotes
actions
mean(actions)
voteDts[nPeriods]#
voteRts[nPeriods]
mean((voteRts+voteDts))
mean(voteRts+voteDts)
mean(voteRts[nPeriods]+voteDts[nPeriods])
mean((voteRts[nPeriods]+voteDts[nPeriods]))
((voteRts[nPeriods]+voteDts[nPeriods]))/2
voteRts
participation<-(voteRts+voteDts)/2
participation
plot(elections, participation)
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.35  ## cost to the democrats#
costR<- 0.35 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 0 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities#
#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	} #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
participation<-(voteRts+voteDts)/2#
#
voteDts[nPeriods]#
voteRts[nPeriods]#
mean(actions)#
#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes")#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes")#
plot(elections, (voteRts+voteDts), cex=.3, xlab="Elections", ylab="Democratic Votes")#
plot(elections, participation, cex=.3, xlab="Elections", ylab="Total Participation")#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.35  ## cost to the democrats#
costR<- 0.35 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 0 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities#
#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	} #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
participation<-(voteRts+voteDts)/2#
#
voteDts[nPeriods]#
voteRts[nPeriods]#
mean(actions)#
#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes")#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes")#
plot(elections, participation, cex=.3, xlab="Elections", ylab="Total Participation")#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual
actions
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.35  ## cost to the democrats#
costR<- 0.35 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 0 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  particmatrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities#
#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	} #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	particmatrixj<-list(particmatrixj,actions)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
meanparticipation<-(voteRts+voteDts)/2#
#
voteDts[nPeriods]#
voteRts[nPeriods]#
mean(actions)#
#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes")#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes")#
plot(elections, meanparticipation, cex=.3, xlab="Elections", ylab="Total Participation")#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
#
##Voting Trends#
particframej <- data.frame(matrix(unlist(list(particmatrixj)), nrow=n, byrow=TRUE))#
particSums<- colSums(particframej)#
particMeans<- colMeans(particframej)#
partictotalvotes<-rowSums(particframej)#
participation<-table(partictotalvotes)#
participation
partictotalvotes
particframej
particSums
particMeans
mean(particMeans)
particframej
particSums
particMeans
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.35  ## cost to the democrats#
costR<- 0.35 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 0 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  particmatrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities#
#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	} #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	particmatrixj<-list(particmatrixj,actions)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
meanparticipation<-(voteRts+voteDts)/2#
#
voteDts[nPeriods]#
voteRts[nPeriods]#
mean(actions)#
#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes")#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes")#
plot(elections, particMeans, cex=.3, xlab="Elections", ylab="Mean Participation")#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
#
##Voting Trends#
particframej <- data.frame(matrix(unlist(list(particmatrixj)), nrow=n, byrow=TRUE))#
particSums<- colSums(particframej)#
particMeans<- colMeans(particframej)#
mean(particMeans) ## Mean of Actions over all j elections#
partictotalvotes<-rowSums(particframej)
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.35  ## cost to the democrats#
costR<- 0.35 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 0 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  particmatrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities#
#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	} #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	particmatrixj<-list(particmatrixj,actions)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
meanparticipation<-(voteRts+voteDts)/2#
#
voteDts[nPeriods]#
voteRts[nPeriods]#
mean(actions)#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
#
##Voting Trends#
particframej <- data.frame(matrix(unlist(list(particmatrixj)), nrow=n, byrow=TRUE))#
particSums<- colSums(particframej)#
particMeans<- colMeans(particframej)#
mean(particMeans) ## Mean of Actions over all j elections#
partictotalvotes<-rowSums(particframej)#
#
## Plots#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes")#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes")#
plot(elections, particMeans, cex=.3, xlab="Elections", ylab="Mean Participation")
actions
particmatrixj
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.35  ## cost to the democrats#
costR<- 0.35 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 0 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  particmatrixj<-matrix()#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities#
#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	} #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	particmatrixj<-list(particmatrixj,actions)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
meanparticipation<-(voteRts+voteDts)/2#
#
voteDts[nPeriods]#
voteRts[nPeriods]#
mean(actions)#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
#
##Voting Trends#
particframej <- data.frame(matrix(unlist(list(particmatrixj)), nrow=n, byrow=TRUE))#
particSums<- colSums(particframej)#
particMeans<- colMeans(particframej)#
mean(particMeans) ## Mean of Actions over all j elections#
partictotalvotes<-rowSums(particframej)#
#
## Plots#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes")#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes")#
plot(elections, particMeans, cex=.3, xlab="Elections", ylab="Mean Participation")
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.35  ## cost to the democrats#
costR<- 0.35 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 0 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  particmatrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities#
#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	} #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	particmatrixj<-list(particmatrixj,actions)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
meanparticipation<-(voteRts+voteDts)/2#
#
voteDts[nPeriods]#
voteRts[nPeriods]#
mean(actions)#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
#
##Voting Trends#
particframej <- data.frame(matrix(unlist(list(particmatrixj)), nrow=n, byrow=TRUE))#
particSums<- colSums(particframej)#
particMeans<- colMeans(particframej)#
mean(particMeans) ## Mean of Actions over all j elections#
partictotalvotes<-rowSums(particframej)#
#
## Plots#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes")#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes")#
plot(elections, particMeans, cex=.3, xlab="Elections", ylab="Mean Participation")
actions
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.35  ## cost to the democrats#
costR<- 0.35 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 0 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  particmatrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities#
#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	} #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	particmatrixj<-list(particmatrixj,actions)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
meanparticipation<-(voteRts+voteDts)/2#
#
voteDts[nPeriods]#
voteRts[nPeriods]#
mean(actions) ## For last election only#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
#
##Voting Trends#
particframej <- data.frame(matrix(unlist(list(particmatrixj)), nrow=n, byrow=TRUE))#
particSums<- colSums(particframej)#
particMeans<- colMeans(particframej)#
mean(particMeans) ## Mean of Actions over all j elections#
partictotalvotes<-rowSums(particframej)#
#
## Plots#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes")#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes")#
plot(elections, particMeans, cex=.3, xlab="Elections", ylab="Mean Participation")
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.40  ## cost to the democrats#
costR<- 0.40 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 0 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  particmatrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities#
#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	} #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	particmatrixj<-list(particmatrixj,actions)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
meanparticipation<-(voteRts+voteDts)/2#
#
voteDts[nPeriods]#
voteRts[nPeriods]#
mean(actions) ## For last election only#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
#
##Voting Trends#
particframej <- data.frame(matrix(unlist(list(particmatrixj)), nrow=n, byrow=TRUE))#
particSums<- colSums(particframej)#
particMeans<- colMeans(particframej)#
mean(particMeans) ## Mean of Actions over all j elections#
partictotalvotes<-rowSums(particframej)#
#
## Plots#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes")#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes")#
plot(elections, particMeans, cex=.3, xlab="Elections", ylab="Mean Participation")
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.50  ## cost to the democrats#
costR<- 0.50 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 0 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  particmatrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities#
#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	} #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	particmatrixj<-list(particmatrixj,actions)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
meanparticipation<-(voteRts+voteDts)/2#
#
voteDts[nPeriods]#
voteRts[nPeriods]#
mean(actions) ## For last election only#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
#
##Voting Trends#
particframej <- data.frame(matrix(unlist(list(particmatrixj)), nrow=n, byrow=TRUE))#
particSums<- colSums(particframej)#
particMeans<- colMeans(particframej)#
mean(particMeans) ## Mean of Actions over all j elections#
partictotalvotes<-rowSums(particframej)#
#
## Plots#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes")#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes")#
plot(elections, particMeans, cex=.3, xlab="Elections", ylab="Mean Participation")
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.60  ## cost to the democrats#
costR<- 0.60 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 0 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  particmatrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities#
#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	} #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	particmatrixj<-list(particmatrixj,actions)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
meanparticipation<-(voteRts+voteDts)/2#
#
voteDts[nPeriods]#
voteRts[nPeriods]#
mean(actions) ## For last election only#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
#
##Voting Trends#
particframej <- data.frame(matrix(unlist(list(particmatrixj)), nrow=n, byrow=TRUE))#
particSums<- colSums(particframej)#
particMeans<- colMeans(particframej)#
mean(particMeans) ## Mean of Actions over all j elections#
partictotalvotes<-rowSums(particframej)#
#
## Plots#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes")#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes")#
plot(elections, particMeans, cex=.3, xlab="Elections", ylab="Mean Participation")
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.55  ## cost to the democrats#
costR<- 0.55 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 0 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  particmatrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities#
#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	} #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	particmatrixj<-list(particmatrixj,actions)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
meanparticipation<-(voteRts+voteDts)/2#
#
voteDts[nPeriods]#
voteRts[nPeriods]#
mean(actions) ## For last election only#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
#
##Voting Trends#
particframej <- data.frame(matrix(unlist(list(particmatrixj)), nrow=n, byrow=TRUE))#
particSums<- colSums(particframej)#
particMeans<- colMeans(particframej)#
mean(particMeans) ## Mean of Actions over all j elections#
partictotalvotes<-rowSums(particframej)#
#
## Plots#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes")#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes")#
plot(elections, particMeans, cex=.3, xlab="Elections", ylab="Mean Participation")
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.50  ## cost to the democrats#
costR<- 0.50 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 0 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  particmatrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities#
#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	} #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	particmatrixj<-list(particmatrixj,actions)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
meanparticipation<-(voteRts+voteDts)/2#
#
voteDts[nPeriods]#
voteRts[nPeriods]#
mean(actions) ## For last election only#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
#
##Voting Trends#
particframej <- data.frame(matrix(unlist(list(particmatrixj)), nrow=n, byrow=TRUE))#
particSums<- colSums(particframej)#
particMeans<- colMeans(particframej)#
mean(particMeans) ## Mean of Actions over all j elections#
partictotalvotes<-rowSums(particframej)#
#
## Plots#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes")#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes")#
plot(elections, particMeans, cex=.3, xlab="Elections", ylab="Mean Participation")
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.47 ## cost to the democrats#
costR<- 0.47 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 0 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  particmatrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities#
#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	} #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	particmatrixj<-list(particmatrixj,actions)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
meanparticipation<-(voteRts+voteDts)/2#
#
voteDts[nPeriods]#
voteRts[nPeriods]#
mean(actions) ## For last election only#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
#
##Voting Trends#
particframej <- data.frame(matrix(unlist(list(particmatrixj)), nrow=n, byrow=TRUE))#
particSums<- colSums(particframej)#
particMeans<- colMeans(particframej)#
mean(particMeans) ## Mean of Actions over all j elections#
partictotalvotes<-rowSums(particframej)#
#
## Plots#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes")#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes")#
plot(elections, particMeans, cex=.3, xlab="Elections", ylab="Mean Participation")
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.47 ## cost to the democrats#
costR<- 0.47 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  particmatrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities#
#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	} #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	particmatrixj<-list(particmatrixj,actions)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
meanparticipation<-(voteRts+voteDts)/2#
#
voteDts[nPeriods]#
voteRts[nPeriods]#
mean(actions) ## For last election only#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
#
##Voting Trends#
particframej <- data.frame(matrix(unlist(list(particmatrixj)), nrow=n, byrow=TRUE))#
particSums<- colSums(particframej)#
particMeans<- colMeans(particframej)#
mean(particMeans) ## Mean of Actions over all j elections#
partictotalvotes<-rowSums(particframej)#
#
## Plots#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes")#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes")#
plot(elections, particMeans, cex=.3, xlab="Elections", ylab="Mean Participation")
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.47 ## cost to the democrats#
costR<- 0.47 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 0 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  particmatrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities#
#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	} #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	particmatrixj<-list(particmatrixj,actions)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
meanparticipation<-(voteRts+voteDts)/2#
#
voteDts[nPeriods]#
voteRts[nPeriods]#
mean(actions) ## For last election only#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
#
##Voting Trends#
particframej <- data.frame(matrix(unlist(list(particmatrixj)), nrow=n, byrow=TRUE))#
particSums<- colSums(particframej)#
particMeans<- colMeans(particframej)#
mean(particMeans) ## Mean of Actions over all j elections#
partictotalvotes<-rowSums(particframej)#
#
## Plots#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes")#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes")#
plot(elections, particMeans, cex=.3, xlab="Elections", ylab="Mean Participation")
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.5 ## cost to the democrats#
costR<- 0.5 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 0 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  particmatrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities#
#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	} #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	particmatrixj<-list(particmatrixj,actions)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
meanparticipation<-(voteRts+voteDts)/2#
#
voteDts[nPeriods]#
voteRts[nPeriods]#
mean(actions) ## For last election only#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
#
##Voting Trends#
particframej <- data.frame(matrix(unlist(list(particmatrixj)), nrow=n, byrow=TRUE))#
particSums<- colSums(particframej)#
particMeans<- colMeans(particframej)#
mean(particMeans) ## Mean of Actions over all j elections#
partictotalvotes<-rowSums(particframej)#
#
## Plots#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes")#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes")#
plot(elections, particMeans, cex=.3, xlab="Elections", ylab="Mean Participation")
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.55 ## cost to the democrats#
costR<- 0.55 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 0 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  particmatrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities#
#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	} #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	particmatrixj<-list(particmatrixj,actions)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
meanparticipation<-(voteRts+voteDts)/2#
#
voteDts[nPeriods]#
voteRts[nPeriods]#
mean(actions) ## For last election only#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
#
##Voting Trends#
particframej <- data.frame(matrix(unlist(list(particmatrixj)), nrow=n, byrow=TRUE))#
particSums<- colSums(particframej)#
particMeans<- colMeans(particframej)#
mean(particMeans) ## Mean of Actions over all j elections#
partictotalvotes<-rowSums(particframej)#
#
## Plots#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes")#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes")#
plot(elections, particMeans, cex=.3, xlab="Elections", ylab="Mean Participation")
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.55 ## cost to the democrats#
costR<- 0.55 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  particmatrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities#
#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	} #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	particmatrixj<-list(particmatrixj,actions)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
meanparticipation<-(voteRts+voteDts)/2#
#
voteDts[nPeriods]#
voteRts[nPeriods]#
mean(actions) ## For last election only#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
#
##Voting Trends#
particframej <- data.frame(matrix(unlist(list(particmatrixj)), nrow=n, byrow=TRUE))#
particSums<- colSums(particframej)#
particMeans<- colMeans(particframej)#
mean(particMeans) ## Mean of Actions over all j elections#
partictotalvotes<-rowSums(particframej)#
#
## Plots#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes")#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes")#
plot(elections, particMeans, cex=.3, xlab="Elections", ylab="Mean Participation")
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.55 ## cost to the democrats#
costR<- 0.55 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 0 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  particmatrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities#
#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	} #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	particmatrixj<-list(particmatrixj,actions)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
meanparticipation<-(voteRts+voteDts)/2#
#
voteDts[nPeriods]#
voteRts[nPeriods]#
mean(actions) ## For last election only#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
#
##Voting Trends#
particframej <- data.frame(matrix(unlist(list(particmatrixj)), nrow=n, byrow=TRUE))#
particSums<- colSums(particframej)#
particMeans<- colMeans(particframej)#
mean(particMeans) ## Mean of Actions over all j elections#
partictotalvotes<-rowSums(particframej)#
#
## Plots#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes")#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes")#
plot(elections, particMeans, cex=.3, xlab="Elections", ylab="Mean Participation")
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.8 ## cost to the democrats#
costR<- 0.8 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  particmatrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities#
#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	} #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	particmatrixj<-list(particmatrixj,actions)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
meanparticipation<-(voteRts+voteDts)/2#
#
voteDts[nPeriods]#
voteRts[nPeriods]#
mean(actions) ## For last election only#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
#
##Voting Trends#
particframej <- data.frame(matrix(unlist(list(particmatrixj)), nrow=n, byrow=TRUE))#
particSums<- colSums(particframej)#
particMeans<- colMeans(particframej)#
mean(particMeans) ## Mean of Actions over all j elections#
partictotalvotes<-rowSums(particframej)#
#
## Plots#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes")#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes")#
plot(elections, particMeans, cex=.3, xlab="Elections", ylab="Mean Participation")
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.9 ## cost to the democrats#
costR<- 0.9 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  particmatrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities#
#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	} #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	particmatrixj<-list(particmatrixj,actions)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
meanparticipation<-(voteRts+voteDts)/2#
#
voteDts[nPeriods]#
voteRts[nPeriods]#
mean(actions) ## For last election only#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
#
##Voting Trends#
particframej <- data.frame(matrix(unlist(list(particmatrixj)), nrow=n, byrow=TRUE))#
particSums<- colSums(particframej)#
particMeans<- colMeans(particframej)#
mean(particMeans) ## Mean of Actions over all j elections#
partictotalvotes<-rowSums(particframej)#
#
## Plots#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes")#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes")#
plot(elections, particMeans, cex=.3, xlab="Elections", ylab="Mean Participation")
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.95 ## cost to the democrats#
costR<- 0.95 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  particmatrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities#
#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	} #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	particmatrixj<-list(particmatrixj,actions)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
meanparticipation<-(voteRts+voteDts)/2#
#
voteDts[nPeriods]#
voteRts[nPeriods]#
mean(actions) ## For last election only#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
#
##Voting Trends#
particframej <- data.frame(matrix(unlist(list(particmatrixj)), nrow=n, byrow=TRUE))#
particSums<- colSums(particframej)#
particMeans<- colMeans(particframej)#
mean(particMeans) ## Mean of Actions over all j elections#
partictotalvotes<-rowSums(particframej)#
#
## Plots#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes")#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes")#
plot(elections, particMeans, cex=.3, xlab="Elections", ylab="Mean Participation")
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  particmatrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities#
#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	} #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	particmatrixj<-list(particmatrixj,actions)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
meanparticipation<-(voteRts+voteDts)/2#
#
voteDts[nPeriods]#
voteRts[nPeriods]#
mean(actions) ## For last election only#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
#
##Voting Trends#
particframej <- data.frame(matrix(unlist(list(particmatrixj)), nrow=n, byrow=TRUE))#
particSums<- colSums(particframej)#
particMeans<- colMeans(particframej)#
mean(particMeans) ## Mean of Actions over all j elections#
partictotalvotes<-rowSums(particframej)#
#
## Plots#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes")#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes")#
plot(elections, particMeans, cex=.3, xlab="Elections", ylab="Mean Participation")
meanParticipation
meanparticipation
mean(meanparticipation)
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  particmatrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities#
#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	} #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	particmatrixj<-list(particmatrixj,actions)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
meanparticipation<-(voteRts+voteDts)/2#
#
voteDts[nPeriods]#
voteRts[nPeriods]#
mean(actions) ## For last election only#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
#
##Voting Trends [Play with this]#
particframej <- data.frame(matrix(unlist(list(particmatrixj)), nrow=n, byrow=TRUE))#
particSums<- colSums(particframej)#
particMeans<- colMeans(particframej)#
mean(particMeans) ## Mean of Actions over all j elections#
partictotalvotes<-rowSums(particframej)#
#
## Plots#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes")#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes")#
plot(elections, particMeans, cex=.3, xlab="Elections", ylab="Mean Participation")
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  particmatrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities#
#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	} #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
meanparticipation<-(voteRts+voteDts)/2#
#
voteDts[nPeriods]#
voteRts[nPeriods]#
mean(actions) ## For last election only#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
#
## Plots#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes")#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes")
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  particmatrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities#
#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	} #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
meanparticipation<-(voteRts+voteDts)/2#
#
voteDts[nPeriods-7:nPeriods]#
voteRts[nPeriods]#
mean(actions) ## For last election only#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
#
## Plots#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes")#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes")
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  particmatrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities#
#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	} #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
meanparticipation<-(voteRts+voteDts)/2#
#
mean(voteDts[nPeriods])#
voteRts[nPeriods]#
mean(actions) ## For last election only#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
#
## Plots#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes")#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes")
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  particmatrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities#
#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	} #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
meanparticipation<-(voteRts+voteDts)/2#
#
mean(voteDts[nPeriods])#
voteDts[nPeriods]#
voteRts[nPeriods]#
mean(actions) ## For last election only#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
#
## Plots#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes")#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes")
voteD
voteR
mean(voteDts)
voteDts
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  rmatrixj<-matrix(nrow=(0), ncol=(0))#
  dmatrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
    meanvoteDts<-mean(voteDts)#
    meanvoteRts<-mean(voteRts)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	rmatrixj<- list(rmatrixj, meanvoteRts)#
	dmatrixj<- list(dmatrixj, meanvoteDts)#
	}#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
meanparticipation<-(voteRts+voteDts)/2#
#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## For last election only#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
#
## Plots#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes")#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes")
rmatrixj
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  rmatrixj<-matrix(nrow=(0), ncol=(0))#
  dmatrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
    meanvoteDts<-mean(voteDts)#
    meanvoteRts<-mean(voteRts)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
	rmatrixj<- list(rmatrixj, meanvoteRts)#
	dmatrixj<- list(dmatrixj, meanvoteDts)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
meanparticipation<-(voteRts+voteDts)/2#
#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## For last election only#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
#
## Plots#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes")#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes")
rmatrixj
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  rmatrixj<-matrix(nrow=(0), ncol=(0))#
  dmatrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
    meanvoteDts<-mean(voteDts)#
    meanvoteRts<-mean(voteRts)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
	rmatrixj<- list(rmatrixj, meanvoteRts)#
	dmatrixj<- list(dmatrixj, meanvoteDts)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
meanparticipation<-(voteRts+voteDts)/2#
#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## For last election only#
mean(rmatrixj)#
mean(dmatrixj)#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
#
## Plots#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes")#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes")
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  rmatrixj<-matrix(nrow=(0), ncol=(0))#
  dmatrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
    meanvoteDts<-mean(voteDts)#
    meanvoteRts<-mean(voteRts)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
	rmatrixj<- list(rmatrixj, meanvoteRts)#
	dmatrixj<- list(dmatrixj, meanvoteDts)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
meanparticipation<-(voteRts+voteDts)/2#
#
rframej <- data.frame(matrix(unlist(list(rmatrixj)), nrow=n, byrow=TRUE))#
dframej <- data.frame(matrix(unlist(list(dmatrixj)), nrow=n, byrow=TRUE))#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## For last election only#
mean(rmatrixj)#
mean(dmatrixj)#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
#
## Plots#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes")#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes")
rmatrixj
rframej
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  rmatrixj<-matrix(nrow=(0), ncol=(0))#
  dmatrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
    meanvoteDts<-mean(voteDts)#
    meanvoteRts<-mean(voteRts)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
	rmatrixj<- list(rmatrixj, meanvoteRts)#
	dmatrixj<- list(dmatrixj, meanvoteDts)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
meanparticipation<-(voteRts+voteDts)/2#
#
rframej <- data.frame(matrix(unlist(list(rmatrixj)), nrow=n, byrow=FALSE))#
dframej <- data.frame(matrix(unlist(list(dmatrixj)), nrow=n, byrow=FALSE))#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## For last election only#
mean(rmatrixj)#
mean(dmatrixj)#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
#
## Plots#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes")#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes")
rmatrixj
rframej
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  rmatrixj<-matrix(nrow=(0), ncol=(0))#
  dmatrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
    meanvoteDts<-mean(voteDts)#
    meanvoteRts<-mean(voteRts)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
	rmatrixj<- list(rmatrixj, meanvoteRts)#
	dmatrixj<- list(dmatrixj, meanvoteDts)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
meanparticipation<-(voteRts+voteDts)/2#
#
rframej <- data.frame(matrix(unlist(list(rmatrixj)), nrow=nPeriods, byrow=TRUE))#
dframej <- data.frame(matrix(unlist(list(dmatrixj)), nrow=nPeriods, byrow=TRUE))#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## For last election only#
mean(rmatrixj)#
mean(dmatrixj)#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
#
## Plots#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes")#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes")
rframej
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  rmatrixj<-matrix(nrow=(0), ncol=(0))#
  dmatrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
    meanvoteDts<-mean(voteDts)#
    meanvoteRts<-mean(voteRts)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
	rmatrixj<- list(rmatrixj, meanvoteRts)#
	dmatrixj<- list(dmatrixj, meanvoteDts)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
meanparticipation<-(voteRts+voteDts)/2#
#
rframej <- data.frame(matrix(unlist(list(rmatrixj)), nrow=nPeriods, byrow=TRUE))#
dframej <- data.frame(matrix(unlist(list(dmatrixj)), nrow=nPeriods, byrow=TRUE))#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## For last election only#
colMeans(rmatrixj)#
colMeans(dmatrixj)#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
#
## Plots#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes")#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes")
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  rmatrixj<-matrix(nrow=(0), ncol=(0))#
  dmatrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
    meanvoteDts<-mean(voteDts)#
    meanvoteRts<-mean(voteRts)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
	rmatrixj<- list(rmatrixj, meanvoteRts)#
	dmatrixj<- list(dmatrixj, meanvoteDts)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
meanparticipation<-(voteRts+voteDts)/2#
#
rframej <- data.frame(matrix(unlist(list(rmatrixj)), nrow=nPeriods, byrow=TRUE))#
dframej <- data.frame(matrix(unlist(list(dmatrixj)), nrow=nPeriods, byrow=TRUE))#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## For last election only#
rowMeans(rmatrixj)#
rowMeans(dmatrixj)#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
#
## Plots#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes")#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes")
rframej
sum(rframej[1])
mean(rframej[1])
mean(rmatrixj[1])
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  ##rmatrixj<-matrix(nrow=(0), ncol=(0))#
  ##dmatrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
    ##meanvoteDts<-mean(voteDts)#
    ##meanvoteRts<-mean(voteRts)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
	##rmatrixj<- list(rmatrixj, meanvoteRts)#
	##dmatrixj<- list(dmatrixj, meanvoteDts)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
meanparticipation<-(voteRts+voteDts)/2#
#
rframej <- data.frame(matrix(unlist(list(rmatrixj)), nrow=nPeriods, byrow=TRUE))#
dframej <- data.frame(matrix(unlist(list(dmatrixj)), nrow=nPeriods, byrow=TRUE))#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## For last election only#
## rowMeans(rmatrixj)#
## rowMeans(dmatrixj)#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
#
## Plots#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes")#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes")
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  ##rmatrixj<-matrix(nrow=(0), ncol=(0))#
  ##dmatrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
    ##meanvoteDts<-mean(voteDts)#
    ##meanvoteRts<-mean(voteRts)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
	##rmatrixj<- list(rmatrixj, meanvoteRts)#
	##dmatrixj<- list(dmatrixj, meanvoteDts)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
meanparticipation<-(voteRts+voteDts)/2#
#
## rframej <- data.frame(matrix(unlist(list(rmatrixj)), nrow=nPeriods, byrow=TRUE))#
## dframej <- data.frame(matrix(unlist(list(dmatrixj)), nrow=nPeriods, byrow=TRUE))#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## For last election only#
## rowMeans(rmatrixj)#
## rowMeans(dmatrixj)#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
#
## Plots#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes")#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes")
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  ##rmatrixj<-matrix(nrow=(0), ncol=(0))#
  ##dmatrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
    ##meanvoteDts<-mean(voteDts)#
    ##meanvoteRts<-mean(voteRts)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
	##rmatrixj<- list(rmatrixj, meanvoteRts)#
	##dmatrixj<- list(dmatrixj, meanvoteDts)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
meanparticipation<-(voteRts+voteDts)/2#
#
## rframej <- data.frame(matrix(unlist(list(rmatrixj)), nrow=nPeriods, byrow=TRUE))#
## dframej <- data.frame(matrix(unlist(list(dmatrixj)), nrow=nPeriods, byrow=TRUE))#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## For last election only#
## rowMeans(rmatrixj)#
## rowMeans(dmatrixj)#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
#
## Plots#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot((elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes", col="Red"), (elections, voteDts))#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes")
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  ##rmatrixj<-matrix(nrow=(0), ncol=(0))#
  ##dmatrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
    ##meanvoteDts<-mean(voteDts)#
    ##meanvoteRts<-mean(voteRts)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
	##rmatrixj<- list(rmatrixj, meanvoteRts)#
	##dmatrixj<- list(dmatrixj, meanvoteDts)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
meanparticipation<-(voteRts+voteDts)/2#
#
## rframej <- data.frame(matrix(unlist(list(rmatrixj)), nrow=nPeriods, byrow=TRUE))#
## dframej <- data.frame(matrix(unlist(list(dmatrixj)), nrow=nPeriods, byrow=TRUE))#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## For last election only#
## rowMeans(rmatrixj)#
## rowMeans(dmatrixj)#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
#
## Plots#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot((elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes", col="Red") (elections, voteDts))#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes")
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  ##rmatrixj<-matrix(nrow=(0), ncol=(0))#
  ##dmatrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
    ##meanvoteDts<-mean(voteDts)#
    ##meanvoteRts<-mean(voteRts)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
	##rmatrixj<- list(rmatrixj, meanvoteRts)#
	##dmatrixj<- list(dmatrixj, meanvoteDts)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
meanparticipation<-(voteRts+voteDts)/2#
#
## rframej <- data.frame(matrix(unlist(list(rmatrixj)), nrow=nPeriods, byrow=TRUE))#
## dframej <- data.frame(matrix(unlist(list(dmatrixj)), nrow=nPeriods, byrow=TRUE))#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## For last election only#
## rowMeans(rmatrixj)#
## rowMeans(dmatrixj)#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
#
## Plots#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot((elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes" col="Red") (elections, voteDts))#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes")
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  ##rmatrixj<-matrix(nrow=(0), ncol=(0))#
  ##dmatrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
    ##meanvoteDts<-mean(voteDts)#
    ##meanvoteRts<-mean(voteRts)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
	##rmatrixj<- list(rmatrixj, meanvoteRts)#
	##dmatrixj<- list(dmatrixj, meanvoteDts)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
meanparticipation<-(voteRts+voteDts)/2#
#
## rframej <- data.frame(matrix(unlist(list(rmatrixj)), nrow=nPeriods, byrow=TRUE))#
## dframej <- data.frame(matrix(unlist(list(dmatrixj)), nrow=nPeriods, byrow=TRUE))#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## For last election only#
## rowMeans(rmatrixj)#
## rowMeans(dmatrixj)#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
#
## Plots#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes")#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes")
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  ##rmatrixj<-matrix(nrow=(0), ncol=(0))#
  ##dmatrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
    ##meanvoteDts<-mean(voteDts)#
    ##meanvoteRts<-mean(voteRts)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
	##rmatrixj<- list(rmatrixj, meanvoteRts)#
	##dmatrixj<- list(dmatrixj, meanvoteDts)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
meanparticipation<-(voteRts+voteDts)/2#
#
## rframej <- data.frame(matrix(unlist(list(rmatrixj)), nrow=nPeriods, byrow=TRUE))#
## dframej <- data.frame(matrix(unlist(list(dmatrixj)), nrow=nPeriods, byrow=TRUE))#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## For last election only#
## rowMeans(rmatrixj)#
## rowMeans(dmatrixj)#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
#
## Plots#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes")#
par(new=T)#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes")#
par(new=F)
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  ##rmatrixj<-matrix(nrow=(0), ncol=(0))#
  ##dmatrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
    ##meanvoteDts<-mean(voteDts)#
    ##meanvoteRts<-mean(voteRts)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
	##rmatrixj<- list(rmatrixj, meanvoteRts)#
	##dmatrixj<- list(dmatrixj, meanvoteDts)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
meanparticipation<-(voteRts+voteDts)/2#
#
## rframej <- data.frame(matrix(unlist(list(rmatrixj)), nrow=nPeriods, byrow=TRUE))#
## dframej <- data.frame(matrix(unlist(list(dmatrixj)), nrow=nPeriods, byrow=TRUE))#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## For last election only#
## rowMeans(rmatrixj)#
## rowMeans(dmatrixj)#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
#
## Plots#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes")#
par(new=T)#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes", col="Red")#
par(new=F)
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  ##rmatrixj<-matrix(nrow=(0), ncol=(0))#
  ##dmatrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
    ##meanvoteDts<-mean(voteDts)#
    ##meanvoteRts<-mean(voteRts)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
	##rmatrixj<- list(rmatrixj, meanvoteRts)#
	##dmatrixj<- list(dmatrixj, meanvoteDts)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
meanparticipation<-(voteRts+voteDts)/2#
#
## rframej <- data.frame(matrix(unlist(list(rmatrixj)), nrow=nPeriods, byrow=TRUE))#
## dframej <- data.frame(matrix(unlist(list(dmatrixj)), nrow=nPeriods, byrow=TRUE))#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## For last election only#
## rowMeans(rmatrixj)#
## rowMeans(dmatrixj)#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
#
## Plots#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes", col="Red")#
par(new=T)#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes", col="Blue")#
par(new=F)
help packages
installed.packages
library()
install.packages("ggplot2")
library()
install.packages("shiny")
library()
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=FALSE))#
primarySums<- colSums(primaryframej) ## Participation in Primary#
primaryMeans<- colMeans(primaryframej) ## Participation Rate#
primaryMeans#
nPeriodthPrimaryMean<-primaryMeans[7]#
nPeriodthPrimaryMean#
primarytotalvotes<-rowSums(primaryframej) ## Individual Participation by number of votes#
primaryparticipation<-table(primarytotalvotes) ## Summary of number of times respondents voted#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
## meanparticipation<-(voteRts+voteDts)/2 ## For each of nPeriods#
#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## Voting rate for last election only#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
#
## Plots#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes", col="Red")#
##par(new=T)#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes", col="Blue")#
##par(new=F)#
#
sum(actions)#
primarySums[7]
actions
primaryframej[7]
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primarySums<- colSums(primaryframej) ## Participation in Primary#
primaryMeans<- colMeans(primaryframej) ## Participation Rate#
primaryMeans#
nPeriodthPrimaryMean<-primaryMeans[7]#
nPeriodthPrimaryMean#
primarytotalvotes<-rowSums(primaryframej) ## Individual Participation by number of votes#
primaryparticipation<-table(primarytotalvotes) ## Summary of number of times respondents voted#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
## meanparticipation<-(voteRts+voteDts)/2 ## For each of nPeriods#
#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## Voting rate for last election only#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
#
## Plots#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes", col="Red")#
##par(new=T)#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes", col="Blue")#
##par(new=F)#
#
sum(actions)#
primarySums[7]
meanparticipation<-(voteRts+voteDts)/2 ## For each of nPeriods
meanparticipation
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primarySums<- colSums(primaryframej) ## Participation in Primary#
primaryMeans<- colMeans(primaryframej) ## Participation Rate#
primaryMeans#
nPeriodthPrimaryMean<-primaryMeans[7]#
nPeriodthPrimaryMean#
primarytotalvotes<-rowSums(primaryframej) ## Individual Participation by number of votes#
primaryparticipation<-table(primarytotalvotes) ## Summary of number of times respondents voted#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
## meanparticipation<-(voteRts+voteDts)/2 ## For each of nPeriods#
#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## Voting rate for last election only#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
#
## Plots#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes", col="Red")#
##par(new=T)#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes", col="Blue")#
##par(new=F)#
#
sum(actions)#
primarySums[7]
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primarySums<- colSums(primaryframej) ## Participation in Primary#
primaryMeans<- colMeans(primaryframej) ## Participation Rate#
## primaryMeans#
nPeriodthPrimaryMean<-primaryMeans[7]#
nPeriodthPrimaryMean#
#
primaryIndVotes<-rowSums(primaryframej) ## Individual Participation by number of votes#
primaryIndParticipation<-table(primaryIndVotes) ## Summary of number of times respondents voted#
primaryIndParticipation#
barplot(primaryIndParticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
## meanparticipation<-(voteRts+voteDts)/2 ## For each of nPeriods#
#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## Voting rate for last election only#
#
##Habitual Voting Behavior#
primaryHabitual<-(((primaryIndParticipation["0"])+(primaryIndParticipation["7"]))/n)#
primaryHabitual#
#
## Plots#
% par(mfrow=c(2,2))#
% barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
% plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes", col="Red")#
% ##par(new=T)#
% plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes", col="Blue")#
##par(new=F)#
#
sum(actions)#
primarySums[7]
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primarySums<- colSums(primaryframej) ## Participation in Primary#
primaryMeans<- colMeans(primaryframej) ## Participation Rate#
## primaryMeans#
nPeriodthPrimaryMean<-primaryMeans[7]#
nPeriodthPrimaryMean#
#
primaryIndVotes<-rowSums(primaryframej) ## Individual Participation by number of votes#
primaryIndParticipation<-table(primaryIndVotes) ## Summary of number of times respondents voted#
primaryIndParticipation#
## barplot(primaryIndParticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
## meanparticipation<-(voteRts+voteDts)/2 ## For each of nPeriods#
#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## Voting rate for last election only#
#
##Habitual Voting Behavior#
primaryHabitual<-(((primaryIndParticipation["0"])+(primaryIndParticipation["7"]))/n)#
primaryHabitual#
#
## Plots#
## par(mfrow=c(2,2))#
## barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
## plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes", col="Red")#
##par(new=T)#
## plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes", col="Blue")#
##par(new=F)#
#
sum(actions)#
primarySums[7]
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primarySums<- colSums(primaryframej) ## Participation in Primary#
primaryMeans<- colMeans(primaryframej) ## Participation Rate#
## primaryMeans#
nPeriodthPrimaryMean<-primaryMeans[7]#
nPeriodthPrimaryMean#
#
primaryIndVotes<-rowSums(primaryframej) ## Individual Participation by number of votes#
primaryIndParticipation<-table(primaryIndVotes) ## Summary of number of times respondents voted (mode)#
primaryIndParticipation#
## barplot(primaryIndParticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
## meanparticipation<-(voteRts+voteDts)/2 ## For each of nPeriods#
#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## Voting rate for last election only#
#
##Habitual Voting Behavior#
primaryHabitual<-(((primaryIndParticipation["0"])+(primaryIndParticipation["7"]))/n)#
primaryHabitual#
#
## Plots#
## par(mfrow=c(2,2))#
## barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
## plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes", col="Red")#
##par(new=T)#
## plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes", col="Blue")#
##par(new=F)#
#
sum(actions)#
primarySums[7]
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primarySums<- colSums(primaryframej) ## Participation in Primary#
primaryMeans<- colMeans(primaryframej) ## Participation Rate#
## primaryMeans#
nPeriodthPrimaryMean<-primaryMeans[7]#
nPeriodthPrimaryMean#
#
primaryIndVotes<-rowSums(primaryframej) ## Individual Participation by number of votes#
primaryIndParticipation<-table(primaryIndVotes) ## Summary of number of times respondents voted (mode)#
primaryIndParticipation#
## barplot(primaryIndParticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
## meanparticipation<-(voteRts+voteDts)/2 ## For each of nPeriods#
#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## Voting rate for last election only#
#
##Habitual Voting Behavior#
primaryHabitual<-(((primaryIndParticipation["0"])+(primaryIndParticipation["7"]))/n)#
primaryHabitual#
#
## Plots#
## par(mfrow=c(2,2))#
## barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
## plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes", col="Red")#
##par(new=T)#
## plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes", col="Blue")#
##par(new=F)#
#
sum(actions)#
primarySums[7]#
##}
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-10 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  votematrixi<-matrix(nrow=(0), ncol=(0))#
  habitmatrixi<-matrix(nrow=(0), ncol=(0))#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primarySums<- colSums(primaryframej) ## Participation in Primary#
primaryMeans<- colMeans(primaryframej) ## Participation Rate#
## primaryMeans#
nPeriodthPrimaryMean<-primaryMeans[7]#
nPeriodthPrimaryMean#
#
primaryIndVotes<-rowSums(primaryframej) ## Individual Participation by number of votes#
primaryIndParticipation<-table(primaryIndVotes) ## Summary of number of times respondents voted (mode)#
primaryIndParticipation#
## barplot(primaryIndParticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
## meanparticipation<-(voteRts+voteDts)/2 ## For each of nPeriods#
#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## Voting rate for last election only#
#
##Habitual Voting Behavior#
primaryHabitual<-(((primaryIndParticipation["0"])+(primaryIndParticipation["7"]))/n) ## For consistent voters and abstainers#
primaryHabitual#
#
## Plots#
## par(mfrow=c(2,2))#
## barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
## plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes", col="Red")#
##par(new=T)#
## plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes", col="Blue")#
##par(new=F)#
#
sum(actions)#
primarySums[7]#
#
votematrixi<- list(votematrixi, mean(actions))#
habitmatrixi<- list(habitmatrixi, primaryHabitual)#
}
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-10 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  votematrixi<-matrix(nrow=(0), ncol=(0))#
  habitmatrixi<-matrix(nrow=(0), ncol=(0))#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primarySums<- colSums(primaryframej) ## Participation in Primary#
primaryMeans<- colMeans(primaryframej) ## Participation Rate#
## primaryMeans#
nPeriodthPrimaryMean<-primaryMeans[7]#
nPeriodthPrimaryMean#
#
primaryIndVotes<-rowSums(primaryframej) ## Individual Participation by number of votes#
primaryIndParticipation<-table(primaryIndVotes) ## Summary of number of times respondents voted (mode)#
primaryIndParticipation#
## barplot(primaryIndParticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
## meanparticipation<-(voteRts+voteDts)/2 ## For each of nPeriods#
#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## Voting rate for last election only#
#
##Habitual Voting Behavior#
primaryHabitual<-(((primaryIndParticipation["0"])+(primaryIndParticipation["7"]))/n) ## For consistent voters and abstainers#
primaryHabitual#
#
## Plots#
## par(mfrow=c(2,2))#
## barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
## plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes", col="Red")#
##par(new=T)#
## plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes", col="Blue")#
##par(new=F)#
#
sum(actions)#
primarySums[7]#
#
votematrixi<- list(votematrixi, mean(actions))#
habitmatrixi<- list(habitmatrixi, primaryHabitual)#
}
votematrixi
habitmatrixi
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-10 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
votematrixi<-matrix(nrow=(0), ncol=(0))#
habitmatrixi<-matrix(nrow=(0), ncol=(0))#
#
for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primarySums<- colSums(primaryframej) ## Participation in Primary#
primaryMeans<- colMeans(primaryframej) ## Participation Rate#
## primaryMeans#
nPeriodthPrimaryMean<-primaryMeans[7]#
nPeriodthPrimaryMean#
#
primaryIndVotes<-rowSums(primaryframej) ## Individual Participation by number of votes#
primaryIndParticipation<-table(primaryIndVotes) ## Summary of number of times respondents voted (mode)#
primaryIndParticipation#
## barplot(primaryIndParticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
## meanparticipation<-(voteRts+voteDts)/2 ## For each of nPeriods#
#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## Voting rate for last election only#
#
##Habitual Voting Behavior#
primaryHabitual<-(((primaryIndParticipation["0"])+(primaryIndParticipation["7"]))/n) ## For consistent voters and abstainers#
primaryHabitual#
#
## Plots#
## par(mfrow=c(2,2))#
## barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
## plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes", col="Red")#
##par(new=T)#
## plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes", col="Blue")#
##par(new=F)#
#
sum(actions)#
primarySums[7]#
#
votematrixi<- list(votematrixi, mean(actions))#
habitmatrixi<- list(habitmatrixi, primaryHabitual)#
}
votematrixi
habitmatrixi
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-10 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
votematrixi<-matrix(nrow=(0), ncol=(0))#
habitmatrixi<-matrix(nrow=(0), ncol=(0))#
#
for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##Primary Election Data#
primaryVoteFramej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primaryVoteSumsj<- colSums(primaryVoteFramej) ## Participation in Primary#
primaryVoteMeansj<- colMeans(primaryVoteFramej) ## Participation Rate#
## primaryVoteMeansj#
nPeriodthPrimaryMeanj<-primaryVoteMeansj[7]#
nPeriodthPrimaryMeanj#
#
primaryIndVotesj<-rowSums(primaryVoteFramej) ## Individual Participation by number of votes#
primaryIndParticipationj<-table(primaryIndVotesj) ## Summary of number of times respondents voted (mode)#
primaryIndParticipationj#
## barplot(primaryIndParticipationj, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
electionsj<-c(1:nPeriods)#
## meanparticipationj<-(voteRts+voteDts)/2 ## For each of nPeriods#
#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## Voting rate for last election only#
#
##Habitual Voting Behavior#
primaryHabitualj<-(((primaryIndParticipationj["0"])+(primaryIndParticipationj["7"]))/n) ## For consistent voters and abstainers#
primaryHabitualj#
#
## Plots#
## par(mfrow=c(2,2))#
## barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
## plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes", col="Red")#
##par(new=T)#
## plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes", col="Blue")#
##par(new=F)#
#
sum(actions)#
primarySums[7]#
#
votematrixi<- list(votematrixi, mean(actions))#
habitmatrixi<- list(habitmatrixi, primaryHabitualj)#
#
}#
#
primaryVoteFramei <- data.frame(matrix(unlist(list(votematrixi)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primaryHabitFramei <- data.frame(matrix(unlist(list(habitmatrixi)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
#
primaryVoteSumsi<- colSums(primaryVoteFramei) ## Participation in Primary#
primaryVoteMeansi<- colMeans(primaryVoteFramei) ## Participation Rate#
## primaryVoteMeansi#
nPeriodthPrimaryMean<-primaryVoteMeansi[7]#
nPeriodthPrimaryMeani#
#
primaryIndVotes<-rowSums(primaryVoteFramej) ## Individual Participation by number of votes#
primaryIndParticipation<-table(primaryIndVotes) ## Summary of number of times respondents voted (mode)#
primaryIndParticipation#
## barplot(primaryIndParticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
## meanparticipation<-(voteRts+voteDts)/2 ## For each of nPeriods#
#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## Voting rate for last election only#
#
##Habitual Voting Behavior#
primaryHabitual<-(((primaryIndParticipation["0"])+(primaryIndParticipation["7"]))/n) ## For consistent voters and abstainers#
primaryHabitual
primaryVoteFramei
votematrixi
habitmatrixi
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-10 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  votematrixi<-matrix(nrow=(0), ncol=(0))#
  habitmatrixi<-matrix(nrow=(0), ncol=(0))#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##Primary Election Data#
primaryVoteFramej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primaryVoteSumsj<- colSums(primaryVoteFramej) ## Participation in Primary#
primaryVoteMeansj<- colMeans(primaryVoteFramej) ## Participation Rate#
## primaryVoteMeansj#
nPeriodthPrimaryMeanj<-primaryVoteMeansj[7]#
nPeriodthPrimaryMeanj#
#
primaryIndVotesj<-rowSums(primaryVoteFramej) ## Individual Participation by number of votes#
primaryIndParticipationj<-table(primaryIndVotesj) ## Summary of number of times respondents voted (mode)#
primaryIndParticipationj#
## barplot(primaryIndParticipationj, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
electionsj<-c(1:nPeriods)#
## meanparticipationj<-(voteRts+voteDts)/2 ## For each of nPeriods#
#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## Voting rate for last election only#
#
##Habitual Voting Behavior#
primaryHabitualj<-(((primaryIndParticipationj["0"])+(primaryIndParticipationj["7"]))/n) ## For consistent voters and abstainers#
primaryHabitualj#
#
## Plots#
## par(mfrow=c(2,2))#
## barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
## plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes", col="Red")#
##par(new=T)#
## plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes", col="Blue")#
##par(new=F)#
#
sum(actions)#
primarySumsj[7]#
#
votematrixi<- list(votematrixi, mean(actions))#
habitmatrixi<- list(habitmatrixi, primaryHabitualj)#
#
}#
#
primaryVoteFramei <- data.frame(matrix(unlist(list(votematrixi)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primaryHabitFramei <- data.frame(matrix(unlist(list(habitmatrixi)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
#
primaryVoteSumsi<- colSums(primaryVoteFramei) ## Participation in Primary#
primaryVoteMeansi<- colMeans(primaryVoteFramei) ## Participation Rate#
## primaryVoteMeansi#
nPeriodthPrimaryMeani<-primaryVoteMeansi[7]#
nPeriodthPrimaryMeani#
#
primaryIndVotes<-rowSums(primaryVoteFramej) ## Individual Participation by number of votes#
primaryIndParticipation<-table(primaryIndVotes) ## Summary of number of times respondents voted (mode)#
primaryIndParticipation#
## barplot(primaryIndParticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
## meanparticipation<-(voteRts+voteDts)/2 ## For each of nPeriods#
#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## Voting rate for last election only#
#
##Habitual Voting Behavior#
primaryHabitual<-(((primaryIndParticipation["0"])+(primaryIndParticipation["7"]))/n) ## For consistent voters and abstainers#
primaryHabitual
votematrixi
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-10 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  votematrixi<-matrix(nrow=(0), ncol=(0))#
  habitmatrixi<-matrix(nrow=(0), ncol=(0))#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##Primary Election Data#
primaryVoteFramej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primaryVoteSumsj<- colSums(primaryVoteFramej) ## Participation in Primary#
primaryVoteMeansj<- colMeans(primaryVoteFramej) ## Participation Rate#
## primaryVoteMeansj#
nPeriodthPrimaryMeanj<-primaryVoteMeansj[7]#
nPeriodthPrimaryMeanj#
#
primaryIndVotesj<-rowSums(primaryVoteFramej) ## Individual Participation by number of votes#
primaryIndParticipationj<-table(primaryIndVotesj) ## Summary of number of times respondents voted (mode)#
primaryIndParticipationj#
## barplot(primaryIndParticipationj, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
electionsj<-c(1:nPeriods)#
## meanparticipationj<-(voteRts+voteDts)/2 ## For each of nPeriods#
#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## Voting rate for last election only#
#
##Habitual Voting Behavior#
primaryHabitualj<-(((primaryIndParticipationj["0"])+(primaryIndParticipationj["7"]))/n) ## For consistent voters and abstainers#
primaryHabitualj#
#
## Plots#
## par(mfrow=c(2,2))#
## barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
## plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes", col="Red")#
##par(new=T)#
## plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes", col="Blue")#
##par(new=F)#
#
sum(actions)#
primarySumsj[7]#
#
  votematrixi<- list(votematrixi, mean(actions))#
  habitmatrixi<- list(habitmatrixi, primaryHabitualj)#
#
}#
#
primaryVoteFramei <- data.frame(matrix(unlist(list(votematrixi)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primaryHabitFramei <- data.frame(matrix(unlist(list(habitmatrixi)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
#
primaryVoteSumsi<- colSums(primaryVoteFramei) ## Participation in Primary#
primaryVoteMeansi<- colMeans(primaryVoteFramei) ## Participation Rate#
## primaryVoteMeansi#
nPeriodthPrimaryMeani<-primaryVoteMeansi[7]#
nPeriodthPrimaryMeani#
#
primaryIndVotes<-rowSums(primaryVoteFramej) ## Individual Participation by number of votes#
primaryIndParticipation<-table(primaryIndVotes) ## Summary of number of times respondents voted (mode)#
primaryIndParticipation#
## barplot(primaryIndParticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
## meanparticipation<-(voteRts+voteDts)/2 ## For each of nPeriods#
#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## Voting rate for last election only#
#
##Habitual Voting Behavior#
primaryHabitual<-(((primaryIndParticipation["0"])+(primaryIndParticipation["7"]))/n) ## For consistent voters and abstainers#
primaryHabitual
votematrixi
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-10 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  votematrixi<-matrix(nrow=(0), ncol=(0))#
  habitmatrixi<-matrix(nrow=(0), ncol=(0))#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##Primary Election Data#
primaryVoteFramej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primaryVoteSumsj<- colSums(primaryVoteFramej) ## Participation in Primary#
primaryVoteMeansj<- colMeans(primaryVoteFramej) ## Participation Rate#
## primaryVoteMeansj#
nPeriodthPrimaryMeanj<-primaryVoteMeansj[7]#
nPeriodthPrimaryMeanj#
#
primaryIndVotesj<-rowSums(primaryVoteFramej) ## Individual Participation by number of votes#
primaryIndParticipationj<-table(primaryIndVotesj) ## Summary of number of times respondents voted (mode)#
primaryIndParticipationj#
## barplot(primaryIndParticipationj, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
electionsj<-c(1:nPeriods)#
## meanparticipationj<-(voteRts+voteDts)/2 ## For each of nPeriods#
#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## Voting rate for last election only#
#
##Habitual Voting Behavior#
primaryHabitualj<-(((primaryIndParticipationj["0"])+(primaryIndParticipationj["7"]))/n) ## For consistent voters and abstainers#
primaryHabitualj#
#
## Plots#
## par(mfrow=c(2,2))#
## barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
## plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes", col="Red")#
##par(new=T)#
## plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes", col="Blue")#
##par(new=F)#
#
sum(actions)#
primarySumsj[7]#
#
votematrixi<- list(votematrixi, mean(actions))#
habitmatrixi<- list(habitmatrixi, primaryHabitualj)#
#
}
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-10 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  votematrixi<-matrix(nrow=(0), ncol=(0))#
  habitmatrixi<-matrix(nrow=(0), ncol=(0))#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##Primary Election Data#
primaryVoteFramej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primaryVoteSumsj<- colSums(primaryVoteFramej) ## Participation in Primary#
primaryVoteMeansj<- colMeans(primaryVoteFramej) ## Participation Rate#
## primaryVoteMeansj#
nPeriodthPrimaryMeanj<-primaryVoteMeansj[7]#
nPeriodthPrimaryMeanj#
#
primaryIndVotesj<-rowSums(primaryVoteFramej) ## Individual Participation by number of votes#
primaryIndParticipationj<-table(primaryIndVotesj) ## Summary of number of times respondents voted (mode)#
primaryIndParticipationj#
## barplot(primaryIndParticipationj, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
electionsj<-c(1:nPeriods)#
## meanparticipationj<-(voteRts+voteDts)/2 ## For each of nPeriods#
#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## Voting rate for last election only#
#
##Habitual Voting Behavior#
primaryHabitualj<-(((primaryIndParticipationj["0"])+(primaryIndParticipationj["7"]))/n) ## For consistent voters and abstainers#
primaryHabitualj#
#
## Plots#
## par(mfrow=c(2,2))#
## barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
## plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes", col="Red")#
##par(new=T)#
## plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes", col="Blue")#
##par(new=F)#
#
sum(actions)#
primaryVoteSumsj[7]#
#
votematrixi<- list(votematrixi, mean(actions))#
habitmatrixi<- list(habitmatrixi, primaryHabitualj)#
#
}
votematrixi
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-10 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
votematrixi<-matrix(nrow=(0), ncol=(0))#
habitmatrixi<-matrix(nrow=(0), ncol=(0))#
#
for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##Primary Election Data#
primaryVoteFramej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primaryVoteSumsj<- colSums(primaryVoteFramej) ## Participation in Primary#
primaryVoteMeansj<- colMeans(primaryVoteFramej) ## Participation Rate#
## primaryVoteMeansj#
nPeriodthPrimaryMeanj<-primaryVoteMeansj[7]#
nPeriodthPrimaryMeanj#
#
primaryIndVotesj<-rowSums(primaryVoteFramej) ## Individual Participation by number of votes#
primaryIndParticipationj<-table(primaryIndVotesj) ## Summary of number of times respondents voted (mode)#
primaryIndParticipationj#
## barplot(primaryIndParticipationj, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
electionsj<-c(1:nPeriods)#
## meanparticipationj<-(voteRts+voteDts)/2 ## For each of nPeriods#
#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## Voting rate for last election only#
#
##Habitual Voting Behavior#
primaryHabitualj<-(((primaryIndParticipationj["0"])+(primaryIndParticipationj["7"]))/n) ## For consistent voters and abstainers#
primaryHabitualj#
#
## Plots#
## par(mfrow=c(2,2))#
## barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
## plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes", col="Red")#
##par(new=T)#
## plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes", col="Blue")#
##par(new=F)#
#
sum(actions)#
primaryVoteSumsj[7]#
#
votematrixi<- list(votematrixi, mean(actions))#
habitmatrixi<- list(habitmatrixi, primaryHabitualj)#
#
}
votematrixi
habitmatrixi
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-10 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
votematrixi<-matrix(nrow=(0), ncol=(0))#
habitmatrixi<-matrix(nrow=(0), ncol=(0))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
#
## This section is for inner J loop only #
##Primary Election Data for j Periods#
primaryVoteFramej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primaryVoteSumsj<- colSums(primaryVoteFramej) ## Participation in Primary#
primaryVoteMeansj<- colMeans(primaryVoteFramej) ## Participation Rate#
## primaryVoteMeansj#
nPeriodthPrimaryMeanj<-primaryVoteMeansj[7]#
nPeriodthPrimaryMeanj#
#
primaryIndVotesj<-rowSums(primaryVoteFramej) ## Individual Participation by number of votes#
primaryIndParticipationj<-table(primaryIndVotesj) ## Summary of number of times respondents voted (mode)#
primaryIndParticipationj#
## barplot(primaryIndParticipationj, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
electionsj<-c(1:nPeriods)#
## meanparticipationj<-(voteRts+voteDts)/2 ## For each of nPeriods#
#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## Voting rate for last election only#
#
##Habitual Voting Behavior#
primaryHabitualj<-(((primaryIndParticipationj["0"])+(primaryIndParticipationj["7"]))/n) ## For consistent voters and abstainers#
primaryHabitualj#
#
## Plots#
## par(mfrow=c(2,2))#
## barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
## plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes", col="Red")#
##par(new=T)#
## plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes", col="Blue")#
##par(new=F)#
#
sum(actions)#
primaryVoteSumsj[7]#
#
votematrixi<- list(votematrixi, mean(actions))#
habitmatrixi<- list(habitmatrixi, primaryHabitualj)#
#
## }
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-10 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
votematrixi<-matrix(nrow=(0), ncol=(0))#
habitmatrixi<-matrix(nrow=(0), ncol=(0))#
#
for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
#
## This section is for inner J loop only #
##Primary Election Data for j Periods#
primaryVoteFramej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primaryVoteSumsj<- colSums(primaryVoteFramej) ## Participation in Primary#
primaryVoteMeansj<- colMeans(primaryVoteFramej) ## Participation Rate#
## primaryVoteMeansj#
nPeriodthPrimaryMeanj<-primaryVoteMeansj[7]#
nPeriodthPrimaryMeanj#
#
primaryIndVotesj<-rowSums(primaryVoteFramej) ## Individual Participation by number of votes#
primaryIndParticipationj<-table(primaryIndVotesj) ## Summary of number of times respondents voted (mode)#
primaryIndParticipationj#
## barplot(primaryIndParticipationj, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
electionsj<-c(1:nPeriods)#
## meanparticipationj<-(voteRts+voteDts)/2 ## For each of nPeriods#
#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## Voting rate for last election only#
#
##Habitual Voting Behavior#
primaryHabitualj<-(((primaryIndParticipationj["0"])+(primaryIndParticipationj["7"]))/n) ## For consistent voters and abstainers#
primaryHabitualj#
#
## Plots#
## par(mfrow=c(2,2))#
## barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
## plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes", col="Red")#
##par(new=T)#
## plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes", col="Blue")#
##par(new=F)#
#
sum(actions)#
primaryVoteSumsj[7]#
#
votematrixi<- list(votematrixi, mean(actions))#
habitmatrixi<- list(habitmatrixi, primaryHabitualj)#
#
}#
#
primaryVoteFramei <- data.frame(matrix(unlist(list(votematrixi)), nrow=n, byrow=FALSE))  ## Extracts data from matrix
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-10 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
votematrixi<-matrix(nrow=(0), ncol=(0))#
habitmatrixi<-matrix(nrow=(0), ncol=(0))#
#
for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
#
## This section is for inner J loop only #
##Primary Election Data for j Periods#
primaryVoteFramej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primaryVoteSumsj<- colSums(primaryVoteFramej) ## Participation in Primary#
primaryVoteMeansj<- colMeans(primaryVoteFramej) ## Participation Rate#
## primaryVoteMeansj#
nPeriodthPrimaryMeanj<-primaryVoteMeansj[7]#
nPeriodthPrimaryMeanj#
#
primaryIndVotesj<-rowSums(primaryVoteFramej) ## Individual Participation by number of votes#
primaryIndParticipationj<-table(primaryIndVotesj) ## Summary of number of times respondents voted (mode)#
primaryIndParticipationj#
## barplot(primaryIndParticipationj, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
electionsj<-c(1:nPeriods)#
## meanparticipationj<-(voteRts+voteDts)/2 ## For each of nPeriods#
#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## Voting rate for last election only#
#
##Habitual Voting Behavior#
primaryHabitualj<-(((primaryIndParticipationj["0"])+(primaryIndParticipationj["7"]))/n) ## For consistent voters and abstainers#
primaryHabitualj#
#
## Plots#
## par(mfrow=c(2,2))#
## barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
## plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes", col="Red")#
##par(new=T)#
## plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes", col="Blue")#
##par(new=F)#
#
sum(actions)#
primaryVoteSumsj[7]#
#
votematrixi<- list(votematrixi, mean(actions))#
habitmatrixi<- list(habitmatrixi, primaryHabitualj)#
#
}#
#
primaryVoteFramei <- data.frame(matrix(unlist(list(votematrixi)), nrow=nSims, byrow=FALSE))  ## Extracts data from matrix
primaryVoteFramei
colSums(primaryVoteFramei)
colMeans(primaryVoteFramei)
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-10 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
votematrixi<-matrix(nrow=(0), ncol=(0))#
habitmatrixi<-matrix(nrow=(0), ncol=(0))#
#
for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
#
## This section is for inner J loop only #
##Primary Election Data for j Periods#
primaryVoteFramej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primaryVoteSumsj<- colSums(primaryVoteFramej) ## Participation in Primary#
primaryVoteMeansj<- colMeans(primaryVoteFramej) ## Participation Rate#
## primaryVoteMeansj#
nPeriodthPrimaryMeanj<-primaryVoteMeansj[7]#
nPeriodthPrimaryMeanj#
#
primaryIndVotesj<-rowSums(primaryVoteFramej) ## Individual Participation by number of votes#
primaryIndParticipationj<-table(primaryIndVotesj) ## Summary of number of times respondents voted (mode)#
primaryIndParticipationj#
## barplot(primaryIndParticipationj, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
electionsj<-c(1:nPeriods)#
## meanparticipationj<-(voteRts+voteDts)/2 ## For each of nPeriods#
#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## Voting rate for last election only#
#
##Habitual Voting Behavior#
primaryHabitualj<-(((primaryIndParticipationj["0"])+(primaryIndParticipationj["7"]))/n) ## For consistent voters and abstainers#
primaryHabitualj#
#
## Plots#
## par(mfrow=c(2,2))#
## barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
## plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes", col="Red")#
##par(new=T)#
## plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes", col="Blue")#
##par(new=F)#
#
sum(actions)#
primaryVoteSumsj[7]#
#
votematrixi<- list(votematrixi, mean(actions))#
habitmatrixi<- list(habitmatrixi, primaryHabitualj)#
#
}#
#
primaryVoteFramei <- data.frame(matrix(unlist(list(votematrixi)), nrow=nSims, byrow=FALSE))  ## Extracts data from matrix#
primaryVoteMeansi<-colMeans(primaryVoteFramei) ## Vote Mean for nSims#
primaryVoteMeansi
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-10 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
votematrixi<-matrix(nrow=(0), ncol=(0))#
habitmatrixi<-matrix(nrow=(0), ncol=(0))#
#
for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
#
## This section is for inner J loop only #
##Primary Election Data for j Periods#
primaryVoteFramej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primaryVoteSumsj<- colSums(primaryVoteFramej) ## Participation in Primary#
primaryVoteMeansj<- colMeans(primaryVoteFramej) ## Participation Rate#
## primaryVoteMeansj#
nPeriodthPrimaryMeanj<-primaryVoteMeansj[7]#
nPeriodthPrimaryMeanj#
#
primaryIndVotesj<-rowSums(primaryVoteFramej) ## Individual Participation by number of votes#
primaryIndParticipationj<-table(primaryIndVotesj) ## Summary of number of times respondents voted (mode)#
primaryIndParticipationj#
## barplot(primaryIndParticipationj, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
electionsj<-c(1:nPeriods)#
## meanparticipationj<-(voteRts+voteDts)/2 ## For each of nPeriods#
#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## Voting rate for last election only#
#
##Habitual Voting Behavior#
primaryHabitualj<-(((primaryIndParticipationj["0"])+(primaryIndParticipationj["7"]))/n) ## For consistent voters and abstainers#
primaryHabitualj#
#
## Plots#
## par(mfrow=c(2,2))#
## barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
## plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes", col="Red")#
##par(new=T)#
## plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes", col="Blue")#
##par(new=F)#
#
sum(actions)#
primaryVoteSumsj[7]#
#
votematrixi<- list(votematrixi, actions)#
habitmatrixi<- list(habitmatrixi, primaryHabitualj)#
#
}#
#
primaryVoteFramei <- data.frame(matrix(unlist(list(votematrixi)), nrow=nSims, byrow=FALSE))  ## Extracts data from matrix#
primaryVoteMeansi<-colMeans(primaryVoteFramei) ## Vote Mean for nSims#
primaryVoteMeansi
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-10 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
votematrixi<-matrix(nrow=(0), ncol=(0))#
habitmatrixi<-matrix(nrow=(0), ncol=(0))#
#
for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
#
## This section is for inner J loop only #
##Primary Election Data for j Periods#
primaryVoteFramej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primaryVoteSumsj<- colSums(primaryVoteFramej) ## Participation in Primary#
primaryVoteMeansj<- colMeans(primaryVoteFramej) ## Participation Rate#
## primaryVoteMeansj#
nPeriodthPrimaryMeanj<-primaryVoteMeansj[7]#
nPeriodthPrimaryMeanj#
#
primaryIndVotesj<-rowSums(primaryVoteFramej) ## Individual Participation by number of votes#
primaryIndParticipationj<-table(primaryIndVotesj) ## Summary of number of times respondents voted (mode)#
primaryIndParticipationj#
## barplot(primaryIndParticipationj, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
electionsj<-c(1:nPeriods)#
## meanparticipationj<-(voteRts+voteDts)/2 ## For each of nPeriods#
#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## Voting rate for last election only#
#
##Habitual Voting Behavior#
primaryHabitualj<-(((primaryIndParticipationj["0"])+(primaryIndParticipationj["7"]))/n) ## For consistent voters and abstainers#
primaryHabitualj#
#
## Plots#
## par(mfrow=c(2,2))#
## barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
## plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes", col="Red")#
##par(new=T)#
## plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes", col="Blue")#
##par(new=F)#
#
sum(actions)#
primaryVoteSumsj[7]#
#
votematrixi<- list(votematrixi, actions)#
habitmatrixi<- list(habitmatrixi, primaryHabitualj)#
#
}#
#
primaryVoteFramei <- data.frame(matrix(unlist(list(votematrixi)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primaryVoteMeansi<-colMeans(primaryVoteFramei) ## Vote Mean for nSims#
primaryVoteMeansi
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-10 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
votematrixi<-matrix(nrow=(0), ncol=(0))#
habitmatrixi<-matrix(nrow=(0), ncol=(0))#
#
for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
#
## This section is for inner J loop only #
##Primary Election Data for j Periods#
primaryVoteFramej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primaryVoteSumsj<- colSums(primaryVoteFramej) ## Participation in Primary#
primaryVoteMeansj<- colMeans(primaryVoteFramej) ## Participation Rate#
## primaryVoteMeansj#
nPeriodthPrimaryMeanj<-primaryVoteMeansj[7]#
nPeriodthPrimaryMeanj#
#
primaryIndVotesj<-rowSums(primaryVoteFramej) ## Individual Participation by number of votes#
primaryIndParticipationj<-table(primaryIndVotesj) ## Summary of number of times respondents voted (mode)#
primaryIndParticipationj#
## barplot(primaryIndParticipationj, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
electionsj<-c(1:nPeriods)#
## meanparticipationj<-(voteRts+voteDts)/2 ## For each of nPeriods#
#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## Voting rate for last election only#
#
##Habitual Voting Behavior#
primaryHabitualj<-(((primaryIndParticipationj["0"])+(primaryIndParticipationj["7"]))/n) ## For consistent voters and abstainers#
primaryHabitualj#
#
## Plots#
## par(mfrow=c(2,2))#
## barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
## plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes", col="Red")#
##par(new=T)#
## plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes", col="Blue")#
##par(new=F)#
#
sum(actions)#
primaryVoteSumsj[7]#
#
votematrixi<- list(votematrixi, actions)#
habitmatrixi<- list(habitmatrixi, primaryHabitualj)#
#
}#
#
primaryVoteFramei <- data.frame(matrix(unlist(list(votematrixi)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primaryVoteMeansi<-colMeans(primaryVoteFramei) ## Vote Mean for each in nSims#
primaryVoteMeansi#
overallPrimaryMean<-rowMeans(primaryVoteMeansi)
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-10 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
votematrixi<-matrix(nrow=(0), ncol=(0))#
habitmatrixi<-matrix(nrow=(0), ncol=(0))#
#
for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
#
## This section is for inner J loop only #
##Primary Election Data for j Periods#
primaryVoteFramej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primaryVoteSumsj<- colSums(primaryVoteFramej) ## Participation in Primary#
primaryVoteMeansj<- colMeans(primaryVoteFramej) ## Participation Rate#
## primaryVoteMeansj#
nPeriodthPrimaryMeanj<-primaryVoteMeansj[7]#
nPeriodthPrimaryMeanj#
#
primaryIndVotesj<-rowSums(primaryVoteFramej) ## Individual Participation by number of votes#
primaryIndParticipationj<-table(primaryIndVotesj) ## Summary of number of times respondents voted (mode)#
primaryIndParticipationj#
## barplot(primaryIndParticipationj, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
electionsj<-c(1:nPeriods)#
## meanparticipationj<-(voteRts+voteDts)/2 ## For each of nPeriods#
#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## Voting rate for last election only#
#
##Habitual Voting Behavior#
primaryHabitualj<-(((primaryIndParticipationj["0"])+(primaryIndParticipationj["7"]))/n) ## For consistent voters and abstainers#
primaryHabitualj#
#
## Plots#
## par(mfrow=c(2,2))#
## barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
## plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes", col="Red")#
##par(new=T)#
## plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes", col="Blue")#
##par(new=F)#
#
sum(actions)#
primaryVoteSumsj[7]#
#
votematrixi<- list(votematrixi, actions)#
habitmatrixi<- list(habitmatrixi, primaryHabitualj)#
#
}#
#
primaryVoteFramei <- data.frame(matrix(unlist(list(votematrixi)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primaryVoteMeansi<-colMeans(primaryVoteFramei) ## Vote Mean for each in nSims#
primaryVoteMeansi#
overallPrimaryMean<-Mean(primaryVoteMeansi)
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-10 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
votematrixi<-matrix(nrow=(0), ncol=(0))#
habitmatrixi<-matrix(nrow=(0), ncol=(0))#
#
for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
#
## This section is for inner J loop only #
##Primary Election Data for j Periods#
primaryVoteFramej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primaryVoteSumsj<- colSums(primaryVoteFramej) ## Participation in Primary#
primaryVoteMeansj<- colMeans(primaryVoteFramej) ## Participation Rate#
## primaryVoteMeansj#
nPeriodthPrimaryMeanj<-primaryVoteMeansj[7]#
nPeriodthPrimaryMeanj#
#
primaryIndVotesj<-rowSums(primaryVoteFramej) ## Individual Participation by number of votes#
primaryIndParticipationj<-table(primaryIndVotesj) ## Summary of number of times respondents voted (mode)#
primaryIndParticipationj#
## barplot(primaryIndParticipationj, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
electionsj<-c(1:nPeriods)#
## meanparticipationj<-(voteRts+voteDts)/2 ## For each of nPeriods#
#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## Voting rate for last election only#
#
##Habitual Voting Behavior#
primaryHabitualj<-(((primaryIndParticipationj["0"])+(primaryIndParticipationj["7"]))/n) ## For consistent voters and abstainers#
primaryHabitualj#
#
## Plots#
## par(mfrow=c(2,2))#
## barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
## plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes", col="Red")#
##par(new=T)#
## plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes", col="Blue")#
##par(new=F)#
#
sum(actions)#
primaryVoteSumsj[7]#
#
votematrixi<- list(votematrixi, actions)#
habitmatrixi<- list(habitmatrixi, primaryHabitualj)#
#
}#
#
primaryVoteFramei <- data.frame(matrix(unlist(list(votematrixi)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primaryVoteMeansi<-colMeans(primaryVoteFramei) ## Vote Mean for each in nSims#
primaryVoteMeansi#
overallPrimaryMean<-mean(primaryVoteMeansi)
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-10 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
votematrixi<-matrix(nrow=(0), ncol=(0))#
habitmatrixi<-matrix(nrow=(0), ncol=(0))#
#
for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
#
## This section is for inner J loop only #
##Primary Election Data for j Periods#
primaryVoteFramej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primaryVoteSumsj<- colSums(primaryVoteFramej) ## Participation in Primary#
primaryVoteMeansj<- colMeans(primaryVoteFramej) ## Participation Rate#
## primaryVoteMeansj#
nPeriodthPrimaryMeanj<-primaryVoteMeansj[7]#
nPeriodthPrimaryMeanj#
#
primaryIndVotesj<-rowSums(primaryVoteFramej) ## Individual Participation by number of votes#
primaryIndParticipationj<-table(primaryIndVotesj) ## Summary of number of times respondents voted (mode)#
primaryIndParticipationj#
## barplot(primaryIndParticipationj, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
electionsj<-c(1:nPeriods)#
## meanparticipationj<-(voteRts+voteDts)/2 ## For each of nPeriods#
#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## Voting rate for last election only#
#
##Habitual Voting Behavior#
primaryHabitualj<-(((primaryIndParticipationj["0"])+(primaryIndParticipationj["7"]))/n) ## For consistent voters and abstainers#
primaryHabitualj#
#
## Plots#
## par(mfrow=c(2,2))#
## barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
## plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes", col="Red")#
##par(new=T)#
## plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes", col="Blue")#
##par(new=F)#
#
sum(actions)#
primaryVoteSumsj[7]#
#
votematrixi<- list(votematrixi, actions)#
habitmatrixi<- list(habitmatrixi, primaryHabitualj)#
#
}#
#
primaryVoteFramei <- data.frame(matrix(unlist(list(votematrixi)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primaryVoteMeansi<-colMeans(primaryVoteFramei) ## Vote Mean for each in nSims#
primaryVoteMeansi#
overallPrimaryMean<-mean(primaryVoteMeansi)#
overallPrimaryMean
votematrixi
actions
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-10 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
votematrixi<-matrix(nrow=(0), ncol=(0))#
habitmatrixi<-matrix(nrow=(0), ncol=(0))#
#
for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
#
## This section is for inner J loop only #
##Primary Election Data for j Periods#
primaryVoteFramej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primaryVoteSumsj<- colSums(primaryVoteFramej) ## Participation in Primary#
primaryVoteMeansj<- colMeans(primaryVoteFramej) ## Participation Rate#
## primaryVoteMeansj#
nPeriodthPrimaryMeanj<-primaryVoteMeansj[7]#
nPeriodthPrimaryMeanj#
#
primaryIndVotesj<-rowSums(primaryVoteFramej) ## Individual Participation by number of votes#
primaryIndParticipationj<-table(primaryIndVotesj) ## Summary of number of times respondents voted (mode)#
primaryIndParticipationj#
## barplot(primaryIndParticipationj, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
electionsj<-c(1:nPeriods)#
## meanparticipationj<-(voteRts+voteDts)/2 ## For each of nPeriods#
#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## Voting rate for last election only#
#
##Habitual Voting Behavior#
primaryHabitualj<-(((primaryIndParticipationj["0"])+(primaryIndParticipationj["7"]))/n) ## For consistent voters and abstainers#
primaryHabitualj#
#
## Plots#
## par(mfrow=c(2,2))#
## barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
## plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes", col="Red")#
##par(new=T)#
## plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes", col="Blue")#
##par(new=F)#
#
sum(actions)#
primaryVoteSumsj[7]#
#
votematrixi<- list(votematrixi, actions)#
habitmatrixi<- list(habitmatrixi, primaryHabitualj)#
#
}#
#
primaryVoteFramei <- data.frame(matrix(unlist(list(votematrixi)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primaryVoteMeansi<-colMeans(primaryVoteFramei) ## Vote Mean for each in nSims#
primaryVoteMeansi#
overallPrimaryMean<-mean(primaryVoteMeansi) ## Mean for nPeriodth in nSims#
overallPrimaryMean
habitmatrixi
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-10 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
votematrixi<-matrix(nrow=(0), ncol=(0))#
habitmatrixi<-matrix(nrow=(0), ncol=(0))#
#
for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
#
## This section is for inner J loop only #
##Primary Election Data for j Periods#
primaryVoteFramej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primaryVoteSumsj<- colSums(primaryVoteFramej) ## Participation in Primary#
primaryVoteMeansj<- colMeans(primaryVoteFramej) ## Participation Rate#
## primaryVoteMeansj#
nPeriodthPrimaryMeanj<-primaryVoteMeansj[7]#
nPeriodthPrimaryMeanj#
#
primaryIndVotesj<-rowSums(primaryVoteFramej) ## Individual Participation by number of votes#
primaryIndParticipationj<-table(primaryIndVotesj) ## Summary of number of times respondents voted (mode)#
primaryIndParticipationj#
## barplot(primaryIndParticipationj, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
electionsj<-c(1:nPeriods)#
## meanparticipationj<-(voteRts+voteDts)/2 ## For each of nPeriods#
#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## Voting rate for last election only#
#
##Habitual Voting Behavior#
primaryHabitualj<-(((primaryIndParticipationj["0"])+(primaryIndParticipationj["7"]))/n) ## For consistent voters and abstainers#
primaryHabitualj#
#
## Plots#
## par(mfrow=c(2,2))#
## barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
## plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes", col="Red")#
##par(new=T)#
## plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes", col="Blue")#
##par(new=F)#
#
sum(actions)#
primaryVoteSumsj[7]#
#
votematrixi<- list(votematrixi, actions)#
habitmatrixi<- list(habitmatrixi, primaryHabitualj)#
#
}#
#
primaryVoteFramei <- data.frame(matrix(unlist(list(votematrixi)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primaryVoteMeansi<-colMeans(primaryVoteFramei) ## Vote Mean for each in nSims#
primaryVoteMeansi#
overallPrimaryMean<-mean(primaryVoteMeansi) ## Mean for nPeriodth in nSims#
overallPrimaryMean#
#
primaryHabitFramei <- data.frame(matrix(unlist(list(habitmatrixi)), nrow=nSims, byrow=FALSE))  ## Extracts data from matrix
primaryHabitFramei
colMeans(primaryHabitFramei)
ls()
load("/Users/jg/Dropbox/Active USF/698 Genetics/Genetic Research/FowlerRworkspace")
ls()
actions
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-10 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
votematrixi<-matrix(nrow=(0), ncol=(0))#
habitmatrixi<-matrix(nrow=(0), ncol=(0))#
#
for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
#
## This section is for inner J loop only #
##Primary Election Data for j Periods#
primaryVoteFramej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primaryVoteSumsj<- colSums(primaryVoteFramej) ## Participation in Primary#
primaryVoteMeansj<- colMeans(primaryVoteFramej) ## Participation Rate#
## primaryVoteMeansj#
nPeriodthPrimaryMeanj<-primaryVoteMeansj[7]#
nPeriodthPrimaryMeanj#
#
primaryIndVotesj<-rowSums(primaryVoteFramej) ## Individual Participation by number of votes#
primaryIndParticipationj<-table(primaryIndVotesj) ## Summary of number of times respondents voted (mode)#
primaryIndParticipationj#
## barplot(primaryIndParticipationj, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
electionsj<-c(1:nPeriods)#
## meanparticipationj<-(voteRts+voteDts)/2 ## For each of nPeriods#
#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## Voting rate for last election only#
#
##Habitual Voting Behavior#
primaryHabitualj<-(((primaryIndParticipationj["0"])+(primaryIndParticipationj["7"]))/n) ## For consistent voters and abstainers#
primaryHabitualj#
#
## Plots#
## par(mfrow=c(2,2))#
## barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
## plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes", col="Red")#
##par(new=T)#
## plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes", col="Blue")#
##par(new=F)#
#
sum(actions)#
primaryVoteSumsj[7]#
#
votematrixi<- list(votematrixi, actions)#
habitmatrixi<- list(habitmatrixi, primaryHabitualj)#
#
}#
#
primaryVoteFramei <- data.frame(matrix(unlist(list(votematrixi)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primaryVoteMeansi<-colMeans(primaryVoteFramei) ## Vote Mean for each in nSims#
primaryVoteMeansi#
overallPrimaryMean<-mean(primaryVoteMeansi) ## Mean for nPeriodth in nSims#
overallPrimaryMean#
#
primaryHabitFramei <- data.frame(matrix(unlist(list(habitmatrixi)), nrow=nSims, byrow=FALSE))  ## Extracts data from matrix#
overallPrimaryHabitBehavior<- colMeans(primaryHabitFramei) ## Habitual Behavior for nPeriodth in nSims#
overallPrimaryHabitBehavior
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-10 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
votematrixi<-matrix(nrow=(0), ncol=(0))#
habitmatrixi<-matrix(nrow=(0), ncol=(0))#
#
for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
#
## This section is for inner J loop only #
##Primary Election Data for j Periods#
primaryVoteFramej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primaryVoteSumsj<- colSums(primaryVoteFramej) ## Participation in Primary#
primaryVoteMeansj<- colMeans(primaryVoteFramej) ## Participation Rate#
## primaryVoteMeansj#
nPeriodthPrimaryMeanj<-primaryVoteMeansj[7]#
nPeriodthPrimaryMeanj#
#
primaryIndVotesj<-rowSums(primaryVoteFramej) ## Individual Participation by number of votes#
primaryIndParticipationj<-table(primaryIndVotesj) ## Summary of number of times respondents voted (mode)#
primaryIndParticipationj#
## barplot(primaryIndParticipationj, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
electionsj<-c(1:nPeriods)#
## meanparticipationj<-(voteRts+voteDts)/2 ## For each of nPeriods#
#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## Voting rate for last election only#
#
##Habitual Voting Behavior#
primaryHabitualj<-(((primaryIndParticipationj["0"])+(primaryIndParticipationj["7"]))/n) ## For consistent voters and abstainers#
primaryHabitualj#
#
## Plots#
 par(mfrow=c(2,2))#
 barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
 plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes", col="Red")#
##par(new=T)#
 plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes", col="Blue")#
##par(new=F)#
#
sum(actions)#
primaryVoteSumsj[7]#
#
votematrixi<- list(votematrixi, actions)#
habitmatrixi<- list(habitmatrixi, primaryHabitualj)#
#
}#
#
primaryVoteFramei <- data.frame(matrix(unlist(list(votematrixi)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primaryVoteMeansi<-colMeans(primaryVoteFramei) ## Vote Mean for each in nSims#
primaryVoteMeansi#
overallPrimaryMean<-mean(primaryVoteMeansi) ## Mean for nPeriodth in nSims#
overallPrimaryMean#
#
primaryHabitFramei <- data.frame(matrix(unlist(list(habitmatrixi)), nrow=nSims, byrow=FALSE))  ## Extracts data from matrix#
overallPrimaryHabitBehavior<- colMeans(primaryHabitFramei) ## Habitual Behavior for nPeriodth in nSims#
overallPrimaryHabitBehavior
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-10 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
votematrixi<-matrix(nrow=(0), ncol=(0))#
habitmatrixi<-matrix(nrow=(0), ncol=(0))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
#
## This section is for inner J loop only #
##Primary Election Data for j Periods#
primaryVoteFramej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primaryVoteSumsj<- colSums(primaryVoteFramej) ## Participation in Primary#
primaryVoteMeansj<- colMeans(primaryVoteFramej) ## Participation Rate#
## primaryVoteMeansj#
nPeriodthPrimaryMeanj<-primaryVoteMeansj[7]#
nPeriodthPrimaryMeanj#
#
primaryIndVotesj<-rowSums(primaryVoteFramej) ## Individual Participation by number of votes#
primaryIndParticipationj<-table(primaryIndVotesj) ## Summary of number of times respondents voted (mode)#
primaryIndParticipationj#
## barplot(primaryIndParticipationj, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
electionsj<-c(1:nPeriods)#
## meanparticipationj<-(voteRts+voteDts)/2 ## For each of nPeriods#
#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## Voting rate for last election only#
#
##Habitual Voting Behavior#
primaryHabitualj<-(((primaryIndParticipationj["0"])+(primaryIndParticipationj["7"]))/n) ## For consistent voters and abstainers#
primaryHabitualj#
#
## Plots#
 par(mfrow=c(2,2))#
 barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
 plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes", col="Red")#
##par(new=T)#
 plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes", col="Blue")#
##par(new=F)#
#
sum(actions)#
primaryVoteSumsj[7]#
#
votematrixi<- list(votematrixi, actions)#
habitmatrixi<- list(habitmatrixi, primaryHabitualj)#
#
##}#
#
primaryVoteFramei <- data.frame(matrix(unlist(list(votematrixi)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primaryVoteMeansi<-colMeans(primaryVoteFramei) ## Vote Mean for each in nSims#
primaryVoteMeansi#
overallPrimaryMean<-mean(primaryVoteMeansi) ## Mean for nPeriodth in nSims#
overallPrimaryMean#
#
primaryHabitFramei <- data.frame(matrix(unlist(list(habitmatrixi)), nrow=nSims, byrow=FALSE))  ## Extracts data from matrix#
overallPrimaryHabitBehavior<- colMeans(primaryHabitFramei) ## Habitual Behavior for nPeriodth in nSims#
overallPrimaryHabitBehavior
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-10 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
votematrixi<-matrix(nrow=(0), ncol=(0))#
habitmatrixi<-matrix(nrow=(0), ncol=(0))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
#
## This section is for inner J loop only #
##Primary Election Data for j Periods#
primaryVoteFramej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primaryVoteSumsj<- colSums(primaryVoteFramej) ## Participation in Primary#
primaryVoteMeansj<- colMeans(primaryVoteFramej) ## Participation Rate#
## primaryVoteMeansj#
nPeriodthPrimaryMeanj<-primaryVoteMeansj[7]#
nPeriodthPrimaryMeanj#
#
primaryIndVotesj<-rowSums(primaryVoteFramej) ## Individual Participation by number of votes#
primaryIndParticipationj<-table(primaryIndVotesj) ## Summary of number of times respondents voted (mode)#
primaryIndParticipationj#
## barplot(primaryIndParticipationj, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
electionsj<-c(1:nPeriods)#
## meanparticipationj<-(voteRts+voteDts)/2 ## For each of nPeriods#
#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## Voting rate for last election only#
#
##Habitual Voting Behavior#
primaryHabitualj<-(((primaryIndParticipationj["0"])+(primaryIndParticipationj["7"]))/n) ## For consistent voters and abstainers#
primaryHabitualj#
#
## Plots#
 par(mfrow=c(2,2))#
 barplot(primaryIndParticipationj, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
 plot(electionsj, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes", col="Red")#
##par(new=T)#
 plot(electionsj, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes", col="Blue")#
##par(new=F)#
#
sum(actions)#
primaryVoteSumsj[7]#
#
votematrixi<- list(votematrixi, actions)#
habitmatrixi<- list(habitmatrixi, primaryHabitualj)#
#
##}#
#
primaryVoteFramei <- data.frame(matrix(unlist(list(votematrixi)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primaryVoteMeansi<-colMeans(primaryVoteFramei) ## Vote Mean for each in nSims#
primaryVoteMeansi#
overallPrimaryMean<-mean(primaryVoteMeansi) ## Mean for nPeriodth in nSims#
overallPrimaryMean#
#
primaryHabitFramei <- data.frame(matrix(unlist(list(habitmatrixi)), nrow=nSims, byrow=FALSE))  ## Extracts data from matrix#
overallPrimaryHabitBehavior<- colMeans(primaryHabitFramei) ## Habitual Behavior for nPeriodth in nSims#
overallPrimaryHabitBehavior
library(ggplot2)#
library(scales)#
#
##data(economics)#
##View(economics)#
#
scatterplot <- ggplot(economics,#
	aes(x=date, y= psavert)) +#
	geop_point() +#
	ggtitle("US Economic Time Series") +#
	xlab("Year") +#
	ylab("Personal Savings Rate")
library(ggplot2)#
library(scales)#
#
##data(economics)#
##View(economics)#
#
scatterplot <- ggplot(economics,#
	aes(x=date, y= psavert)) +#
	geom_point() +#
	ggtitle("US Economic Time Series") +#
	xlab("Year") +#
	ylab("Personal Savings Rate")
scatterplot
library(ggplot2)#
library(scales)#
#
##data(economics)#
##View(economics)#
#
scatterplot <- ggplot(economics,#
	aes(x=date, y= psavert)) +#
	geom_line() +#
	ggtitle("US Economic Time Series") +#
	xlab("Year") +#
	ylab("Personal Savings Rate")#
#
scatterplot
print(scatterplot)
library(ggplot2)#
library(scales)#
#
##data(economics)#
##View(economics)#
#
scatterplot <- ggplot(economics, aes(x=date, y= psavert)) + ##base#
	geom_line() +#
	ggtitle("US Economic Time Series") +#
	xlab("Year") +#
	ylab("Personal Savings Rate")#
#
print(scatterplot)#
#
help(geom_line)
scatterplot <- ggplot(economics, aes(x=date, y= psavert)) + ##base#
	geom_area() +#
	ggtitle("US Economic Time Series") +#
	xlab("Year") +#
	ylab("Personal Savings Rate")#
#
print(scatterplot)
library(ggplot2)#
library(scales)#
#
##data(economics)#
##View(economics)#
#
economics$year <- + as.POSIXlt(economics$date)$year#
economics$month <- + as.POSIXlt(economics$date)$mon#
#
p <- ggplot(subset(economics, year >= 2003), aes(x=date, y= psavert)) + ##base#
	geom_bar(stat="identity") +#
	ylim(-5,5)#
	ggtitle("US Economic Time Series") +#
	xlab("Year") +#
	ylab("Personal Savings Rate")#
print(p)#
#
##help(geom_line)
library(ggplot2)#
library(scales)#
#
##data(economics)#
##View(economics)#
#
economics$year <- + as.POSIXlt(economics$date)$year#
economics$month <- + as.POSIXlt(economics$date)$mon#
#
p <- ggplot(subset(economics, year >= 2003), aes(x=date, y= psavert)) + ##base#
	geom_bar(stat="identity") +#
	ylim(-5,5) +#
	ggtitle("US Economic Time Series") +#
	xlab("Year") +#
	ylab("Personal Savings Rate")#
print(p)#
#
##help(geom_line)
library(ggplot2)#
library(scales)#
#
##data(economics)#
##View(economics)#
#
economics$year <- 1900 + as.POSIXlt(economics$date)$year#
economics$mon <- 1 + as.POSIXlt(economics$date)$mon#
#
p <- ggplot(subset(economics, year >= 2003), aes(x=date, y= psavert)) + ##base#
	geom_bar(stat="identity") +#
	ylim(-5,5) +#
	ggtitle("US Economic Time Series") +#
	xlab("Year") +#
	ylab("Personal Savings Rate")#
print(p)#
#
##help(geom_line)
library(ggplot2)#
library(scales)#
#
##data(economics)#
##View(economics)#
#
economics$year <- 1900 + as.POSIXlt(economics$date)$year#
economics$mon <- 1 + as.POSIXlt(economics$date)$mon#
#
p <- ggplot(subset(economics, year <= 1990),#
	aes(x=factor(year), y= psavert)) + ##base#
	geom_bar(stat="identity") +#
	ylim(-5,5) +#
	ggtitle("US Economic Time Series") +#
	xlab("Year") +#
	ylab("Personal Savings Rate")#
#
print(p)#
#
##help(geom_line)
library(ggplot2)#
library(scales)#
#
##data(economics)#
##View(economics)#
#
economics$year <- 1900 + as.POSIXlt(economics$date)$year#
economics$mon <- 1 + as.POSIXlt(economics$date)$mon#
#
p <- ggplot(subset(economics, year <= 1990),#
	aes(x=factor(year), y= psavert)) + ##base#
	geom_boxplot() +#
	ylim(-5,5) +#
	ggtitle("US Economic Time Series") +#
	xlab("Year") +#
	ylab("Personal Savings Rate")#
#
print(p)#
#
##help(geom_line)
library(ggplot2)#
library(scales)#
#
##data(economics)#
##View(economics)#
#
economics$year <- 1900 + as.POSIXlt(economics$date)$year ##posix is date object#
economics$month <- 1 + as.POSIXlt(economics$date)$mon#
#
p <- ggplot(subset(economics, year <= 1990),#
	aes(x=factor(year), y= psavert)) + ##base#
	geom_bar(stat="identity") +#
	ylim(-5,5) +#
	ggtitle("US Economic Time Series") +#
	xlab("Year") +#
	ylab("Personal Savings Rate")#
#
print(p)#
#
##help(geom_line)
library(ggplot2)#
library(scales)#
#
##data(economics)#
##View(economics)#
#
economics$year <- 1900 + as.POSIXlt(economics$date)$year ##posix is date object#
economics$month <- 1 + as.POSIXlt(economics$date)$mon#
#
p <- ggplot(subset(economics, year %in% seq(1970, 2010, 5)),#
	aes(x=factor(year), y= psavert)) + ##base#
	geom_line(stat="identity") +#
	ylim(-5,5) +#
	ggtitle("US Economic Time Series") +#
	xlab("Year") +#
	ylab("Personal Savings Rate")#
#
print(p)#
#
##help(geom_line)
library(ggplot2)#
library(scales)#
#
##data(economics)#
##View(economics)#
#
economics$year <- 1900 + as.POSIXlt(economics$date)$year ##posix is date object#
economics$month <- 1 + as.POSIXlt(economics$date)$mon#
#
p <- ggplot(subset(economics, year %in% seq(1970, 2010, 5)),#
	aes(x=factor(month), y= psavert)) + ##base#
	geom_line() +#
	ylim(-5,5) +#
	ggtitle("US Economic Time Series") +#
	xlab("Year") +#
	ylab("Personal Savings Rate")#
#
print(p)#
#
##help(geom_line)
library(ggplot2)#
library(scales)#
#
##data(economics)#
##View(economics)#
#
economics$year <- 1900 + as.POSIXlt(economics$date)$year ##posix is date object#
economics$month <- 1 + as.POSIXlt(economics$date)$mon#
#
p <- ggplot(subset(economics, year %in% seq(1970, 2010, 5)),#
	aes(x=month, y= psavert)) + ##base#
	geom_line() +#
	ylim(-5,5) +#
	ggtitle("US Economic Time Series") +#
	xlab("Year") +#
	ylab("Personal Savings Rate")#
#
print(p)#
#
##help(geom_line)
library(ggplot2)#
library(scales)#
#
##data(economics)#
##View(economics)#
#
economics$year <- 1900 + as.POSIXlt(economics$date)$year ##posix is date object#
economics$month <- 1 + as.POSIXlt(economics$date)$mon#
#
d<-subset(economics, year %in% seq(1970, 2010, 5))#
#
p <- ggplot(d, #
	aes(x=month, y= psavert, #
	group = factor(year),#
	color = factor(year))) + ##base#
	geom_line() +#
	ylim(-5,5) +#
	ggtitle("US Economic Time Series") +#
	xlab("Year") +#
	ylab("Personal Savings Rate")#
#
print(p)#
#
##help(geom_line)
library(ggplot2)#
library(scales)#
#
##data(economics)#
##View(economics)#
#
economics$year <- 1900 + as.POSIXlt(economics$date)$year ##posix is date object#
economics$month <- 1 + as.POSIXlt(economics$date)$mon#
#
d<-subset(economics, year %in% seq(1970, 2010, 5))#
#
p <- ggplot(d, #
	aes(x=month, y= psavert, #
	group = factor(year),#
	color = factor(year))) + ##base#
	geom_line() +#
	ylim(-2,15) +#
	ggtitle("US Economic Time Series") +#
	xlab("Year") +#
	ylab("Personal Savings Rate")#
#
print(p)#
#
##help(geom_line)
library(ggplot2)#
library(scales)#
#
##data(economics)#
##View(economics)#
#
economics$year <- 1900 + as.POSIXlt(economics$date)$year ##posix is date object#
economics$month <- 1 + as.POSIXlt(economics$date)$mon#
#
d<-subset(economics, year %in% seq(1970, 2010, 5))#
#
p <- ggplot(d, #
	aes(x=month, y= psavert, #
	group = factor(year),#
	color = factor(year))) + ##base#
	geom_line() +#
	ylim(-5,15) +#
	ggtitle("US Economic Time Series") +#
	xlab("Year") +#
	ylab("Personal Savings Rate")#
#
print(p)#
#
##help(geom_line)
library(ggplot2)#
library(scales)#
#
##data(economics)#
##View(economics)#
#
economics$year <- 1900 + as.POSIXlt(economics$date)$year ##posix is date object#
economics$month <- 1 + as.POSIXlt(economics$date)$mon#
monthtext<- c("Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec")#
#
d<-subset(economics, year %in% seq(1970, 2010, 5))#
#
p <- ggplot(d, #
	aes(x=month, y= psavert, #
	group = factor(year),#
	color = factor(year))) + ##base#
	geom_line() +#
	ylim(-5,15) +#
	ggtitle("US Economic Time Series") +#
	xlab("Year") +#
	ylab("Personal Savings Rate")#
	scale_x_discrete(labels = monthtext)#
print(p)#
#
##help(geom_line)
library(ggplot2)#
library(scales)#
#
##data(economics)#
##View(economics)#
#
economics$year <- 1900 + as.POSIXlt(economics$date)$year ##posix is date object#
economics$month <- 1 + as.POSIXlt(economics$date)$mon#
monthtext<- c("Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec")#
#
d<-subset(economics, year %in% seq(1970, 2010, 5))#
#
p <- ggplot(d, #
	aes(x=month, y= psavert, #
	group = factor(year),#
	color = factor(year))) + ##base#
	geom_line() +#
	ylim(-5,15) +#
	ggtitle("US Economic Time Series") +#
	xlab("Year") +#
	ylab("Personal Savings Rate") +#
	scale_x_discrete(labels = monthtext) +#
	facet_wrap( ~year, ncol=3)#
#
print(p)#
#
##help(geom_line)
library(ggplot2)#
data(movies)#
data(EuStockMarkets)
movies
MSAN 622#
## Jeremy Gilmore#
## Homework 1#
#
library(ggplot2)#
data(movies)#
data(EuStockMarkets)#
#
## modify data: movies#
movies=movies[!(movies$budget<="0"),]#
genre <- rep(NA, nrow(movies))#
count <- rowSums(movies[, 18:24])#
genre[which(count > 1)] = "Mixed"#
genre[which(count < 1)] = "None"#
genre[which(count == 1 & movies$Action == 1)] = "Action"#
genre[which(count == 1 & movies$Animation == 1)] = "Animation"#
genre[which(count == 1 & movies$Comedy == 1)] = "Comedy"#
genre[which(count == 1 & movies$Drama == 1)] = "Drama"#
genre[which(count == 1 & movies$Documentary == 1)] = "Documentary"#
genre[which(count == 1 & movies$Romance == 1)] = "Romance"#
genre[which(count == 1 & movies$Short == 1)] = "Short"#
#
## modify data: EuStockMarkets#
eu <- transform(data.frame(EuStockMarkets), time = time(EuStockMarkets))
movies
MSAN 622#
## Jeremy Gilmore#
## Homework 1#
#
library(ggplot2)#
data(movies)#
data(EuStockMarkets)#
#
## modify data: movies#
movies=movies[(movies$budget<="0"),]#
##subset(dataframe, )#
genre <- rep(NA, nrow(movies))#
count <- rowSums(movies[, 18:24])#
genre[which(count > 1)] = "Mixed"#
genre[which(count < 1)] = "None"#
genre[which(count == 1 & movies$Action == 1)] = "Action"#
genre[which(count == 1 & movies$Animation == 1)] = "Animation"#
genre[which(count == 1 & movies$Comedy == 1)] = "Comedy"#
genre[which(count == 1 & movies$Drama == 1)] = "Drama"#
genre[which(count == 1 & movies$Documentary == 1)] = "Documentary"#
genre[which(count == 1 & movies$Romance == 1)] = "Romance"#
genre[which(count == 1 & movies$Short == 1)] = "Short"#
#
## modify data: EuStockMarkets#
eu <- transform(data.frame(EuStockMarkets), time = time(EuStockMarkets))
movies
MSAN 622#
## Jeremy Gilmore#
## Homework 1#
#
library(ggplot2)#
data(movies)#
data(EuStockMarkets)#
#
## modify data: movies#
movies=movies[!(movies$budget<=0),]#
##subset(dataframe, )#
genre <- rep(NA, nrow(movies))#
count <- rowSums(movies[, 18:24])#
genre[which(count > 1)] = "Mixed"#
genre[which(count < 1)] = "None"#
genre[which(count == 1 & movies$Action == 1)] = "Action"#
genre[which(count == 1 & movies$Animation == 1)] = "Animation"#
genre[which(count == 1 & movies$Comedy == 1)] = "Comedy"#
genre[which(count == 1 & movies$Drama == 1)] = "Drama"#
genre[which(count == 1 & movies$Documentary == 1)] = "Documentary"#
genre[which(count == 1 & movies$Romance == 1)] = "Romance"#
genre[which(count == 1 & movies$Short == 1)] = "Short"#
#
## modify data: EuStockMarkets#
eu <- transform(data.frame(EuStockMarkets), time = time(EuStockMarkets))
movies
library(ggplot2)#
data(movies)#
data(EuStockMarkets)
movies
movies=movies[!(movies$budget<=0 | movies$budget=="NA"),]
movies
MSAN 622#
## Jeremy Gilmore#
## Homework 1#
#
library(ggplot2)#
data(movies)#
data(EuStockMarkets)#
#
## modify data: movies#
movies=movies[(movies$budget>0),]#
##subset(dataframe, )#
genre <- rep(NA, nrow(movies))#
count <- rowSums(movies[, 18:24])#
genre[which(count > 1)] = "Mixed"#
genre[which(count < 1)] = "None"#
genre[which(count == 1 & movies$Action == 1)] = "Action"#
genre[which(count == 1 & movies$Animation == 1)] = "Animation"#
genre[which(count == 1 & movies$Comedy == 1)] = "Comedy"#
genre[which(count == 1 & movies$Drama == 1)] = "Drama"#
genre[which(count == 1 & movies$Documentary == 1)] = "Documentary"#
genre[which(count == 1 & movies$Romance == 1)] = "Romance"#
genre[which(count == 1 & movies$Short == 1)] = "Short"#
#
## modify data: EuStockMarkets#
eu <- transform(data.frame(EuStockMarkets), time = time(EuStockMarkets))
movies
library(ggplot2)#
data(movies)#
data(EuStockMarkets)
budget
movies$budget
MSAN 622#
## Jeremy Gilmore#
## Homework 1#
#
library(ggplot2)#
data(movies)#
data(EuStockMarkets)#
#
## modify data: movies#
##movies=movies[(movies$budget>0),]#
##subset(dataframe, )#
genre <- rep(NA, nrow(movies))#
count <- rowSums(movies[, 18:24])#
genre[which(count > 1)] = "Mixed"#
genre[which(count < 1)] = "None"#
genre[which(count == 1 & movies$Action == 1)] = "Action"#
genre[which(count == 1 & movies$Animation == 1)] = "Animation"#
genre[which(count == 1 & movies$Comedy == 1)] = "Comedy"#
genre[which(count == 1 & movies$Drama == 1)] = "Drama"#
genre[which(count == 1 & movies$Documentary == 1)] = "Documentary"#
genre[which(count == 1 & movies$Romance == 1)] = "Romance"#
genre[which(count == 1 & movies$Short == 1)] = "Short"#
#
## modify data: EuStockMarkets#
eu <- transform(data.frame(EuStockMarkets), time = time(EuStockMarkets))
budget
MSAN 622#
## Jeremy Gilmore#
## Homework 1#
#
library(ggplot2)#
data(movies)#
data(EuStockMarkets)#
#
setwd("/Users/jg/Documents/DataVis/msan622/homework1")#
#
## modify data: movies#
movies=movies[which(!movies$budget<=0),]#
genre <- rep(NA, nrow(movies))#
count <- rowSums(movies[, 18:24])#
genre[which(count > 1)] = "Mixed"#
genre[which(count < 1)] = "None"#
genre[which(count == 1 & movies$Action == 1)] = "Action"#
genre[which(count == 1 & movies$Animation == 1)] = "Animation"#
genre[which(count == 1 & movies$Comedy == 1)] = "Comedy"#
genre[which(count == 1 & movies$Drama == 1)] = "Drama"#
genre[which(count == 1 & movies$Documentary == 1)] = "Documentary"#
genre[which(count == 1 & movies$Romance == 1)] = "Romance"#
genre[which(count == 1 & movies$Short == 1)] = "Short"#
movies$genre<-genre#
movies$budget<-(movies$budget/1000000)#
movies$rndrating<-round(movies$rating/.1)*.1#
movies$rndbudget<-round(movies$budget/.1)*.1#
#
## modify data: EuStockMarkets#
eu <- transform(data.frame(EuStockMarkets), time = time(EuStockMarkets))#
#
## Plot 1: Scatterplot#
p.scatter <- ggplot(movies, #
	aes(x= rndbudget, y= rndrating,#
	colour=genre)) +#
	geom_point(alpha=.5, shape=20) +#
	scale_y_continuous(breaks=seq(0,10,1), labels=seq(0,10,1)) +#
	ggtitle("IMDB Movies Data") +#
	xlab("Budget in Millions of USD") +#
	ylab("Movie Ratings") +#
	labs(colour = "Genre")#
#
print(p.scatter)#
ggsave(p.scatter, file="hw1-scatter.png", width=6, height=6)#
## Plot 2: Bar Chart#
table.genre<-sort(table(genre))#
genre.rank<-as.vector(table.genre)#
genre.labels<-c("Animation", "Romance", "Documentary", "Short", "Action", "Comedy", "None", "Drama", "Mixed")#
movies$genre2<- factor(movies$genre, levels=genre.labels)#
#
p.bar <- ggplot(movies, #
	aes(x=genre2, fill=genre)) +#
	geom_bar(width=.75) +#
##	geom_text(aes(label=genre2, y=count)) +#
	theme(axis.text.x=element_text(angle=45)) +#
	ggtitle("IMDB Movies Data") +#
	xlab("Film Genre") +#
	ylab("Number of Films in Genre") +#
	labs(colour = "Genre")#
#
print(p.bar)#
ggsave(p.bar, file="hw1-bar.png", width=6, height=6)#
## Plot 3: Small Multiples#
p.small <- ggplot(movies, #
	aes(x=budget, y=rating,#
	group = genre,#
	color = genre)) +#
	geom_point(alpha=.6, shape=20) +#
	scale_y_continuous(breaks=seq(0,10,1), labels=seq(0,10,1)) +#
	ggtitle("IMDB Movies Data") +#
	xlab("Film Budget in Millions of USD") +#
	ylab("Ratings") +#
	facet_wrap( ~genre2, ncol=3) +#
	labs(colour = "Genre")#
#
print(p.small)#
ggsave(p.small, file="hw1-multiples.png", width=6, height=6)#
## Plot 4: Multi-Line Chart#
yeartext <- c("1991", "1992", "1993", "1994", "1995", "1996", "1997", "1998")#
DAX<-eu[1]#
SMI<-eu[2]#
CAC<-eu[3]#
FTSE<-eu[4]#
##index<- data.frame(eu[,1:4]) ## I wasn't sure which data-type to use.#
##eu$year<-trunc(eu$time, "day") ## The intent was to use for labels.#
#
p.multi <- ggplot(eu, #
	aes(eu$time)) +#
##	group = factor(index),#
##	color = factor(index))) +#
	geom_line(aes(y=DAX, colour = "DAX: Germany")) +#
	geom_line(aes(y=SMI, colour = "SMI: Switzerland")) +#
	geom_line(aes(y=CAC, colour = "CAC: France")) +#
	geom_line(aes(y=FTSE, colour = "FSTE: UK")) +#
	ggtitle("Daily EU Stock Market Performance (1991:1998)") +#
	xlab("") +#
	ylab("Performance") +#
	scale_x_continuous(breaks=seq(1991,1998, 1), labels = yeartext) +#
	scale_y_continuous(breaks=seq(2000,10000, 1000)) +#
	theme(legend.position=c(.25,.75)) +#
	labs(colour = "Index")#
#
print(p.multi)#
ggsave(p.multi, file="hw1-multiline.png", width=6, height=6)
MSAN 622#
## Jeremy Gilmore#
## Homework 1#
#
library(ggplot2)#
data(movies)#
data(EuStockMarkets)#
#
setwd("/Users/jg/Documents/DataVis/msan622/homework1")#
#
## modify data: movies#
movies=movies[which(!movies$budget<=0),]#
genre <- rep(NA, nrow(movies))#
count <- rowSums(movies[, 18:24])#
genre[which(count > 1)] = "Mixed"#
genre[which(count < 1)] = "None"#
genre[which(count == 1 & movies$Action == 1)] = "Action"#
genre[which(count == 1 & movies$Animation == 1)] = "Animation"#
genre[which(count == 1 & movies$Comedy == 1)] = "Comedy"#
genre[which(count == 1 & movies$Drama == 1)] = "Drama"#
genre[which(count == 1 & movies$Documentary == 1)] = "Documentary"#
genre[which(count == 1 & movies$Romance == 1)] = "Romance"#
genre[which(count == 1 & movies$Short == 1)] = "Short"#
movies$genre<-genre#
movies$budget<-(movies$budget/1000000)#
movies$rndrating<-round(movies$rating/.1)*.1#
movies$rndbudget<-round(movies$budget/.1)*.1#
#
## modify data: EuStockMarkets#
eu <- transform(data.frame(EuStockMarkets), time = time(EuStockMarkets))#
## Plot 1: Scatterplot#
p.scatter <- ggplot(movies, #
	aes(x= rndbudget, y= rndrating,#
	colour=genre)) +#
	geom_point(alpha=.5, shape=20) +#
	scale_y_continuous(breaks=seq(0,10,1), labels=seq(0,10,1)) +#
	ggtitle("IMDB Movies Data") +#
	xlab("Budget in Millions of USD") +#
	ylab("Movie Ratings") +#
	labs(colour = "Genre")#
#
print(p.scatter)#
ggsave(p.scatter, file="hw1-scatter.png", width=6, height=6)#
## Plot 2: Bar Chart#
table.genre<-sort(table(genre))#
genre.rank<-as.vector(table.genre)#
genre.labels<-c("Animation", "Romance", "Documentary", "Short", "Action", "Comedy", "None", "Drama", "Mixed")#
movies$genre2<- factor(movies$genre, levels=genre.labels)#
#
p.bar <- ggplot(movies, #
	aes(x=genre2, fill=genre)) +#
	geom_bar(width=.75) +#
##	geom_text(aes(label=genre2, y=count)) +#
	theme(axis.text.x=element_text(angle=45)) +#
	ggtitle("IMDB Movies Data") +#
	xlab("Film Genre") +#
	ylab("Number of Films in Genre") +#
	labs(colour = "Genre")#
#
print(p.bar)#
ggsave(p.bar, file="hw1-bar.png", width=6, height=6)#
## Plot 3: Small Multiples#
p.small <- ggplot(movies, #
	aes(x=budget, y=rating,#
	group = genre,#
	color = genre)) +#
	geom_point(alpha=.6, shape=20) +#
	scale_y_continuous(breaks=seq(0,10,1), labels=seq(0,10,1)) +#
	ggtitle("IMDB Movies Data") +#
	xlab("Film Budget in Millions of USD") +#
	ylab("Ratings") +#
	facet_wrap( ~genre2, ncol=3) +#
	labs(colour = "Genre")#
#
print(p.small)#
ggsave(p.small, file="hw1-multiples.png", width=6, height=6)#
## Plot 4: Multi-Line Chart#
yeartext <- c("1991", "1992", "1993", "1994", "1995", "1996", "1997", "1998")#
DAX<-eu[1]#
SMI<-eu[2]#
CAC<-eu[3]#
FTSE<-eu[4]#
##index<- data.frame(eu[,1:4]) ## I wasn't sure which data-type to use.#
##eu$year<-trunc(eu$time, "day") ## The intent was to use for labels.#
#
p.multi <- ggplot(eu, #
	aes(eu$time)) +#
##	group = factor(index),#
##	color = factor(index))) +#
	geom_line(aes(y=DAX, colour = "DAX: Germany")) +#
	geom_line(aes(y=SMI, colour = "SMI: Switzerland")) +#
	geom_line(aes(y=CAC, colour = "CAC: France")) +#
	geom_line(aes(y=FTSE, colour = "FSTE: UK")) +#
	ggtitle("Daily EU Stock Market Performance (1991:1998)") +#
	xlab("") +#
	ylab("Performance") +#
	scale_x_continuous(breaks=seq(1991,1998, 1), labels = yeartext) +#
	scale_y_continuous(breaks=seq(2000,10000, 1000)) +#
	theme(legend.position=c(.25,.75)) +#
	labs(colour = "Index")#
#
print(p.multi)#
ggsave(p.multi, file="hw1-multiline.png", width=6, height=6)
MSAN 622#
## Jeremy Gilmore#
## Homework 1#
#
library(ggplot2)#
data(movies)#
data(EuStockMarkets)#
#
setwd("/Users/jg/Documents/DataVis/msan622/homework1")#
#
## modify data: movies#
movies=movies[which(!movies$budget<=0),]#
genre <- rep(NA, nrow(movies))#
count <- rowSums(movies[, 18:24])#
genre[which(count > 1)] = "Mixed"#
genre[which(count < 1)] = "None"#
genre[which(count == 1 & movies$Action == 1)] = "Action"#
genre[which(count == 1 & movies$Animation == 1)] = "Animation"#
genre[which(count == 1 & movies$Comedy == 1)] = "Comedy"#
genre[which(count == 1 & movies$Drama == 1)] = "Drama"#
genre[which(count == 1 & movies$Documentary == 1)] = "Documentary"#
genre[which(count == 1 & movies$Romance == 1)] = "Romance"#
genre[which(count == 1 & movies$Short == 1)] = "Short"#
movies$genre<-genre#
movies$budget<-(movies$budget/1000000)#
movies$rndrating<-round(movies$rating/.1)*.1#
movies$rndbudget<-round(movies$budget/.1)*.1#
#
## modify data: EuStockMarkets#
eu <- transform(data.frame(EuStockMarkets), time = time(EuStockMarkets))#
## Plot 1: Scatterplot#
p.scatter <- ggplot(movies, #
	aes(x= rndbudget, y= rndrating,#
	colour=genre)) +#
	geom_point(alpha=.5, shape=20) +#
	scale_y_continuous(breaks=seq(0,10,1), labels=seq(0,10,1)) +#
	ggtitle("IMDB Movies Data") +#
	xlab("Budget in Millions of USD") +#
	ylab("Movie Ratings") +#
	labs(colour = "Genre")#
#
print(p.scatter)#
ggsave(p.scatter, file="hw1-scatter.png", width=6, height=6)#
## Plot 2: Bar Chart#
table.genre<-sort(table(genre))#
genre.rank<-as.vector(table.genre)#
genre.labels<-c("Animation", "Romance", "Documentary", "Short", "Action", "Comedy", "None", "Drama", "Mixed")#
movies$genre2<- factor(movies$genre, levels=genre.labels)#
#
p.bar <- ggplot(movies, #
	aes(x=genre2, fill=genre)) +#
	geom_bar(width=.75) +#
##	geom_text(aes(label=genre2, y=count)) + ## eventually add bar labels#
	theme(axis.text.x=element_text(angle=45)) +#
	ggtitle("IMDB Movies Data") +#
	xlab("Film Genre") +#
	ylab("Number of Films in Genre") +#
	labs(colour = "Genre")#
#
print(p.bar)#
ggsave(p.bar, file="hw1-bar.png", width=6, height=6)#
## Plot 3: Small Multiples#
p.small <- ggplot(movies, #
	aes(x=budget, y=rating,#
	group = genre,#
	color = genre)) +#
	geom_point(alpha=.6, shape=20) +#
	scale_y_continuous(breaks=seq(0,10,1), labels=seq(0,10,1)) +#
	ggtitle("IMDB Movies Data") +#
	xlab("Film Budget in Millions of USD") +#
	ylab("Ratings") +#
	facet_wrap( ~genre2, ncol=3) +#
	labs(colour = "Genre")#
#
print(p.small)#
ggsave(p.small, file="hw1-multiples.png", width=6, height=6)#
## Plot 4: Multi-Line Chart#
yeartext <- c("1991", "1992", "1993", "1994", "1995", "1996", "1997", "1998")#
DAX<-eu[1]#
SMI<-eu[2]#
CAC<-eu[3]#
FTSE<-eu[4]#
##index<- data.frame(eu[,1:4]) ## I wasn't sure which data-type to use.#
##eu$year<-trunc(eu$time, "day") ## The intent was to use for labels.#
#
p.multi <- ggplot(eu, #
	aes(eu$time)) +#
##	group = factor(index),#
##	color = factor(index))) +#
	geom_line(aes(y=DAX, colour = "DAX: Germany")) +#
	geom_line(aes(y=SMI, colour = "SMI: Switzerland")) +#
	geom_line(aes(y=CAC, colour = "CAC: France")) +#
	geom_line(aes(y=FTSE, colour = "FSTE: UK")) +#
	ggtitle("Daily EU Stock Market Performance (1991:1998)") +#
	xlab("") +#
	ylab("Performance") +#
	scale_x_continuous(breaks=seq(1991,1998, 1), labels = yeartext) +#
	scale_y_continuous(breaks=seq(2000,10000, 1000)) +#
	theme(legend.position=c(.25,.75)) +#
	labs(colour = "Index")#
#
print(p.multi)#
ggsave(p.multi, file="hw1-multiline.png", width=6, height=6)
MSAN 622#
## Jeremy Gilmore#
## Homework 1#
#
library(ggplot2)#
data(movies)#
data(EuStockMarkets)#
#
setwd("/Users/jg/Documents/DataVis/msan622/homework1")#
#
## modify data: movies#
movies=movies[which(!movies$budget<=0),]#
genre <- rep(NA, nrow(movies))#
count <- rowSums(movies[, 18:24])#
genre[which(count > 1)] = "Mixed"#
genre[which(count < 1)] = "None"#
genre[which(count == 1 & movies$Action == 1)] = "Action"#
genre[which(count == 1 & movies$Animation == 1)] = "Animation"#
genre[which(count == 1 & movies$Comedy == 1)] = "Comedy"#
genre[which(count == 1 & movies$Drama == 1)] = "Drama"#
genre[which(count == 1 & movies$Documentary == 1)] = "Documentary"#
genre[which(count == 1 & movies$Romance == 1)] = "Romance"#
genre[which(count == 1 & movies$Short == 1)] = "Short"#
movies$genre<-genre#
movies$budget<-(movies$budget/1000000)#
movies$rndrating<-round(movies$rating/.1)*.1#
movies$rndbudget<-round(movies$budget/.1)*.1#
#
## modify data: EuStockMarkets#
eu <- transform(data.frame(EuStockMarkets), time = time(EuStockMarkets))#
## Plot 1: Scatterplot#
p.scatter <- ggplot(movies, #
	aes(x= rndbudget, y= rndrating,#
	colour=genre)) +#
	geom_point(alpha=.5, shape=20) +#
	scale_y_continuous(breaks=seq(0,10,1), labels=seq(0,10,1)) +#
	ggtitle("IMDB Movies Data") +#
	xlab("Budget in Millions of USD") +#
	ylab("Movie Ratings") +#
	labs(colour = "Genre")#
#
print(p.scatter)#
ggsave(p.scatter, file="hw1-scatter.png", width=6, height=6)#
## Plot 2: Bar Chart#
table.genre<-sort(table(genre))#
genre.rank<-as.vector(table.genre)#
genre.labels<-c("Animation", "Romance", "Documentary", "Short", "Action", "Comedy", "None", "Drama", "Mixed")#
movies$genre2<- factor(movies$genre, levels=genre.labels)#
#
p.bar <- ggplot(movies, #
	aes(x=genre2, fill=genre, labs="Genre")) +#
	geom_bar(width=.75) +#
##	geom_text(aes(label=genre2, y=count)) + ## eventually add bar labels#
	theme(axis.text.x=element_text(angle=45)) +#
	ggtitle("IMDB Movies Data") +#
	xlab("Film Genre") +#
	ylab("Number of Films in Genre") +#
	labs(colour = "Genre")#
#
print(p.bar)#
ggsave(p.bar, file="hw1-bar.png", width=6, height=6)#
## Plot 3: Small Multiples#
p.small <- ggplot(movies, #
	aes(x=budget, y=rating,#
	group = genre,#
	color = genre)) +#
	geom_point(alpha=.6, shape=20) +#
	scale_y_continuous(breaks=seq(0,10,1), labels=seq(0,10,1)) +#
	ggtitle("IMDB Movies Data") +#
	xlab("Film Budget in Millions of USD") +#
	ylab("Ratings") +#
	facet_wrap( ~genre2, ncol=3) +#
	labs(colour = "Genre")#
#
print(p.small)#
ggsave(p.small, file="hw1-multiples.png", width=6, height=6)#
## Plot 4: Multi-Line Chart#
yeartext <- c("1991", "1992", "1993", "1994", "1995", "1996", "1997", "1998")#
DAX<-eu[1]#
SMI<-eu[2]#
CAC<-eu[3]#
FTSE<-eu[4]#
##index<- data.frame(eu[,1:4]) ## I wasn't sure which data-type to use.#
##eu$year<-trunc(eu$time, "day") ## The intent was to use for labels.#
#
p.multi <- ggplot(eu, #
	aes(eu$time)) +#
##	group = factor(index),#
##	color = factor(index))) +#
	geom_line(aes(y=DAX, colour = "DAX: Germany")) +#
	geom_line(aes(y=SMI, colour = "SMI: Switzerland")) +#
	geom_line(aes(y=CAC, colour = "CAC: France")) +#
	geom_line(aes(y=FTSE, colour = "FSTE: UK")) +#
	ggtitle("Daily EU Stock Market Performance (1991:1998)") +#
	xlab("") +#
	ylab("Performance") +#
	scale_x_continuous(breaks=seq(1991,1998, 1), labels = yeartext) +#
	scale_y_continuous(breaks=seq(2000,10000, 1000)) +#
	theme(legend.position=c(.25,.75)) +#
	labs(colour = "Index")#
#
print(p.multi)#
ggsave(p.multi, file="hw1-multiline.png", width=6, height=6)
MSAN 622#
## Jeremy Gilmore#
## Homework 1#
#
library(ggplot2)#
data(movies)#
data(EuStockMarkets)#
#
setwd("/Users/jg/Documents/DataVis/msan622/homework1")#
#
## modify data: movies#
movies=movies[which(!movies$budget<=0),]#
genre <- rep(NA, nrow(movies))#
count <- rowSums(movies[, 18:24])#
genre[which(count > 1)] = "Mixed"#
genre[which(count < 1)] = "None"#
genre[which(count == 1 & movies$Action == 1)] = "Action"#
genre[which(count == 1 & movies$Animation == 1)] = "Animation"#
genre[which(count == 1 & movies$Comedy == 1)] = "Comedy"#
genre[which(count == 1 & movies$Drama == 1)] = "Drama"#
genre[which(count == 1 & movies$Documentary == 1)] = "Documentary"#
genre[which(count == 1 & movies$Romance == 1)] = "Romance"#
genre[which(count == 1 & movies$Short == 1)] = "Short"#
movies$genre<-genre#
movies$budget<-(movies$budget/1000000)#
movies$rndrating<-round(movies$rating/.1)*.1#
movies$rndbudget<-round(movies$budget/.1)*.1#
#
## modify data: EuStockMarkets#
eu <- transform(data.frame(EuStockMarkets), time = time(EuStockMarkets))#
## Plot 1: Scatterplot#
p.scatter <- ggplot(movies, #
	aes(x= rndbudget, y= rndrating,#
	colour=genre)) +#
	geom_point(alpha=.5, shape=20) +#
	scale_y_continuous(breaks=seq(0,10,1), labels=seq(0,10,1)) +#
	ggtitle("IMDB Movies Data") +#
	xlab("Budget in Millions of USD") +#
	ylab("Movie Ratings") +#
	labs(colour = "Genre")#
#
print(p.scatter)#
ggsave(p.scatter, file="hw1-scatter.png", width=6, height=6)#
## Plot 2: Bar Chart#
table.genre<-sort(table(genre))#
genre.rank<-as.vector(table.genre)#
genre.labels<-c("Animation", "Romance", "Documentary", "Short", "Action", "Comedy", "None", "Drama", "Mixed")#
movies$genre2<- factor(movies$genre, levels=genre.labels)#
#
p.bar <- ggplot(movies, #
	aes(x=genre2, fill=genre)) +#
	geom_bar(width=.75) +#
##	geom_text(aes(label=genre2, y=count)) + ## eventually add bar labels#
	theme(axis.text.x=element_text(angle=45)) +#
	ggtitle("IMDB Movies Data") +#
	xlab("Film Genre") +#
	ylab("Number of Films in Genre") +#
	labs(colour = "Genre")#
#
print(p.bar)#
ggsave(p.bar, file="hw1-bar.png", width=6, height=6)#
## Plot 3: Small Multiples#
p.small <- ggplot(movies, #
	aes(x=budget, y=rating,#
	group = genre,#
	color = genre)) +#
	geom_point(alpha=.6, shape=20) +#
	scale_y_continuous(breaks=seq(0,10,1), labels=seq(0,10,1)) +#
	ggtitle("IMDB Movies Data") +#
	xlab("Film Budget in Millions of USD") +#
	ylab("Ratings") +#
	facet_wrap( ~genre2, ncol=3) +#
	labs(colour = "Genre")#
#
print(p.small)#
ggsave(p.small, file="hw1-multiples.png", width=6, height=6)#
## Plot 4: Multi-Line Chart#
yeartext <- c("1991", "1992", "1993", "1994", "1995", "1996", "1997", "1998")#
DAX<-eu[1]#
SMI<-eu[2]#
CAC<-eu[3]#
FTSE<-eu[4]#
##index<- data.frame(eu[,1:4]) ## I wasn't sure which data-type to use.#
##eu$year<-trunc(eu$time, "day") ## The intent was to use for labels.#
#
p.multi <- ggplot(eu, #
	aes(eu$time)) +#
##	group = factor(index),#
##	color = factor(index))) +#
	geom_line(aes(y=DAX, colour = "DAX: Germany")) +#
	geom_line(aes(y=SMI, colour = "SMI: Switzerland")) +#
	geom_line(aes(y=CAC, colour = "CAC: France")) +#
	geom_line(aes(y=FTSE, colour = "FSTE: UK")) +#
	ggtitle("Daily EU Stock Market Performance (1991:1998)") +#
	xlab("") +#
	ylab("Performance") +#
	scale_x_continuous(breaks=seq(1991,1998, 1), labels = yeartext) +#
	scale_y_continuous(breaks=seq(2000,10000, 1000)) +#
	theme(legend.position=c(.25,.75)) +#
	labs(colour = "Index")#
#
print(p.multi)#
ggsave(p.multi, file="hw1-multiline.png", width=6, height=6)
