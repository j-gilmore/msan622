R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.35  ## cost to the democrats#
costR<- 0.35 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 0 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities#
#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	} #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
participation<-(voteRts+voteDts)/2#
#
voteDts[nPeriods]#
voteRts[nPeriods]#
mean(actions)#
#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes")#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes")#
plot(elections, participation, cex=.3, xlab="Elections", ylab="Total Participation")#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual
actions
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.35  ## cost to the democrats#
costR<- 0.35 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 0 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  particmatrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities#
#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	} #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	particmatrixj<-list(particmatrixj,actions)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
meanparticipation<-(voteRts+voteDts)/2#
#
voteDts[nPeriods]#
voteRts[nPeriods]#
mean(actions)#
#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes")#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes")#
plot(elections, meanparticipation, cex=.3, xlab="Elections", ylab="Total Participation")#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
#
##Voting Trends#
particframej <- data.frame(matrix(unlist(list(particmatrixj)), nrow=n, byrow=TRUE))#
particSums<- colSums(particframej)#
particMeans<- colMeans(particframej)#
partictotalvotes<-rowSums(particframej)#
participation<-table(partictotalvotes)#
participation
partictotalvotes
particframej
particSums
particMeans
mean(particMeans)
particframej
particSums
particMeans
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.35  ## cost to the democrats#
costR<- 0.35 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 0 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  particmatrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities#
#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	} #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	particmatrixj<-list(particmatrixj,actions)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
meanparticipation<-(voteRts+voteDts)/2#
#
voteDts[nPeriods]#
voteRts[nPeriods]#
mean(actions)#
#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes")#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes")#
plot(elections, particMeans, cex=.3, xlab="Elections", ylab="Mean Participation")#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
#
##Voting Trends#
particframej <- data.frame(matrix(unlist(list(particmatrixj)), nrow=n, byrow=TRUE))#
particSums<- colSums(particframej)#
particMeans<- colMeans(particframej)#
mean(particMeans) ## Mean of Actions over all j elections#
partictotalvotes<-rowSums(particframej)
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.35  ## cost to the democrats#
costR<- 0.35 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 0 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  particmatrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities#
#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	} #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	particmatrixj<-list(particmatrixj,actions)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
meanparticipation<-(voteRts+voteDts)/2#
#
voteDts[nPeriods]#
voteRts[nPeriods]#
mean(actions)#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
#
##Voting Trends#
particframej <- data.frame(matrix(unlist(list(particmatrixj)), nrow=n, byrow=TRUE))#
particSums<- colSums(particframej)#
particMeans<- colMeans(particframej)#
mean(particMeans) ## Mean of Actions over all j elections#
partictotalvotes<-rowSums(particframej)#
#
## Plots#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes")#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes")#
plot(elections, particMeans, cex=.3, xlab="Elections", ylab="Mean Participation")
actions
particmatrixj
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.35  ## cost to the democrats#
costR<- 0.35 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 0 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  particmatrixj<-matrix()#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities#
#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	} #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	particmatrixj<-list(particmatrixj,actions)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
meanparticipation<-(voteRts+voteDts)/2#
#
voteDts[nPeriods]#
voteRts[nPeriods]#
mean(actions)#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
#
##Voting Trends#
particframej <- data.frame(matrix(unlist(list(particmatrixj)), nrow=n, byrow=TRUE))#
particSums<- colSums(particframej)#
particMeans<- colMeans(particframej)#
mean(particMeans) ## Mean of Actions over all j elections#
partictotalvotes<-rowSums(particframej)#
#
## Plots#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes")#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes")#
plot(elections, particMeans, cex=.3, xlab="Elections", ylab="Mean Participation")
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.35  ## cost to the democrats#
costR<- 0.35 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 0 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  particmatrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities#
#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	} #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	particmatrixj<-list(particmatrixj,actions)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
meanparticipation<-(voteRts+voteDts)/2#
#
voteDts[nPeriods]#
voteRts[nPeriods]#
mean(actions)#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
#
##Voting Trends#
particframej <- data.frame(matrix(unlist(list(particmatrixj)), nrow=n, byrow=TRUE))#
particSums<- colSums(particframej)#
particMeans<- colMeans(particframej)#
mean(particMeans) ## Mean of Actions over all j elections#
partictotalvotes<-rowSums(particframej)#
#
## Plots#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes")#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes")#
plot(elections, particMeans, cex=.3, xlab="Elections", ylab="Mean Participation")
actions
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.35  ## cost to the democrats#
costR<- 0.35 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 0 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  particmatrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities#
#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	} #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	particmatrixj<-list(particmatrixj,actions)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
meanparticipation<-(voteRts+voteDts)/2#
#
voteDts[nPeriods]#
voteRts[nPeriods]#
mean(actions) ## For last election only#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
#
##Voting Trends#
particframej <- data.frame(matrix(unlist(list(particmatrixj)), nrow=n, byrow=TRUE))#
particSums<- colSums(particframej)#
particMeans<- colMeans(particframej)#
mean(particMeans) ## Mean of Actions over all j elections#
partictotalvotes<-rowSums(particframej)#
#
## Plots#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes")#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes")#
plot(elections, particMeans, cex=.3, xlab="Elections", ylab="Mean Participation")
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.40  ## cost to the democrats#
costR<- 0.40 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 0 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  particmatrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities#
#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	} #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	particmatrixj<-list(particmatrixj,actions)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
meanparticipation<-(voteRts+voteDts)/2#
#
voteDts[nPeriods]#
voteRts[nPeriods]#
mean(actions) ## For last election only#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
#
##Voting Trends#
particframej <- data.frame(matrix(unlist(list(particmatrixj)), nrow=n, byrow=TRUE))#
particSums<- colSums(particframej)#
particMeans<- colMeans(particframej)#
mean(particMeans) ## Mean of Actions over all j elections#
partictotalvotes<-rowSums(particframej)#
#
## Plots#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes")#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes")#
plot(elections, particMeans, cex=.3, xlab="Elections", ylab="Mean Participation")
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.50  ## cost to the democrats#
costR<- 0.50 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 0 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  particmatrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities#
#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	} #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	particmatrixj<-list(particmatrixj,actions)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
meanparticipation<-(voteRts+voteDts)/2#
#
voteDts[nPeriods]#
voteRts[nPeriods]#
mean(actions) ## For last election only#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
#
##Voting Trends#
particframej <- data.frame(matrix(unlist(list(particmatrixj)), nrow=n, byrow=TRUE))#
particSums<- colSums(particframej)#
particMeans<- colMeans(particframej)#
mean(particMeans) ## Mean of Actions over all j elections#
partictotalvotes<-rowSums(particframej)#
#
## Plots#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes")#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes")#
plot(elections, particMeans, cex=.3, xlab="Elections", ylab="Mean Participation")
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.60  ## cost to the democrats#
costR<- 0.60 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 0 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  particmatrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities#
#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	} #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	particmatrixj<-list(particmatrixj,actions)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
meanparticipation<-(voteRts+voteDts)/2#
#
voteDts[nPeriods]#
voteRts[nPeriods]#
mean(actions) ## For last election only#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
#
##Voting Trends#
particframej <- data.frame(matrix(unlist(list(particmatrixj)), nrow=n, byrow=TRUE))#
particSums<- colSums(particframej)#
particMeans<- colMeans(particframej)#
mean(particMeans) ## Mean of Actions over all j elections#
partictotalvotes<-rowSums(particframej)#
#
## Plots#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes")#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes")#
plot(elections, particMeans, cex=.3, xlab="Elections", ylab="Mean Participation")
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.55  ## cost to the democrats#
costR<- 0.55 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 0 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  particmatrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities#
#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	} #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	particmatrixj<-list(particmatrixj,actions)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
meanparticipation<-(voteRts+voteDts)/2#
#
voteDts[nPeriods]#
voteRts[nPeriods]#
mean(actions) ## For last election only#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
#
##Voting Trends#
particframej <- data.frame(matrix(unlist(list(particmatrixj)), nrow=n, byrow=TRUE))#
particSums<- colSums(particframej)#
particMeans<- colMeans(particframej)#
mean(particMeans) ## Mean of Actions over all j elections#
partictotalvotes<-rowSums(particframej)#
#
## Plots#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes")#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes")#
plot(elections, particMeans, cex=.3, xlab="Elections", ylab="Mean Participation")
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.50  ## cost to the democrats#
costR<- 0.50 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 0 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  particmatrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities#
#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	} #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	particmatrixj<-list(particmatrixj,actions)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
meanparticipation<-(voteRts+voteDts)/2#
#
voteDts[nPeriods]#
voteRts[nPeriods]#
mean(actions) ## For last election only#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
#
##Voting Trends#
particframej <- data.frame(matrix(unlist(list(particmatrixj)), nrow=n, byrow=TRUE))#
particSums<- colSums(particframej)#
particMeans<- colMeans(particframej)#
mean(particMeans) ## Mean of Actions over all j elections#
partictotalvotes<-rowSums(particframej)#
#
## Plots#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes")#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes")#
plot(elections, particMeans, cex=.3, xlab="Elections", ylab="Mean Participation")
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.47 ## cost to the democrats#
costR<- 0.47 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 0 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  particmatrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities#
#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	} #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	particmatrixj<-list(particmatrixj,actions)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
meanparticipation<-(voteRts+voteDts)/2#
#
voteDts[nPeriods]#
voteRts[nPeriods]#
mean(actions) ## For last election only#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
#
##Voting Trends#
particframej <- data.frame(matrix(unlist(list(particmatrixj)), nrow=n, byrow=TRUE))#
particSums<- colSums(particframej)#
particMeans<- colMeans(particframej)#
mean(particMeans) ## Mean of Actions over all j elections#
partictotalvotes<-rowSums(particframej)#
#
## Plots#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes")#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes")#
plot(elections, particMeans, cex=.3, xlab="Elections", ylab="Mean Participation")
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.47 ## cost to the democrats#
costR<- 0.47 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  particmatrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities#
#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	} #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	particmatrixj<-list(particmatrixj,actions)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
meanparticipation<-(voteRts+voteDts)/2#
#
voteDts[nPeriods]#
voteRts[nPeriods]#
mean(actions) ## For last election only#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
#
##Voting Trends#
particframej <- data.frame(matrix(unlist(list(particmatrixj)), nrow=n, byrow=TRUE))#
particSums<- colSums(particframej)#
particMeans<- colMeans(particframej)#
mean(particMeans) ## Mean of Actions over all j elections#
partictotalvotes<-rowSums(particframej)#
#
## Plots#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes")#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes")#
plot(elections, particMeans, cex=.3, xlab="Elections", ylab="Mean Participation")
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.47 ## cost to the democrats#
costR<- 0.47 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 0 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  particmatrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities#
#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	} #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	particmatrixj<-list(particmatrixj,actions)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
meanparticipation<-(voteRts+voteDts)/2#
#
voteDts[nPeriods]#
voteRts[nPeriods]#
mean(actions) ## For last election only#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
#
##Voting Trends#
particframej <- data.frame(matrix(unlist(list(particmatrixj)), nrow=n, byrow=TRUE))#
particSums<- colSums(particframej)#
particMeans<- colMeans(particframej)#
mean(particMeans) ## Mean of Actions over all j elections#
partictotalvotes<-rowSums(particframej)#
#
## Plots#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes")#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes")#
plot(elections, particMeans, cex=.3, xlab="Elections", ylab="Mean Participation")
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.5 ## cost to the democrats#
costR<- 0.5 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 0 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  particmatrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities#
#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	} #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	particmatrixj<-list(particmatrixj,actions)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
meanparticipation<-(voteRts+voteDts)/2#
#
voteDts[nPeriods]#
voteRts[nPeriods]#
mean(actions) ## For last election only#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
#
##Voting Trends#
particframej <- data.frame(matrix(unlist(list(particmatrixj)), nrow=n, byrow=TRUE))#
particSums<- colSums(particframej)#
particMeans<- colMeans(particframej)#
mean(particMeans) ## Mean of Actions over all j elections#
partictotalvotes<-rowSums(particframej)#
#
## Plots#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes")#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes")#
plot(elections, particMeans, cex=.3, xlab="Elections", ylab="Mean Participation")
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.55 ## cost to the democrats#
costR<- 0.55 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 0 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  particmatrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities#
#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	} #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	particmatrixj<-list(particmatrixj,actions)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
meanparticipation<-(voteRts+voteDts)/2#
#
voteDts[nPeriods]#
voteRts[nPeriods]#
mean(actions) ## For last election only#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
#
##Voting Trends#
particframej <- data.frame(matrix(unlist(list(particmatrixj)), nrow=n, byrow=TRUE))#
particSums<- colSums(particframej)#
particMeans<- colMeans(particframej)#
mean(particMeans) ## Mean of Actions over all j elections#
partictotalvotes<-rowSums(particframej)#
#
## Plots#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes")#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes")#
plot(elections, particMeans, cex=.3, xlab="Elections", ylab="Mean Participation")
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.55 ## cost to the democrats#
costR<- 0.55 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  particmatrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities#
#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	} #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	particmatrixj<-list(particmatrixj,actions)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
meanparticipation<-(voteRts+voteDts)/2#
#
voteDts[nPeriods]#
voteRts[nPeriods]#
mean(actions) ## For last election only#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
#
##Voting Trends#
particframej <- data.frame(matrix(unlist(list(particmatrixj)), nrow=n, byrow=TRUE))#
particSums<- colSums(particframej)#
particMeans<- colMeans(particframej)#
mean(particMeans) ## Mean of Actions over all j elections#
partictotalvotes<-rowSums(particframej)#
#
## Plots#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes")#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes")#
plot(elections, particMeans, cex=.3, xlab="Elections", ylab="Mean Participation")
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.55 ## cost to the democrats#
costR<- 0.55 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 0 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  particmatrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities#
#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	} #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	particmatrixj<-list(particmatrixj,actions)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
meanparticipation<-(voteRts+voteDts)/2#
#
voteDts[nPeriods]#
voteRts[nPeriods]#
mean(actions) ## For last election only#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
#
##Voting Trends#
particframej <- data.frame(matrix(unlist(list(particmatrixj)), nrow=n, byrow=TRUE))#
particSums<- colSums(particframej)#
particMeans<- colMeans(particframej)#
mean(particMeans) ## Mean of Actions over all j elections#
partictotalvotes<-rowSums(particframej)#
#
## Plots#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes")#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes")#
plot(elections, particMeans, cex=.3, xlab="Elections", ylab="Mean Participation")
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.8 ## cost to the democrats#
costR<- 0.8 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  particmatrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities#
#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	} #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	particmatrixj<-list(particmatrixj,actions)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
meanparticipation<-(voteRts+voteDts)/2#
#
voteDts[nPeriods]#
voteRts[nPeriods]#
mean(actions) ## For last election only#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
#
##Voting Trends#
particframej <- data.frame(matrix(unlist(list(particmatrixj)), nrow=n, byrow=TRUE))#
particSums<- colSums(particframej)#
particMeans<- colMeans(particframej)#
mean(particMeans) ## Mean of Actions over all j elections#
partictotalvotes<-rowSums(particframej)#
#
## Plots#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes")#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes")#
plot(elections, particMeans, cex=.3, xlab="Elections", ylab="Mean Participation")
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.9 ## cost to the democrats#
costR<- 0.9 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  particmatrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities#
#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	} #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	particmatrixj<-list(particmatrixj,actions)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
meanparticipation<-(voteRts+voteDts)/2#
#
voteDts[nPeriods]#
voteRts[nPeriods]#
mean(actions) ## For last election only#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
#
##Voting Trends#
particframej <- data.frame(matrix(unlist(list(particmatrixj)), nrow=n, byrow=TRUE))#
particSums<- colSums(particframej)#
particMeans<- colMeans(particframej)#
mean(particMeans) ## Mean of Actions over all j elections#
partictotalvotes<-rowSums(particframej)#
#
## Plots#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes")#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes")#
plot(elections, particMeans, cex=.3, xlab="Elections", ylab="Mean Participation")
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.95 ## cost to the democrats#
costR<- 0.95 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  particmatrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities#
#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	} #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	particmatrixj<-list(particmatrixj,actions)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
meanparticipation<-(voteRts+voteDts)/2#
#
voteDts[nPeriods]#
voteRts[nPeriods]#
mean(actions) ## For last election only#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
#
##Voting Trends#
particframej <- data.frame(matrix(unlist(list(particmatrixj)), nrow=n, byrow=TRUE))#
particSums<- colSums(particframej)#
particMeans<- colMeans(particframej)#
mean(particMeans) ## Mean of Actions over all j elections#
partictotalvotes<-rowSums(particframej)#
#
## Plots#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes")#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes")#
plot(elections, particMeans, cex=.3, xlab="Elections", ylab="Mean Participation")
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  particmatrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities#
#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	} #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	particmatrixj<-list(particmatrixj,actions)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
meanparticipation<-(voteRts+voteDts)/2#
#
voteDts[nPeriods]#
voteRts[nPeriods]#
mean(actions) ## For last election only#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
#
##Voting Trends#
particframej <- data.frame(matrix(unlist(list(particmatrixj)), nrow=n, byrow=TRUE))#
particSums<- colSums(particframej)#
particMeans<- colMeans(particframej)#
mean(particMeans) ## Mean of Actions over all j elections#
partictotalvotes<-rowSums(particframej)#
#
## Plots#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes")#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes")#
plot(elections, particMeans, cex=.3, xlab="Elections", ylab="Mean Participation")
meanParticipation
meanparticipation
mean(meanparticipation)
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  particmatrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities#
#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	} #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	particmatrixj<-list(particmatrixj,actions)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
meanparticipation<-(voteRts+voteDts)/2#
#
voteDts[nPeriods]#
voteRts[nPeriods]#
mean(actions) ## For last election only#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
#
##Voting Trends [Play with this]#
particframej <- data.frame(matrix(unlist(list(particmatrixj)), nrow=n, byrow=TRUE))#
particSums<- colSums(particframej)#
particMeans<- colMeans(particframej)#
mean(particMeans) ## Mean of Actions over all j elections#
partictotalvotes<-rowSums(particframej)#
#
## Plots#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes")#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes")#
plot(elections, particMeans, cex=.3, xlab="Elections", ylab="Mean Participation")
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  particmatrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities#
#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	} #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
meanparticipation<-(voteRts+voteDts)/2#
#
voteDts[nPeriods]#
voteRts[nPeriods]#
mean(actions) ## For last election only#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
#
## Plots#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes")#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes")
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  particmatrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities#
#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	} #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
meanparticipation<-(voteRts+voteDts)/2#
#
voteDts[nPeriods-7:nPeriods]#
voteRts[nPeriods]#
mean(actions) ## For last election only#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
#
## Plots#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes")#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes")
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  particmatrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities#
#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	} #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
meanparticipation<-(voteRts+voteDts)/2#
#
mean(voteDts[nPeriods])#
voteRts[nPeriods]#
mean(actions) ## For last election only#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
#
## Plots#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes")#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes")
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  particmatrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities#
#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	} #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
meanparticipation<-(voteRts+voteDts)/2#
#
mean(voteDts[nPeriods])#
voteDts[nPeriods]#
voteRts[nPeriods]#
mean(actions) ## For last election only#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
#
## Plots#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes")#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes")
voteD
voteR
mean(voteDts)
voteDts
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  rmatrixj<-matrix(nrow=(0), ncol=(0))#
  dmatrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
    meanvoteDts<-mean(voteDts)#
    meanvoteRts<-mean(voteRts)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	rmatrixj<- list(rmatrixj, meanvoteRts)#
	dmatrixj<- list(dmatrixj, meanvoteDts)#
	}#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
meanparticipation<-(voteRts+voteDts)/2#
#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## For last election only#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
#
## Plots#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes")#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes")
rmatrixj
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  rmatrixj<-matrix(nrow=(0), ncol=(0))#
  dmatrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
    meanvoteDts<-mean(voteDts)#
    meanvoteRts<-mean(voteRts)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
	rmatrixj<- list(rmatrixj, meanvoteRts)#
	dmatrixj<- list(dmatrixj, meanvoteDts)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
meanparticipation<-(voteRts+voteDts)/2#
#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## For last election only#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
#
## Plots#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes")#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes")
rmatrixj
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  rmatrixj<-matrix(nrow=(0), ncol=(0))#
  dmatrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
    meanvoteDts<-mean(voteDts)#
    meanvoteRts<-mean(voteRts)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
	rmatrixj<- list(rmatrixj, meanvoteRts)#
	dmatrixj<- list(dmatrixj, meanvoteDts)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
meanparticipation<-(voteRts+voteDts)/2#
#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## For last election only#
mean(rmatrixj)#
mean(dmatrixj)#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
#
## Plots#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes")#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes")
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  rmatrixj<-matrix(nrow=(0), ncol=(0))#
  dmatrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
    meanvoteDts<-mean(voteDts)#
    meanvoteRts<-mean(voteRts)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
	rmatrixj<- list(rmatrixj, meanvoteRts)#
	dmatrixj<- list(dmatrixj, meanvoteDts)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
meanparticipation<-(voteRts+voteDts)/2#
#
rframej <- data.frame(matrix(unlist(list(rmatrixj)), nrow=n, byrow=TRUE))#
dframej <- data.frame(matrix(unlist(list(dmatrixj)), nrow=n, byrow=TRUE))#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## For last election only#
mean(rmatrixj)#
mean(dmatrixj)#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
#
## Plots#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes")#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes")
rmatrixj
rframej
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  rmatrixj<-matrix(nrow=(0), ncol=(0))#
  dmatrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
    meanvoteDts<-mean(voteDts)#
    meanvoteRts<-mean(voteRts)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
	rmatrixj<- list(rmatrixj, meanvoteRts)#
	dmatrixj<- list(dmatrixj, meanvoteDts)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
meanparticipation<-(voteRts+voteDts)/2#
#
rframej <- data.frame(matrix(unlist(list(rmatrixj)), nrow=n, byrow=FALSE))#
dframej <- data.frame(matrix(unlist(list(dmatrixj)), nrow=n, byrow=FALSE))#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## For last election only#
mean(rmatrixj)#
mean(dmatrixj)#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
#
## Plots#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes")#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes")
rmatrixj
rframej
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  rmatrixj<-matrix(nrow=(0), ncol=(0))#
  dmatrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
    meanvoteDts<-mean(voteDts)#
    meanvoteRts<-mean(voteRts)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
	rmatrixj<- list(rmatrixj, meanvoteRts)#
	dmatrixj<- list(dmatrixj, meanvoteDts)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
meanparticipation<-(voteRts+voteDts)/2#
#
rframej <- data.frame(matrix(unlist(list(rmatrixj)), nrow=nPeriods, byrow=TRUE))#
dframej <- data.frame(matrix(unlist(list(dmatrixj)), nrow=nPeriods, byrow=TRUE))#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## For last election only#
mean(rmatrixj)#
mean(dmatrixj)#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
#
## Plots#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes")#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes")
rframej
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  rmatrixj<-matrix(nrow=(0), ncol=(0))#
  dmatrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
    meanvoteDts<-mean(voteDts)#
    meanvoteRts<-mean(voteRts)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
	rmatrixj<- list(rmatrixj, meanvoteRts)#
	dmatrixj<- list(dmatrixj, meanvoteDts)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
meanparticipation<-(voteRts+voteDts)/2#
#
rframej <- data.frame(matrix(unlist(list(rmatrixj)), nrow=nPeriods, byrow=TRUE))#
dframej <- data.frame(matrix(unlist(list(dmatrixj)), nrow=nPeriods, byrow=TRUE))#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## For last election only#
colMeans(rmatrixj)#
colMeans(dmatrixj)#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
#
## Plots#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes")#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes")
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  rmatrixj<-matrix(nrow=(0), ncol=(0))#
  dmatrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
    meanvoteDts<-mean(voteDts)#
    meanvoteRts<-mean(voteRts)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
	rmatrixj<- list(rmatrixj, meanvoteRts)#
	dmatrixj<- list(dmatrixj, meanvoteDts)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
meanparticipation<-(voteRts+voteDts)/2#
#
rframej <- data.frame(matrix(unlist(list(rmatrixj)), nrow=nPeriods, byrow=TRUE))#
dframej <- data.frame(matrix(unlist(list(dmatrixj)), nrow=nPeriods, byrow=TRUE))#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## For last election only#
rowMeans(rmatrixj)#
rowMeans(dmatrixj)#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
#
## Plots#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes")#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes")
rframej
sum(rframej[1])
mean(rframej[1])
mean(rmatrixj[1])
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  ##rmatrixj<-matrix(nrow=(0), ncol=(0))#
  ##dmatrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
    ##meanvoteDts<-mean(voteDts)#
    ##meanvoteRts<-mean(voteRts)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
	##rmatrixj<- list(rmatrixj, meanvoteRts)#
	##dmatrixj<- list(dmatrixj, meanvoteDts)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
meanparticipation<-(voteRts+voteDts)/2#
#
rframej <- data.frame(matrix(unlist(list(rmatrixj)), nrow=nPeriods, byrow=TRUE))#
dframej <- data.frame(matrix(unlist(list(dmatrixj)), nrow=nPeriods, byrow=TRUE))#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## For last election only#
## rowMeans(rmatrixj)#
## rowMeans(dmatrixj)#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
#
## Plots#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes")#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes")
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  ##rmatrixj<-matrix(nrow=(0), ncol=(0))#
  ##dmatrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
    ##meanvoteDts<-mean(voteDts)#
    ##meanvoteRts<-mean(voteRts)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
	##rmatrixj<- list(rmatrixj, meanvoteRts)#
	##dmatrixj<- list(dmatrixj, meanvoteDts)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
meanparticipation<-(voteRts+voteDts)/2#
#
## rframej <- data.frame(matrix(unlist(list(rmatrixj)), nrow=nPeriods, byrow=TRUE))#
## dframej <- data.frame(matrix(unlist(list(dmatrixj)), nrow=nPeriods, byrow=TRUE))#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## For last election only#
## rowMeans(rmatrixj)#
## rowMeans(dmatrixj)#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
#
## Plots#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes")#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes")
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  ##rmatrixj<-matrix(nrow=(0), ncol=(0))#
  ##dmatrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
    ##meanvoteDts<-mean(voteDts)#
    ##meanvoteRts<-mean(voteRts)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
	##rmatrixj<- list(rmatrixj, meanvoteRts)#
	##dmatrixj<- list(dmatrixj, meanvoteDts)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
meanparticipation<-(voteRts+voteDts)/2#
#
## rframej <- data.frame(matrix(unlist(list(rmatrixj)), nrow=nPeriods, byrow=TRUE))#
## dframej <- data.frame(matrix(unlist(list(dmatrixj)), nrow=nPeriods, byrow=TRUE))#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## For last election only#
## rowMeans(rmatrixj)#
## rowMeans(dmatrixj)#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
#
## Plots#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot((elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes", col="Red"), (elections, voteDts))#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes")
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  ##rmatrixj<-matrix(nrow=(0), ncol=(0))#
  ##dmatrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
    ##meanvoteDts<-mean(voteDts)#
    ##meanvoteRts<-mean(voteRts)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
	##rmatrixj<- list(rmatrixj, meanvoteRts)#
	##dmatrixj<- list(dmatrixj, meanvoteDts)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
meanparticipation<-(voteRts+voteDts)/2#
#
## rframej <- data.frame(matrix(unlist(list(rmatrixj)), nrow=nPeriods, byrow=TRUE))#
## dframej <- data.frame(matrix(unlist(list(dmatrixj)), nrow=nPeriods, byrow=TRUE))#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## For last election only#
## rowMeans(rmatrixj)#
## rowMeans(dmatrixj)#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
#
## Plots#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot((elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes", col="Red") (elections, voteDts))#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes")
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  ##rmatrixj<-matrix(nrow=(0), ncol=(0))#
  ##dmatrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
    ##meanvoteDts<-mean(voteDts)#
    ##meanvoteRts<-mean(voteRts)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
	##rmatrixj<- list(rmatrixj, meanvoteRts)#
	##dmatrixj<- list(dmatrixj, meanvoteDts)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
meanparticipation<-(voteRts+voteDts)/2#
#
## rframej <- data.frame(matrix(unlist(list(rmatrixj)), nrow=nPeriods, byrow=TRUE))#
## dframej <- data.frame(matrix(unlist(list(dmatrixj)), nrow=nPeriods, byrow=TRUE))#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## For last election only#
## rowMeans(rmatrixj)#
## rowMeans(dmatrixj)#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
#
## Plots#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot((elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes" col="Red") (elections, voteDts))#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes")
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  ##rmatrixj<-matrix(nrow=(0), ncol=(0))#
  ##dmatrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
    ##meanvoteDts<-mean(voteDts)#
    ##meanvoteRts<-mean(voteRts)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
	##rmatrixj<- list(rmatrixj, meanvoteRts)#
	##dmatrixj<- list(dmatrixj, meanvoteDts)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
meanparticipation<-(voteRts+voteDts)/2#
#
## rframej <- data.frame(matrix(unlist(list(rmatrixj)), nrow=nPeriods, byrow=TRUE))#
## dframej <- data.frame(matrix(unlist(list(dmatrixj)), nrow=nPeriods, byrow=TRUE))#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## For last election only#
## rowMeans(rmatrixj)#
## rowMeans(dmatrixj)#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
#
## Plots#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes")#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes")
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  ##rmatrixj<-matrix(nrow=(0), ncol=(0))#
  ##dmatrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
    ##meanvoteDts<-mean(voteDts)#
    ##meanvoteRts<-mean(voteRts)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
	##rmatrixj<- list(rmatrixj, meanvoteRts)#
	##dmatrixj<- list(dmatrixj, meanvoteDts)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
meanparticipation<-(voteRts+voteDts)/2#
#
## rframej <- data.frame(matrix(unlist(list(rmatrixj)), nrow=nPeriods, byrow=TRUE))#
## dframej <- data.frame(matrix(unlist(list(dmatrixj)), nrow=nPeriods, byrow=TRUE))#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## For last election only#
## rowMeans(rmatrixj)#
## rowMeans(dmatrixj)#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
#
## Plots#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes")#
par(new=T)#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes")#
par(new=F)
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  ##rmatrixj<-matrix(nrow=(0), ncol=(0))#
  ##dmatrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
    ##meanvoteDts<-mean(voteDts)#
    ##meanvoteRts<-mean(voteRts)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
	##rmatrixj<- list(rmatrixj, meanvoteRts)#
	##dmatrixj<- list(dmatrixj, meanvoteDts)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
meanparticipation<-(voteRts+voteDts)/2#
#
## rframej <- data.frame(matrix(unlist(list(rmatrixj)), nrow=nPeriods, byrow=TRUE))#
## dframej <- data.frame(matrix(unlist(list(dmatrixj)), nrow=nPeriods, byrow=TRUE))#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## For last election only#
## rowMeans(rmatrixj)#
## rowMeans(dmatrixj)#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
#
## Plots#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes")#
par(new=T)#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes", col="Red")#
par(new=F)
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  ##rmatrixj<-matrix(nrow=(0), ncol=(0))#
  ##dmatrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
    ##meanvoteDts<-mean(voteDts)#
    ##meanvoteRts<-mean(voteRts)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
	##rmatrixj<- list(rmatrixj, meanvoteRts)#
	##dmatrixj<- list(dmatrixj, meanvoteDts)#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=TRUE))#
primarySums<- colSums(primaryframej)#
primaryMeans<- colMeans(primaryframej)#
primarytotalvotes<-rowSums(primaryframej)#
primaryparticipation<-table(primarytotalvotes)#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
meanparticipation<-(voteRts+voteDts)/2#
#
## rframej <- data.frame(matrix(unlist(list(rmatrixj)), nrow=nPeriods, byrow=TRUE))#
## dframej <- data.frame(matrix(unlist(list(dmatrixj)), nrow=nPeriods, byrow=TRUE))#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## For last election only#
## rowMeans(rmatrixj)#
## rowMeans(dmatrixj)#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
#
## Plots#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes", col="Red")#
par(new=T)#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes", col="Blue")#
par(new=F)
help packages
installed.packages
library()
install.packages("ggplot2")
library()
install.packages("shiny")
library()
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=FALSE))#
primarySums<- colSums(primaryframej) ## Participation in Primary#
primaryMeans<- colMeans(primaryframej) ## Participation Rate#
primaryMeans#
nPeriodthPrimaryMean<-primaryMeans[7]#
nPeriodthPrimaryMean#
primarytotalvotes<-rowSums(primaryframej) ## Individual Participation by number of votes#
primaryparticipation<-table(primarytotalvotes) ## Summary of number of times respondents voted#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
## meanparticipation<-(voteRts+voteDts)/2 ## For each of nPeriods#
#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## Voting rate for last election only#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
#
## Plots#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes", col="Red")#
##par(new=T)#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes", col="Blue")#
##par(new=F)#
#
sum(actions)#
primarySums[7]
actions
primaryframej[7]
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primarySums<- colSums(primaryframej) ## Participation in Primary#
primaryMeans<- colMeans(primaryframej) ## Participation Rate#
primaryMeans#
nPeriodthPrimaryMean<-primaryMeans[7]#
nPeriodthPrimaryMean#
primarytotalvotes<-rowSums(primaryframej) ## Individual Participation by number of votes#
primaryparticipation<-table(primarytotalvotes) ## Summary of number of times respondents voted#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
## meanparticipation<-(voteRts+voteDts)/2 ## For each of nPeriods#
#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## Voting rate for last election only#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
#
## Plots#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes", col="Red")#
##par(new=T)#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes", col="Blue")#
##par(new=F)#
#
sum(actions)#
primarySums[7]
meanparticipation<-(voteRts+voteDts)/2 ## For each of nPeriods
meanparticipation
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primarySums<- colSums(primaryframej) ## Participation in Primary#
primaryMeans<- colMeans(primaryframej) ## Participation Rate#
primaryMeans#
nPeriodthPrimaryMean<-primaryMeans[7]#
nPeriodthPrimaryMean#
primarytotalvotes<-rowSums(primaryframej) ## Individual Participation by number of votes#
primaryparticipation<-table(primarytotalvotes) ## Summary of number of times respondents voted#
primaryparticipation#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
## meanparticipation<-(voteRts+voteDts)/2 ## For each of nPeriods#
#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## Voting rate for last election only#
#
##Habitual Voting Behavior#
primaryhabitual<-(((primaryparticipation["0"])+(primaryparticipation["7"]))/n)#
primaryhabitual#
#
## Plots#
par(mfrow=c(2,2))#
barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes", col="Red")#
##par(new=T)#
plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes", col="Blue")#
##par(new=F)#
#
sum(actions)#
primarySums[7]
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primarySums<- colSums(primaryframej) ## Participation in Primary#
primaryMeans<- colMeans(primaryframej) ## Participation Rate#
## primaryMeans#
nPeriodthPrimaryMean<-primaryMeans[7]#
nPeriodthPrimaryMean#
#
primaryIndVotes<-rowSums(primaryframej) ## Individual Participation by number of votes#
primaryIndParticipation<-table(primaryIndVotes) ## Summary of number of times respondents voted#
primaryIndParticipation#
barplot(primaryIndParticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
## meanparticipation<-(voteRts+voteDts)/2 ## For each of nPeriods#
#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## Voting rate for last election only#
#
##Habitual Voting Behavior#
primaryHabitual<-(((primaryIndParticipation["0"])+(primaryIndParticipation["7"]))/n)#
primaryHabitual#
#
## Plots#
% par(mfrow=c(2,2))#
% barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
% plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes", col="Red")#
% ##par(new=T)#
% plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes", col="Blue")#
##par(new=F)#
#
sum(actions)#
primarySums[7]
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primarySums<- colSums(primaryframej) ## Participation in Primary#
primaryMeans<- colMeans(primaryframej) ## Participation Rate#
## primaryMeans#
nPeriodthPrimaryMean<-primaryMeans[7]#
nPeriodthPrimaryMean#
#
primaryIndVotes<-rowSums(primaryframej) ## Individual Participation by number of votes#
primaryIndParticipation<-table(primaryIndVotes) ## Summary of number of times respondents voted#
primaryIndParticipation#
## barplot(primaryIndParticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
## meanparticipation<-(voteRts+voteDts)/2 ## For each of nPeriods#
#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## Voting rate for last election only#
#
##Habitual Voting Behavior#
primaryHabitual<-(((primaryIndParticipation["0"])+(primaryIndParticipation["7"]))/n)#
primaryHabitual#
#
## Plots#
## par(mfrow=c(2,2))#
## barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
## plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes", col="Red")#
##par(new=T)#
## plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes", col="Blue")#
##par(new=F)#
#
sum(actions)#
primarySums[7]
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##}#
#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primarySums<- colSums(primaryframej) ## Participation in Primary#
primaryMeans<- colMeans(primaryframej) ## Participation Rate#
## primaryMeans#
nPeriodthPrimaryMean<-primaryMeans[7]#
nPeriodthPrimaryMean#
#
primaryIndVotes<-rowSums(primaryframej) ## Individual Participation by number of votes#
primaryIndParticipation<-table(primaryIndVotes) ## Summary of number of times respondents voted (mode)#
primaryIndParticipation#
## barplot(primaryIndParticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
## meanparticipation<-(voteRts+voteDts)/2 ## For each of nPeriods#
#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## Voting rate for last election only#
#
##Habitual Voting Behavior#
primaryHabitual<-(((primaryIndParticipation["0"])+(primaryIndParticipation["7"]))/n)#
primaryHabitual#
#
## Plots#
## par(mfrow=c(2,2))#
## barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
## plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes", col="Red")#
##par(new=T)#
## plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes", col="Blue")#
##par(new=F)#
#
sum(actions)#
primarySums[7]
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-1000 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primarySums<- colSums(primaryframej) ## Participation in Primary#
primaryMeans<- colMeans(primaryframej) ## Participation Rate#
## primaryMeans#
nPeriodthPrimaryMean<-primaryMeans[7]#
nPeriodthPrimaryMean#
#
primaryIndVotes<-rowSums(primaryframej) ## Individual Participation by number of votes#
primaryIndParticipation<-table(primaryIndVotes) ## Summary of number of times respondents voted (mode)#
primaryIndParticipation#
## barplot(primaryIndParticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
## meanparticipation<-(voteRts+voteDts)/2 ## For each of nPeriods#
#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## Voting rate for last election only#
#
##Habitual Voting Behavior#
primaryHabitual<-(((primaryIndParticipation["0"])+(primaryIndParticipation["7"]))/n)#
primaryHabitual#
#
## Plots#
## par(mfrow=c(2,2))#
## barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
## plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes", col="Red")#
##par(new=T)#
## plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes", col="Blue")#
##par(new=F)#
#
sum(actions)#
primarySums[7]#
##}
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-10 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  votematrixi<-matrix(nrow=(0), ncol=(0))#
  habitmatrixi<-matrix(nrow=(0), ncol=(0))#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primarySums<- colSums(primaryframej) ## Participation in Primary#
primaryMeans<- colMeans(primaryframej) ## Participation Rate#
## primaryMeans#
nPeriodthPrimaryMean<-primaryMeans[7]#
nPeriodthPrimaryMean#
#
primaryIndVotes<-rowSums(primaryframej) ## Individual Participation by number of votes#
primaryIndParticipation<-table(primaryIndVotes) ## Summary of number of times respondents voted (mode)#
primaryIndParticipation#
## barplot(primaryIndParticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
## meanparticipation<-(voteRts+voteDts)/2 ## For each of nPeriods#
#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## Voting rate for last election only#
#
##Habitual Voting Behavior#
primaryHabitual<-(((primaryIndParticipation["0"])+(primaryIndParticipation["7"]))/n) ## For consistent voters and abstainers#
primaryHabitual#
#
## Plots#
## par(mfrow=c(2,2))#
## barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
## plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes", col="Red")#
##par(new=T)#
## plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes", col="Blue")#
##par(new=F)#
#
sum(actions)#
primarySums[7]#
#
votematrixi<- list(votematrixi, mean(actions))#
habitmatrixi<- list(habitmatrixi, primaryHabitual)#
}
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-10 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  votematrixi<-matrix(nrow=(0), ncol=(0))#
  habitmatrixi<-matrix(nrow=(0), ncol=(0))#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primarySums<- colSums(primaryframej) ## Participation in Primary#
primaryMeans<- colMeans(primaryframej) ## Participation Rate#
## primaryMeans#
nPeriodthPrimaryMean<-primaryMeans[7]#
nPeriodthPrimaryMean#
#
primaryIndVotes<-rowSums(primaryframej) ## Individual Participation by number of votes#
primaryIndParticipation<-table(primaryIndVotes) ## Summary of number of times respondents voted (mode)#
primaryIndParticipation#
## barplot(primaryIndParticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
## meanparticipation<-(voteRts+voteDts)/2 ## For each of nPeriods#
#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## Voting rate for last election only#
#
##Habitual Voting Behavior#
primaryHabitual<-(((primaryIndParticipation["0"])+(primaryIndParticipation["7"]))/n) ## For consistent voters and abstainers#
primaryHabitual#
#
## Plots#
## par(mfrow=c(2,2))#
## barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
## plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes", col="Red")#
##par(new=T)#
## plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes", col="Blue")#
##par(new=F)#
#
sum(actions)#
primarySums[7]#
#
votematrixi<- list(votematrixi, mean(actions))#
habitmatrixi<- list(habitmatrixi, primaryHabitual)#
}
votematrixi
habitmatrixi
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-10 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
votematrixi<-matrix(nrow=(0), ncol=(0))#
habitmatrixi<-matrix(nrow=(0), ncol=(0))#
#
for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##Primary Election Data#
primaryframej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primarySums<- colSums(primaryframej) ## Participation in Primary#
primaryMeans<- colMeans(primaryframej) ## Participation Rate#
## primaryMeans#
nPeriodthPrimaryMean<-primaryMeans[7]#
nPeriodthPrimaryMean#
#
primaryIndVotes<-rowSums(primaryframej) ## Individual Participation by number of votes#
primaryIndParticipation<-table(primaryIndVotes) ## Summary of number of times respondents voted (mode)#
primaryIndParticipation#
## barplot(primaryIndParticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
## meanparticipation<-(voteRts+voteDts)/2 ## For each of nPeriods#
#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## Voting rate for last election only#
#
##Habitual Voting Behavior#
primaryHabitual<-(((primaryIndParticipation["0"])+(primaryIndParticipation["7"]))/n) ## For consistent voters and abstainers#
primaryHabitual#
#
## Plots#
## par(mfrow=c(2,2))#
## barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
## plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes", col="Red")#
##par(new=T)#
## plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes", col="Blue")#
##par(new=F)#
#
sum(actions)#
primarySums[7]#
#
votematrixi<- list(votematrixi, mean(actions))#
habitmatrixi<- list(habitmatrixi, primaryHabitual)#
}
votematrixi
habitmatrixi
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-10 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
votematrixi<-matrix(nrow=(0), ncol=(0))#
habitmatrixi<-matrix(nrow=(0), ncol=(0))#
#
for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##Primary Election Data#
primaryVoteFramej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primaryVoteSumsj<- colSums(primaryVoteFramej) ## Participation in Primary#
primaryVoteMeansj<- colMeans(primaryVoteFramej) ## Participation Rate#
## primaryVoteMeansj#
nPeriodthPrimaryMeanj<-primaryVoteMeansj[7]#
nPeriodthPrimaryMeanj#
#
primaryIndVotesj<-rowSums(primaryVoteFramej) ## Individual Participation by number of votes#
primaryIndParticipationj<-table(primaryIndVotesj) ## Summary of number of times respondents voted (mode)#
primaryIndParticipationj#
## barplot(primaryIndParticipationj, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
electionsj<-c(1:nPeriods)#
## meanparticipationj<-(voteRts+voteDts)/2 ## For each of nPeriods#
#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## Voting rate for last election only#
#
##Habitual Voting Behavior#
primaryHabitualj<-(((primaryIndParticipationj["0"])+(primaryIndParticipationj["7"]))/n) ## For consistent voters and abstainers#
primaryHabitualj#
#
## Plots#
## par(mfrow=c(2,2))#
## barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
## plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes", col="Red")#
##par(new=T)#
## plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes", col="Blue")#
##par(new=F)#
#
sum(actions)#
primarySums[7]#
#
votematrixi<- list(votematrixi, mean(actions))#
habitmatrixi<- list(habitmatrixi, primaryHabitualj)#
#
}#
#
primaryVoteFramei <- data.frame(matrix(unlist(list(votematrixi)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primaryHabitFramei <- data.frame(matrix(unlist(list(habitmatrixi)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
#
primaryVoteSumsi<- colSums(primaryVoteFramei) ## Participation in Primary#
primaryVoteMeansi<- colMeans(primaryVoteFramei) ## Participation Rate#
## primaryVoteMeansi#
nPeriodthPrimaryMean<-primaryVoteMeansi[7]#
nPeriodthPrimaryMeani#
#
primaryIndVotes<-rowSums(primaryVoteFramej) ## Individual Participation by number of votes#
primaryIndParticipation<-table(primaryIndVotes) ## Summary of number of times respondents voted (mode)#
primaryIndParticipation#
## barplot(primaryIndParticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
## meanparticipation<-(voteRts+voteDts)/2 ## For each of nPeriods#
#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## Voting rate for last election only#
#
##Habitual Voting Behavior#
primaryHabitual<-(((primaryIndParticipation["0"])+(primaryIndParticipation["7"]))/n) ## For consistent voters and abstainers#
primaryHabitual
primaryVoteFramei
votematrixi
habitmatrixi
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-10 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  votematrixi<-matrix(nrow=(0), ncol=(0))#
  habitmatrixi<-matrix(nrow=(0), ncol=(0))#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##Primary Election Data#
primaryVoteFramej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primaryVoteSumsj<- colSums(primaryVoteFramej) ## Participation in Primary#
primaryVoteMeansj<- colMeans(primaryVoteFramej) ## Participation Rate#
## primaryVoteMeansj#
nPeriodthPrimaryMeanj<-primaryVoteMeansj[7]#
nPeriodthPrimaryMeanj#
#
primaryIndVotesj<-rowSums(primaryVoteFramej) ## Individual Participation by number of votes#
primaryIndParticipationj<-table(primaryIndVotesj) ## Summary of number of times respondents voted (mode)#
primaryIndParticipationj#
## barplot(primaryIndParticipationj, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
electionsj<-c(1:nPeriods)#
## meanparticipationj<-(voteRts+voteDts)/2 ## For each of nPeriods#
#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## Voting rate for last election only#
#
##Habitual Voting Behavior#
primaryHabitualj<-(((primaryIndParticipationj["0"])+(primaryIndParticipationj["7"]))/n) ## For consistent voters and abstainers#
primaryHabitualj#
#
## Plots#
## par(mfrow=c(2,2))#
## barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
## plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes", col="Red")#
##par(new=T)#
## plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes", col="Blue")#
##par(new=F)#
#
sum(actions)#
primarySumsj[7]#
#
votematrixi<- list(votematrixi, mean(actions))#
habitmatrixi<- list(habitmatrixi, primaryHabitualj)#
#
}#
#
primaryVoteFramei <- data.frame(matrix(unlist(list(votematrixi)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primaryHabitFramei <- data.frame(matrix(unlist(list(habitmatrixi)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
#
primaryVoteSumsi<- colSums(primaryVoteFramei) ## Participation in Primary#
primaryVoteMeansi<- colMeans(primaryVoteFramei) ## Participation Rate#
## primaryVoteMeansi#
nPeriodthPrimaryMeani<-primaryVoteMeansi[7]#
nPeriodthPrimaryMeani#
#
primaryIndVotes<-rowSums(primaryVoteFramej) ## Individual Participation by number of votes#
primaryIndParticipation<-table(primaryIndVotes) ## Summary of number of times respondents voted (mode)#
primaryIndParticipation#
## barplot(primaryIndParticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
## meanparticipation<-(voteRts+voteDts)/2 ## For each of nPeriods#
#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## Voting rate for last election only#
#
##Habitual Voting Behavior#
primaryHabitual<-(((primaryIndParticipation["0"])+(primaryIndParticipation["7"]))/n) ## For consistent voters and abstainers#
primaryHabitual
votematrixi
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-10 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  votematrixi<-matrix(nrow=(0), ncol=(0))#
  habitmatrixi<-matrix(nrow=(0), ncol=(0))#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##Primary Election Data#
primaryVoteFramej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primaryVoteSumsj<- colSums(primaryVoteFramej) ## Participation in Primary#
primaryVoteMeansj<- colMeans(primaryVoteFramej) ## Participation Rate#
## primaryVoteMeansj#
nPeriodthPrimaryMeanj<-primaryVoteMeansj[7]#
nPeriodthPrimaryMeanj#
#
primaryIndVotesj<-rowSums(primaryVoteFramej) ## Individual Participation by number of votes#
primaryIndParticipationj<-table(primaryIndVotesj) ## Summary of number of times respondents voted (mode)#
primaryIndParticipationj#
## barplot(primaryIndParticipationj, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
electionsj<-c(1:nPeriods)#
## meanparticipationj<-(voteRts+voteDts)/2 ## For each of nPeriods#
#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## Voting rate for last election only#
#
##Habitual Voting Behavior#
primaryHabitualj<-(((primaryIndParticipationj["0"])+(primaryIndParticipationj["7"]))/n) ## For consistent voters and abstainers#
primaryHabitualj#
#
## Plots#
## par(mfrow=c(2,2))#
## barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
## plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes", col="Red")#
##par(new=T)#
## plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes", col="Blue")#
##par(new=F)#
#
sum(actions)#
primarySumsj[7]#
#
  votematrixi<- list(votematrixi, mean(actions))#
  habitmatrixi<- list(habitmatrixi, primaryHabitualj)#
#
}#
#
primaryVoteFramei <- data.frame(matrix(unlist(list(votematrixi)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primaryHabitFramei <- data.frame(matrix(unlist(list(habitmatrixi)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
#
primaryVoteSumsi<- colSums(primaryVoteFramei) ## Participation in Primary#
primaryVoteMeansi<- colMeans(primaryVoteFramei) ## Participation Rate#
## primaryVoteMeansi#
nPeriodthPrimaryMeani<-primaryVoteMeansi[7]#
nPeriodthPrimaryMeani#
#
primaryIndVotes<-rowSums(primaryVoteFramej) ## Individual Participation by number of votes#
primaryIndParticipation<-table(primaryIndVotes) ## Summary of number of times respondents voted (mode)#
primaryIndParticipation#
## barplot(primaryIndParticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
elections<-c(1:nPeriods)#
## meanparticipation<-(voteRts+voteDts)/2 ## For each of nPeriods#
#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## Voting rate for last election only#
#
##Habitual Voting Behavior#
primaryHabitual<-(((primaryIndParticipation["0"])+(primaryIndParticipation["7"]))/n) ## For consistent voters and abstainers#
primaryHabitual
votematrixi
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-10 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  votematrixi<-matrix(nrow=(0), ncol=(0))#
  habitmatrixi<-matrix(nrow=(0), ncol=(0))#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##Primary Election Data#
primaryVoteFramej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primaryVoteSumsj<- colSums(primaryVoteFramej) ## Participation in Primary#
primaryVoteMeansj<- colMeans(primaryVoteFramej) ## Participation Rate#
## primaryVoteMeansj#
nPeriodthPrimaryMeanj<-primaryVoteMeansj[7]#
nPeriodthPrimaryMeanj#
#
primaryIndVotesj<-rowSums(primaryVoteFramej) ## Individual Participation by number of votes#
primaryIndParticipationj<-table(primaryIndVotesj) ## Summary of number of times respondents voted (mode)#
primaryIndParticipationj#
## barplot(primaryIndParticipationj, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
electionsj<-c(1:nPeriods)#
## meanparticipationj<-(voteRts+voteDts)/2 ## For each of nPeriods#
#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## Voting rate for last election only#
#
##Habitual Voting Behavior#
primaryHabitualj<-(((primaryIndParticipationj["0"])+(primaryIndParticipationj["7"]))/n) ## For consistent voters and abstainers#
primaryHabitualj#
#
## Plots#
## par(mfrow=c(2,2))#
## barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
## plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes", col="Red")#
##par(new=T)#
## plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes", col="Blue")#
##par(new=F)#
#
sum(actions)#
primarySumsj[7]#
#
votematrixi<- list(votematrixi, mean(actions))#
habitmatrixi<- list(habitmatrixi, primaryHabitualj)#
#
}
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-10 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  votematrixi<-matrix(nrow=(0), ncol=(0))#
  habitmatrixi<-matrix(nrow=(0), ncol=(0))#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##Primary Election Data#
primaryVoteFramej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primaryVoteSumsj<- colSums(primaryVoteFramej) ## Participation in Primary#
primaryVoteMeansj<- colMeans(primaryVoteFramej) ## Participation Rate#
## primaryVoteMeansj#
nPeriodthPrimaryMeanj<-primaryVoteMeansj[7]#
nPeriodthPrimaryMeanj#
#
primaryIndVotesj<-rowSums(primaryVoteFramej) ## Individual Participation by number of votes#
primaryIndParticipationj<-table(primaryIndVotesj) ## Summary of number of times respondents voted (mode)#
primaryIndParticipationj#
## barplot(primaryIndParticipationj, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
electionsj<-c(1:nPeriods)#
## meanparticipationj<-(voteRts+voteDts)/2 ## For each of nPeriods#
#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## Voting rate for last election only#
#
##Habitual Voting Behavior#
primaryHabitualj<-(((primaryIndParticipationj["0"])+(primaryIndParticipationj["7"]))/n) ## For consistent voters and abstainers#
primaryHabitualj#
#
## Plots#
## par(mfrow=c(2,2))#
## barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
## plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes", col="Red")#
##par(new=T)#
## plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes", col="Blue")#
##par(new=F)#
#
sum(actions)#
primaryVoteSumsj[7]#
#
votematrixi<- list(votematrixi, mean(actions))#
habitmatrixi<- list(habitmatrixi, primaryHabitualj)#
#
}
votematrixi
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-10 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
votematrixi<-matrix(nrow=(0), ncol=(0))#
habitmatrixi<-matrix(nrow=(0), ncol=(0))#
#
for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
##Primary Election Data#
primaryVoteFramej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primaryVoteSumsj<- colSums(primaryVoteFramej) ## Participation in Primary#
primaryVoteMeansj<- colMeans(primaryVoteFramej) ## Participation Rate#
## primaryVoteMeansj#
nPeriodthPrimaryMeanj<-primaryVoteMeansj[7]#
nPeriodthPrimaryMeanj#
#
primaryIndVotesj<-rowSums(primaryVoteFramej) ## Individual Participation by number of votes#
primaryIndParticipationj<-table(primaryIndVotesj) ## Summary of number of times respondents voted (mode)#
primaryIndParticipationj#
## barplot(primaryIndParticipationj, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
electionsj<-c(1:nPeriods)#
## meanparticipationj<-(voteRts+voteDts)/2 ## For each of nPeriods#
#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## Voting rate for last election only#
#
##Habitual Voting Behavior#
primaryHabitualj<-(((primaryIndParticipationj["0"])+(primaryIndParticipationj["7"]))/n) ## For consistent voters and abstainers#
primaryHabitualj#
#
## Plots#
## par(mfrow=c(2,2))#
## barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
## plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes", col="Red")#
##par(new=T)#
## plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes", col="Blue")#
##par(new=F)#
#
sum(actions)#
primaryVoteSumsj[7]#
#
votematrixi<- list(votematrixi, mean(actions))#
habitmatrixi<- list(habitmatrixi, primaryHabitualj)#
#
}
votematrixi
habitmatrixi
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-10 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
votematrixi<-matrix(nrow=(0), ncol=(0))#
habitmatrixi<-matrix(nrow=(0), ncol=(0))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
#
## This section is for inner J loop only #
##Primary Election Data for j Periods#
primaryVoteFramej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primaryVoteSumsj<- colSums(primaryVoteFramej) ## Participation in Primary#
primaryVoteMeansj<- colMeans(primaryVoteFramej) ## Participation Rate#
## primaryVoteMeansj#
nPeriodthPrimaryMeanj<-primaryVoteMeansj[7]#
nPeriodthPrimaryMeanj#
#
primaryIndVotesj<-rowSums(primaryVoteFramej) ## Individual Participation by number of votes#
primaryIndParticipationj<-table(primaryIndVotesj) ## Summary of number of times respondents voted (mode)#
primaryIndParticipationj#
## barplot(primaryIndParticipationj, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
electionsj<-c(1:nPeriods)#
## meanparticipationj<-(voteRts+voteDts)/2 ## For each of nPeriods#
#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## Voting rate for last election only#
#
##Habitual Voting Behavior#
primaryHabitualj<-(((primaryIndParticipationj["0"])+(primaryIndParticipationj["7"]))/n) ## For consistent voters and abstainers#
primaryHabitualj#
#
## Plots#
## par(mfrow=c(2,2))#
## barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
## plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes", col="Red")#
##par(new=T)#
## plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes", col="Blue")#
##par(new=F)#
#
sum(actions)#
primaryVoteSumsj[7]#
#
votematrixi<- list(votematrixi, mean(actions))#
habitmatrixi<- list(habitmatrixi, primaryHabitualj)#
#
## }
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-10 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
votematrixi<-matrix(nrow=(0), ncol=(0))#
habitmatrixi<-matrix(nrow=(0), ncol=(0))#
#
for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
#
## This section is for inner J loop only #
##Primary Election Data for j Periods#
primaryVoteFramej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primaryVoteSumsj<- colSums(primaryVoteFramej) ## Participation in Primary#
primaryVoteMeansj<- colMeans(primaryVoteFramej) ## Participation Rate#
## primaryVoteMeansj#
nPeriodthPrimaryMeanj<-primaryVoteMeansj[7]#
nPeriodthPrimaryMeanj#
#
primaryIndVotesj<-rowSums(primaryVoteFramej) ## Individual Participation by number of votes#
primaryIndParticipationj<-table(primaryIndVotesj) ## Summary of number of times respondents voted (mode)#
primaryIndParticipationj#
## barplot(primaryIndParticipationj, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
electionsj<-c(1:nPeriods)#
## meanparticipationj<-(voteRts+voteDts)/2 ## For each of nPeriods#
#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## Voting rate for last election only#
#
##Habitual Voting Behavior#
primaryHabitualj<-(((primaryIndParticipationj["0"])+(primaryIndParticipationj["7"]))/n) ## For consistent voters and abstainers#
primaryHabitualj#
#
## Plots#
## par(mfrow=c(2,2))#
## barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
## plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes", col="Red")#
##par(new=T)#
## plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes", col="Blue")#
##par(new=F)#
#
sum(actions)#
primaryVoteSumsj[7]#
#
votematrixi<- list(votematrixi, mean(actions))#
habitmatrixi<- list(habitmatrixi, primaryHabitualj)#
#
}#
#
primaryVoteFramei <- data.frame(matrix(unlist(list(votematrixi)), nrow=n, byrow=FALSE))  ## Extracts data from matrix
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-10 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
votematrixi<-matrix(nrow=(0), ncol=(0))#
habitmatrixi<-matrix(nrow=(0), ncol=(0))#
#
for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
#
## This section is for inner J loop only #
##Primary Election Data for j Periods#
primaryVoteFramej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primaryVoteSumsj<- colSums(primaryVoteFramej) ## Participation in Primary#
primaryVoteMeansj<- colMeans(primaryVoteFramej) ## Participation Rate#
## primaryVoteMeansj#
nPeriodthPrimaryMeanj<-primaryVoteMeansj[7]#
nPeriodthPrimaryMeanj#
#
primaryIndVotesj<-rowSums(primaryVoteFramej) ## Individual Participation by number of votes#
primaryIndParticipationj<-table(primaryIndVotesj) ## Summary of number of times respondents voted (mode)#
primaryIndParticipationj#
## barplot(primaryIndParticipationj, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
electionsj<-c(1:nPeriods)#
## meanparticipationj<-(voteRts+voteDts)/2 ## For each of nPeriods#
#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## Voting rate for last election only#
#
##Habitual Voting Behavior#
primaryHabitualj<-(((primaryIndParticipationj["0"])+(primaryIndParticipationj["7"]))/n) ## For consistent voters and abstainers#
primaryHabitualj#
#
## Plots#
## par(mfrow=c(2,2))#
## barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
## plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes", col="Red")#
##par(new=T)#
## plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes", col="Blue")#
##par(new=F)#
#
sum(actions)#
primaryVoteSumsj[7]#
#
votematrixi<- list(votematrixi, mean(actions))#
habitmatrixi<- list(habitmatrixi, primaryHabitualj)#
#
}#
#
primaryVoteFramei <- data.frame(matrix(unlist(list(votematrixi)), nrow=nSims, byrow=FALSE))  ## Extracts data from matrix
primaryVoteFramei
colSums(primaryVoteFramei)
colMeans(primaryVoteFramei)
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-10 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
votematrixi<-matrix(nrow=(0), ncol=(0))#
habitmatrixi<-matrix(nrow=(0), ncol=(0))#
#
for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
#
## This section is for inner J loop only #
##Primary Election Data for j Periods#
primaryVoteFramej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primaryVoteSumsj<- colSums(primaryVoteFramej) ## Participation in Primary#
primaryVoteMeansj<- colMeans(primaryVoteFramej) ## Participation Rate#
## primaryVoteMeansj#
nPeriodthPrimaryMeanj<-primaryVoteMeansj[7]#
nPeriodthPrimaryMeanj#
#
primaryIndVotesj<-rowSums(primaryVoteFramej) ## Individual Participation by number of votes#
primaryIndParticipationj<-table(primaryIndVotesj) ## Summary of number of times respondents voted (mode)#
primaryIndParticipationj#
## barplot(primaryIndParticipationj, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
electionsj<-c(1:nPeriods)#
## meanparticipationj<-(voteRts+voteDts)/2 ## For each of nPeriods#
#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## Voting rate for last election only#
#
##Habitual Voting Behavior#
primaryHabitualj<-(((primaryIndParticipationj["0"])+(primaryIndParticipationj["7"]))/n) ## For consistent voters and abstainers#
primaryHabitualj#
#
## Plots#
## par(mfrow=c(2,2))#
## barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
## plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes", col="Red")#
##par(new=T)#
## plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes", col="Blue")#
##par(new=F)#
#
sum(actions)#
primaryVoteSumsj[7]#
#
votematrixi<- list(votematrixi, mean(actions))#
habitmatrixi<- list(habitmatrixi, primaryHabitualj)#
#
}#
#
primaryVoteFramei <- data.frame(matrix(unlist(list(votematrixi)), nrow=nSims, byrow=FALSE))  ## Extracts data from matrix#
primaryVoteMeansi<-colMeans(primaryVoteFramei) ## Vote Mean for nSims#
primaryVoteMeansi
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-10 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
votematrixi<-matrix(nrow=(0), ncol=(0))#
habitmatrixi<-matrix(nrow=(0), ncol=(0))#
#
for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
#
## This section is for inner J loop only #
##Primary Election Data for j Periods#
primaryVoteFramej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primaryVoteSumsj<- colSums(primaryVoteFramej) ## Participation in Primary#
primaryVoteMeansj<- colMeans(primaryVoteFramej) ## Participation Rate#
## primaryVoteMeansj#
nPeriodthPrimaryMeanj<-primaryVoteMeansj[7]#
nPeriodthPrimaryMeanj#
#
primaryIndVotesj<-rowSums(primaryVoteFramej) ## Individual Participation by number of votes#
primaryIndParticipationj<-table(primaryIndVotesj) ## Summary of number of times respondents voted (mode)#
primaryIndParticipationj#
## barplot(primaryIndParticipationj, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
electionsj<-c(1:nPeriods)#
## meanparticipationj<-(voteRts+voteDts)/2 ## For each of nPeriods#
#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## Voting rate for last election only#
#
##Habitual Voting Behavior#
primaryHabitualj<-(((primaryIndParticipationj["0"])+(primaryIndParticipationj["7"]))/n) ## For consistent voters and abstainers#
primaryHabitualj#
#
## Plots#
## par(mfrow=c(2,2))#
## barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
## plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes", col="Red")#
##par(new=T)#
## plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes", col="Blue")#
##par(new=F)#
#
sum(actions)#
primaryVoteSumsj[7]#
#
votematrixi<- list(votematrixi, actions)#
habitmatrixi<- list(habitmatrixi, primaryHabitualj)#
#
}#
#
primaryVoteFramei <- data.frame(matrix(unlist(list(votematrixi)), nrow=nSims, byrow=FALSE))  ## Extracts data from matrix#
primaryVoteMeansi<-colMeans(primaryVoteFramei) ## Vote Mean for nSims#
primaryVoteMeansi
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-10 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
votematrixi<-matrix(nrow=(0), ncol=(0))#
habitmatrixi<-matrix(nrow=(0), ncol=(0))#
#
for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
#
## This section is for inner J loop only #
##Primary Election Data for j Periods#
primaryVoteFramej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primaryVoteSumsj<- colSums(primaryVoteFramej) ## Participation in Primary#
primaryVoteMeansj<- colMeans(primaryVoteFramej) ## Participation Rate#
## primaryVoteMeansj#
nPeriodthPrimaryMeanj<-primaryVoteMeansj[7]#
nPeriodthPrimaryMeanj#
#
primaryIndVotesj<-rowSums(primaryVoteFramej) ## Individual Participation by number of votes#
primaryIndParticipationj<-table(primaryIndVotesj) ## Summary of number of times respondents voted (mode)#
primaryIndParticipationj#
## barplot(primaryIndParticipationj, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
electionsj<-c(1:nPeriods)#
## meanparticipationj<-(voteRts+voteDts)/2 ## For each of nPeriods#
#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## Voting rate for last election only#
#
##Habitual Voting Behavior#
primaryHabitualj<-(((primaryIndParticipationj["0"])+(primaryIndParticipationj["7"]))/n) ## For consistent voters and abstainers#
primaryHabitualj#
#
## Plots#
## par(mfrow=c(2,2))#
## barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
## plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes", col="Red")#
##par(new=T)#
## plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes", col="Blue")#
##par(new=F)#
#
sum(actions)#
primaryVoteSumsj[7]#
#
votematrixi<- list(votematrixi, actions)#
habitmatrixi<- list(habitmatrixi, primaryHabitualj)#
#
}#
#
primaryVoteFramei <- data.frame(matrix(unlist(list(votematrixi)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primaryVoteMeansi<-colMeans(primaryVoteFramei) ## Vote Mean for nSims#
primaryVoteMeansi
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-10 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
votematrixi<-matrix(nrow=(0), ncol=(0))#
habitmatrixi<-matrix(nrow=(0), ncol=(0))#
#
for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
#
## This section is for inner J loop only #
##Primary Election Data for j Periods#
primaryVoteFramej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primaryVoteSumsj<- colSums(primaryVoteFramej) ## Participation in Primary#
primaryVoteMeansj<- colMeans(primaryVoteFramej) ## Participation Rate#
## primaryVoteMeansj#
nPeriodthPrimaryMeanj<-primaryVoteMeansj[7]#
nPeriodthPrimaryMeanj#
#
primaryIndVotesj<-rowSums(primaryVoteFramej) ## Individual Participation by number of votes#
primaryIndParticipationj<-table(primaryIndVotesj) ## Summary of number of times respondents voted (mode)#
primaryIndParticipationj#
## barplot(primaryIndParticipationj, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
electionsj<-c(1:nPeriods)#
## meanparticipationj<-(voteRts+voteDts)/2 ## For each of nPeriods#
#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## Voting rate for last election only#
#
##Habitual Voting Behavior#
primaryHabitualj<-(((primaryIndParticipationj["0"])+(primaryIndParticipationj["7"]))/n) ## For consistent voters and abstainers#
primaryHabitualj#
#
## Plots#
## par(mfrow=c(2,2))#
## barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
## plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes", col="Red")#
##par(new=T)#
## plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes", col="Blue")#
##par(new=F)#
#
sum(actions)#
primaryVoteSumsj[7]#
#
votematrixi<- list(votematrixi, actions)#
habitmatrixi<- list(habitmatrixi, primaryHabitualj)#
#
}#
#
primaryVoteFramei <- data.frame(matrix(unlist(list(votematrixi)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primaryVoteMeansi<-colMeans(primaryVoteFramei) ## Vote Mean for each in nSims#
primaryVoteMeansi#
overallPrimaryMean<-rowMeans(primaryVoteMeansi)
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-10 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
votematrixi<-matrix(nrow=(0), ncol=(0))#
habitmatrixi<-matrix(nrow=(0), ncol=(0))#
#
for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
#
## This section is for inner J loop only #
##Primary Election Data for j Periods#
primaryVoteFramej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primaryVoteSumsj<- colSums(primaryVoteFramej) ## Participation in Primary#
primaryVoteMeansj<- colMeans(primaryVoteFramej) ## Participation Rate#
## primaryVoteMeansj#
nPeriodthPrimaryMeanj<-primaryVoteMeansj[7]#
nPeriodthPrimaryMeanj#
#
primaryIndVotesj<-rowSums(primaryVoteFramej) ## Individual Participation by number of votes#
primaryIndParticipationj<-table(primaryIndVotesj) ## Summary of number of times respondents voted (mode)#
primaryIndParticipationj#
## barplot(primaryIndParticipationj, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
electionsj<-c(1:nPeriods)#
## meanparticipationj<-(voteRts+voteDts)/2 ## For each of nPeriods#
#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## Voting rate for last election only#
#
##Habitual Voting Behavior#
primaryHabitualj<-(((primaryIndParticipationj["0"])+(primaryIndParticipationj["7"]))/n) ## For consistent voters and abstainers#
primaryHabitualj#
#
## Plots#
## par(mfrow=c(2,2))#
## barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
## plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes", col="Red")#
##par(new=T)#
## plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes", col="Blue")#
##par(new=F)#
#
sum(actions)#
primaryVoteSumsj[7]#
#
votematrixi<- list(votematrixi, actions)#
habitmatrixi<- list(habitmatrixi, primaryHabitualj)#
#
}#
#
primaryVoteFramei <- data.frame(matrix(unlist(list(votematrixi)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primaryVoteMeansi<-colMeans(primaryVoteFramei) ## Vote Mean for each in nSims#
primaryVoteMeansi#
overallPrimaryMean<-Mean(primaryVoteMeansi)
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-10 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
votematrixi<-matrix(nrow=(0), ncol=(0))#
habitmatrixi<-matrix(nrow=(0), ncol=(0))#
#
for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
#
## This section is for inner J loop only #
##Primary Election Data for j Periods#
primaryVoteFramej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primaryVoteSumsj<- colSums(primaryVoteFramej) ## Participation in Primary#
primaryVoteMeansj<- colMeans(primaryVoteFramej) ## Participation Rate#
## primaryVoteMeansj#
nPeriodthPrimaryMeanj<-primaryVoteMeansj[7]#
nPeriodthPrimaryMeanj#
#
primaryIndVotesj<-rowSums(primaryVoteFramej) ## Individual Participation by number of votes#
primaryIndParticipationj<-table(primaryIndVotesj) ## Summary of number of times respondents voted (mode)#
primaryIndParticipationj#
## barplot(primaryIndParticipationj, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
electionsj<-c(1:nPeriods)#
## meanparticipationj<-(voteRts+voteDts)/2 ## For each of nPeriods#
#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## Voting rate for last election only#
#
##Habitual Voting Behavior#
primaryHabitualj<-(((primaryIndParticipationj["0"])+(primaryIndParticipationj["7"]))/n) ## For consistent voters and abstainers#
primaryHabitualj#
#
## Plots#
## par(mfrow=c(2,2))#
## barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
## plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes", col="Red")#
##par(new=T)#
## plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes", col="Blue")#
##par(new=F)#
#
sum(actions)#
primaryVoteSumsj[7]#
#
votematrixi<- list(votematrixi, actions)#
habitmatrixi<- list(habitmatrixi, primaryHabitualj)#
#
}#
#
primaryVoteFramei <- data.frame(matrix(unlist(list(votematrixi)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primaryVoteMeansi<-colMeans(primaryVoteFramei) ## Vote Mean for each in nSims#
primaryVoteMeansi#
overallPrimaryMean<-mean(primaryVoteMeansi)
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-10 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
votematrixi<-matrix(nrow=(0), ncol=(0))#
habitmatrixi<-matrix(nrow=(0), ncol=(0))#
#
for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
#
## This section is for inner J loop only #
##Primary Election Data for j Periods#
primaryVoteFramej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primaryVoteSumsj<- colSums(primaryVoteFramej) ## Participation in Primary#
primaryVoteMeansj<- colMeans(primaryVoteFramej) ## Participation Rate#
## primaryVoteMeansj#
nPeriodthPrimaryMeanj<-primaryVoteMeansj[7]#
nPeriodthPrimaryMeanj#
#
primaryIndVotesj<-rowSums(primaryVoteFramej) ## Individual Participation by number of votes#
primaryIndParticipationj<-table(primaryIndVotesj) ## Summary of number of times respondents voted (mode)#
primaryIndParticipationj#
## barplot(primaryIndParticipationj, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
electionsj<-c(1:nPeriods)#
## meanparticipationj<-(voteRts+voteDts)/2 ## For each of nPeriods#
#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## Voting rate for last election only#
#
##Habitual Voting Behavior#
primaryHabitualj<-(((primaryIndParticipationj["0"])+(primaryIndParticipationj["7"]))/n) ## For consistent voters and abstainers#
primaryHabitualj#
#
## Plots#
## par(mfrow=c(2,2))#
## barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
## plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes", col="Red")#
##par(new=T)#
## plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes", col="Blue")#
##par(new=F)#
#
sum(actions)#
primaryVoteSumsj[7]#
#
votematrixi<- list(votematrixi, actions)#
habitmatrixi<- list(habitmatrixi, primaryHabitualj)#
#
}#
#
primaryVoteFramei <- data.frame(matrix(unlist(list(votematrixi)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primaryVoteMeansi<-colMeans(primaryVoteFramei) ## Vote Mean for each in nSims#
primaryVoteMeansi#
overallPrimaryMean<-mean(primaryVoteMeansi)#
overallPrimaryMean
votematrixi
actions
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-10 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
votematrixi<-matrix(nrow=(0), ncol=(0))#
habitmatrixi<-matrix(nrow=(0), ncol=(0))#
#
for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
#
## This section is for inner J loop only #
##Primary Election Data for j Periods#
primaryVoteFramej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primaryVoteSumsj<- colSums(primaryVoteFramej) ## Participation in Primary#
primaryVoteMeansj<- colMeans(primaryVoteFramej) ## Participation Rate#
## primaryVoteMeansj#
nPeriodthPrimaryMeanj<-primaryVoteMeansj[7]#
nPeriodthPrimaryMeanj#
#
primaryIndVotesj<-rowSums(primaryVoteFramej) ## Individual Participation by number of votes#
primaryIndParticipationj<-table(primaryIndVotesj) ## Summary of number of times respondents voted (mode)#
primaryIndParticipationj#
## barplot(primaryIndParticipationj, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
electionsj<-c(1:nPeriods)#
## meanparticipationj<-(voteRts+voteDts)/2 ## For each of nPeriods#
#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## Voting rate for last election only#
#
##Habitual Voting Behavior#
primaryHabitualj<-(((primaryIndParticipationj["0"])+(primaryIndParticipationj["7"]))/n) ## For consistent voters and abstainers#
primaryHabitualj#
#
## Plots#
## par(mfrow=c(2,2))#
## barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
## plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes", col="Red")#
##par(new=T)#
## plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes", col="Blue")#
##par(new=F)#
#
sum(actions)#
primaryVoteSumsj[7]#
#
votematrixi<- list(votematrixi, actions)#
habitmatrixi<- list(habitmatrixi, primaryHabitualj)#
#
}#
#
primaryVoteFramei <- data.frame(matrix(unlist(list(votematrixi)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primaryVoteMeansi<-colMeans(primaryVoteFramei) ## Vote Mean for each in nSims#
primaryVoteMeansi#
overallPrimaryMean<-mean(primaryVoteMeansi) ## Mean for nPeriodth in nSims#
overallPrimaryMean
habitmatrixi
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-10 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
votematrixi<-matrix(nrow=(0), ncol=(0))#
habitmatrixi<-matrix(nrow=(0), ncol=(0))#
#
for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
#
## This section is for inner J loop only #
##Primary Election Data for j Periods#
primaryVoteFramej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primaryVoteSumsj<- colSums(primaryVoteFramej) ## Participation in Primary#
primaryVoteMeansj<- colMeans(primaryVoteFramej) ## Participation Rate#
## primaryVoteMeansj#
nPeriodthPrimaryMeanj<-primaryVoteMeansj[7]#
nPeriodthPrimaryMeanj#
#
primaryIndVotesj<-rowSums(primaryVoteFramej) ## Individual Participation by number of votes#
primaryIndParticipationj<-table(primaryIndVotesj) ## Summary of number of times respondents voted (mode)#
primaryIndParticipationj#
## barplot(primaryIndParticipationj, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
electionsj<-c(1:nPeriods)#
## meanparticipationj<-(voteRts+voteDts)/2 ## For each of nPeriods#
#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## Voting rate for last election only#
#
##Habitual Voting Behavior#
primaryHabitualj<-(((primaryIndParticipationj["0"])+(primaryIndParticipationj["7"]))/n) ## For consistent voters and abstainers#
primaryHabitualj#
#
## Plots#
## par(mfrow=c(2,2))#
## barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
## plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes", col="Red")#
##par(new=T)#
## plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes", col="Blue")#
##par(new=F)#
#
sum(actions)#
primaryVoteSumsj[7]#
#
votematrixi<- list(votematrixi, actions)#
habitmatrixi<- list(habitmatrixi, primaryHabitualj)#
#
}#
#
primaryVoteFramei <- data.frame(matrix(unlist(list(votematrixi)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primaryVoteMeansi<-colMeans(primaryVoteFramei) ## Vote Mean for each in nSims#
primaryVoteMeansi#
overallPrimaryMean<-mean(primaryVoteMeansi) ## Mean for nPeriodth in nSims#
overallPrimaryMean#
#
primaryHabitFramei <- data.frame(matrix(unlist(list(habitmatrixi)), nrow=nSims, byrow=FALSE))  ## Extracts data from matrix
primaryHabitFramei
colMeans(primaryHabitFramei)
ls()
load("/Users/jg/Dropbox/Active USF/698 Genetics/Genetic Research/FowlerRworkspace")
ls()
actions
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-10 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
votematrixi<-matrix(nrow=(0), ncol=(0))#
habitmatrixi<-matrix(nrow=(0), ncol=(0))#
#
for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
#
## This section is for inner J loop only #
##Primary Election Data for j Periods#
primaryVoteFramej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primaryVoteSumsj<- colSums(primaryVoteFramej) ## Participation in Primary#
primaryVoteMeansj<- colMeans(primaryVoteFramej) ## Participation Rate#
## primaryVoteMeansj#
nPeriodthPrimaryMeanj<-primaryVoteMeansj[7]#
nPeriodthPrimaryMeanj#
#
primaryIndVotesj<-rowSums(primaryVoteFramej) ## Individual Participation by number of votes#
primaryIndParticipationj<-table(primaryIndVotesj) ## Summary of number of times respondents voted (mode)#
primaryIndParticipationj#
## barplot(primaryIndParticipationj, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
electionsj<-c(1:nPeriods)#
## meanparticipationj<-(voteRts+voteDts)/2 ## For each of nPeriods#
#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## Voting rate for last election only#
#
##Habitual Voting Behavior#
primaryHabitualj<-(((primaryIndParticipationj["0"])+(primaryIndParticipationj["7"]))/n) ## For consistent voters and abstainers#
primaryHabitualj#
#
## Plots#
## par(mfrow=c(2,2))#
## barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
## plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes", col="Red")#
##par(new=T)#
## plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes", col="Blue")#
##par(new=F)#
#
sum(actions)#
primaryVoteSumsj[7]#
#
votematrixi<- list(votematrixi, actions)#
habitmatrixi<- list(habitmatrixi, primaryHabitualj)#
#
}#
#
primaryVoteFramei <- data.frame(matrix(unlist(list(votematrixi)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primaryVoteMeansi<-colMeans(primaryVoteFramei) ## Vote Mean for each in nSims#
primaryVoteMeansi#
overallPrimaryMean<-mean(primaryVoteMeansi) ## Mean for nPeriodth in nSims#
overallPrimaryMean#
#
primaryHabitFramei <- data.frame(matrix(unlist(list(habitmatrixi)), nrow=nSims, byrow=FALSE))  ## Extracts data from matrix#
overallPrimaryHabitBehavior<- colMeans(primaryHabitFramei) ## Habitual Behavior for nPeriodth in nSims#
overallPrimaryHabitBehavior
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-10 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
votematrixi<-matrix(nrow=(0), ncol=(0))#
habitmatrixi<-matrix(nrow=(0), ncol=(0))#
#
for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
#
## This section is for inner J loop only #
##Primary Election Data for j Periods#
primaryVoteFramej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primaryVoteSumsj<- colSums(primaryVoteFramej) ## Participation in Primary#
primaryVoteMeansj<- colMeans(primaryVoteFramej) ## Participation Rate#
## primaryVoteMeansj#
nPeriodthPrimaryMeanj<-primaryVoteMeansj[7]#
nPeriodthPrimaryMeanj#
#
primaryIndVotesj<-rowSums(primaryVoteFramej) ## Individual Participation by number of votes#
primaryIndParticipationj<-table(primaryIndVotesj) ## Summary of number of times respondents voted (mode)#
primaryIndParticipationj#
## barplot(primaryIndParticipationj, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
electionsj<-c(1:nPeriods)#
## meanparticipationj<-(voteRts+voteDts)/2 ## For each of nPeriods#
#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## Voting rate for last election only#
#
##Habitual Voting Behavior#
primaryHabitualj<-(((primaryIndParticipationj["0"])+(primaryIndParticipationj["7"]))/n) ## For consistent voters and abstainers#
primaryHabitualj#
#
## Plots#
 par(mfrow=c(2,2))#
 barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
 plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes", col="Red")#
##par(new=T)#
 plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes", col="Blue")#
##par(new=F)#
#
sum(actions)#
primaryVoteSumsj[7]#
#
votematrixi<- list(votematrixi, actions)#
habitmatrixi<- list(habitmatrixi, primaryHabitualj)#
#
}#
#
primaryVoteFramei <- data.frame(matrix(unlist(list(votematrixi)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primaryVoteMeansi<-colMeans(primaryVoteFramei) ## Vote Mean for each in nSims#
primaryVoteMeansi#
overallPrimaryMean<-mean(primaryVoteMeansi) ## Mean for nPeriodth in nSims#
overallPrimaryMean#
#
primaryHabitFramei <- data.frame(matrix(unlist(list(habitmatrixi)), nrow=nSims, byrow=FALSE))  ## Extracts data from matrix#
overallPrimaryHabitBehavior<- colMeans(primaryHabitFramei) ## Habitual Behavior for nPeriodth in nSims#
overallPrimaryHabitBehavior
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-10 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
votematrixi<-matrix(nrow=(0), ncol=(0))#
habitmatrixi<-matrix(nrow=(0), ncol=(0))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
#
## This section is for inner J loop only #
##Primary Election Data for j Periods#
primaryVoteFramej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primaryVoteSumsj<- colSums(primaryVoteFramej) ## Participation in Primary#
primaryVoteMeansj<- colMeans(primaryVoteFramej) ## Participation Rate#
## primaryVoteMeansj#
nPeriodthPrimaryMeanj<-primaryVoteMeansj[7]#
nPeriodthPrimaryMeanj#
#
primaryIndVotesj<-rowSums(primaryVoteFramej) ## Individual Participation by number of votes#
primaryIndParticipationj<-table(primaryIndVotesj) ## Summary of number of times respondents voted (mode)#
primaryIndParticipationj#
## barplot(primaryIndParticipationj, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
electionsj<-c(1:nPeriods)#
## meanparticipationj<-(voteRts+voteDts)/2 ## For each of nPeriods#
#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## Voting rate for last election only#
#
##Habitual Voting Behavior#
primaryHabitualj<-(((primaryIndParticipationj["0"])+(primaryIndParticipationj["7"]))/n) ## For consistent voters and abstainers#
primaryHabitualj#
#
## Plots#
 par(mfrow=c(2,2))#
 barplot(primaryparticipation, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
 plot(elections, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes", col="Red")#
##par(new=T)#
 plot(elections, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes", col="Blue")#
##par(new=F)#
#
sum(actions)#
primaryVoteSumsj[7]#
#
votematrixi<- list(votematrixi, actions)#
habitmatrixi<- list(habitmatrixi, primaryHabitualj)#
#
##}#
#
primaryVoteFramei <- data.frame(matrix(unlist(list(votematrixi)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primaryVoteMeansi<-colMeans(primaryVoteFramei) ## Vote Mean for each in nSims#
primaryVoteMeansi#
overallPrimaryMean<-mean(primaryVoteMeansi) ## Mean for nPeriodth in nSims#
overallPrimaryMean#
#
primaryHabitFramei <- data.frame(matrix(unlist(list(habitmatrixi)), nrow=nSims, byrow=FALSE))  ## Extracts data from matrix#
overallPrimaryHabitBehavior<- colMeans(primaryHabitFramei) ## Habitual Behavior for nPeriodth in nSims#
overallPrimaryHabitBehavior
R code for a behavioral model of turnout#
## Jeremy Gilmore#
## Adapted from James Fowler (2003)#
rm(list=ls(all=TRUE))#
#
nPeriods<-1000 ## number of periods#
nSims<-10 ## number of simulations#
#
nDems<- 960 ## number of Democrats#
nReps<-961 ## number of Republicans#
n<-nDems+nReps ## number of citizens#
#
winPayoffD<-1.0 ## Dem payoff for winning#
winPayoffR<-1.0 ## Rep payoff for winning#
#
losePayoffD<-0 ## Dem payoff for winning#
losePayoffR<-0 ## Rep payoff for winning#
#
costD<- 0.25 ## cost to the democrats#
costR<- 0.25 ## cost to the republicans#
#
iaspirationD<- 0.5 ## initial aspiration Dems#
iaspirationR<- 0.5 ## initial aspiration Reps#
#
iturnoutpropensityD<-0.5 ## initial propensity to turnout Dems#
iturnoutpropensityR<-0.5 ## initial propensity to turnout Reps#
#
## auxilary parameters#
#
tau<- 1 ## if 1, use Bush Mosteller rule, if 0, unbiased adjustment#
#
alpha<-0.1  ## propensity update weight for success#
beta<-0.1   ## propensity update weight for failure#
lambda<-0.95 ## weight for aspiration update#
inert<-0.01 ## probability a voter updates propensity or aspiration#
support<-0.2 ## support of random payoff shock#
#
## payoff function#
payofff<-function(winner,preference,cost,action) #
  preference*(winner*winPayoffR+(1-winner)*losePayoffR)+#
  (1-preference)*(winner*losePayoffD+(1-winner)*winPayoffD)-#
  action*cost+round(runif(length(action),-support/2,support/2),3)#
#
## aspiration update function#
aspirationf<-function(aspiration,payoff)#
  ((aspiration>payoff)*floor(1000*(lambda*aspiration+(1-lambda)*payoff))+#
  (aspiration<payoff)*ceiling(1000*(lambda*aspiration+(1-lambda)*payoff)))/1000+#
  (aspiration==payoff)*aspiration#
#
## adjustment for propensities#
  propensityf<-function(propensity,aspiration,action,payoff)#
    pmin(1,pmax(0,((action) *#
     ((payoff>=aspiration)*ceiling(1000*(propensity+alpha*(1-tau*propensity)))+#
      (payoff<aspiration)*floor(1000*(propensity-beta*(1-tau*(1-propensity)))))+#
    (1-action) * #
     ((payoff>=aspiration)*floor(1000*(propensity-alpha*(1-tau*(1-propensity))))+#
      (payoff<aspiration)*ceiling(1000*(propensity+beta*(1-tau*propensity)))))/1000))#
#
## voter preferences#
preferences<-c(rep(0,nDems),rep(1,nReps))#
#
## voter costs#
costs<-c(rep(costD,nDems),rep(costR,nReps))#
#
votematrixi<-matrix(nrow=(0), ncol=(0))#
habitmatrixi<-matrix(nrow=(0), ncol=(0))#
#
##for (i in 1:nSims) {#
#
  ## initial values#
  voteDts<-NULL ## init Dem vote time series#
  voteRts<-NULL ## init Rep vote time series#
  votematrixj<-matrix(nrow=(0), ncol=(0))#
  ## propensity to vote#
  propensities<-c(rep(iturnoutpropensityD,nDems),rep(iturnoutpropensityR,nReps))#
#
  ## voter aspirations#
  aspirations<-c(rep(iaspirationD,nDems),rep(iaspirationR,nReps))#
#
  for (j in 1:nPeriods) {#
#
    ## voters choose whether or not to vote#
    actions<-runif(n,0,1)<propensities #
#
    ## total votes#
    voteD<-sum((1-preferences)*actions)#
    voteR<-sum(preferences*actions)#
    voteDts<-c(voteDts,voteD/nDems)#
    voteRts<-c(voteRts,voteR/nReps)#
	## individual voting habits#
	if(j > nPeriods-7){#
	votematrixj<- list(votematrixj, actions)#
	}#
#
    ## winner determined#
    winner<-(voteR>voteD)+(voteD==voteR)*(runif(1,0,1)>0.5)#
#
    ## voter payoffs#
    payoffs<-payofff(winner,preferences,costs,actions)#
#
    ## set up voter index vector for propensities#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update propensities#
    propensities[noninertials]<-propensityf(propensities[noninertials],#
      aspirations[noninertials],actions[noninertials],payoffs[noninertials])#
#
    ## set up voter index vector for aspirations#
    noninertials<-which(runif(n,0,1)>inert)#
#
    ## update aspirations#
    aspirations[noninertials]<-aspirationf(aspirations[noninertials],#
      payoffs[noninertials])#
  }#
#
## This section is for inner J loop only #
##Primary Election Data for j Periods#
primaryVoteFramej <- data.frame(matrix(unlist(list(votematrixj)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primaryVoteSumsj<- colSums(primaryVoteFramej) ## Participation in Primary#
primaryVoteMeansj<- colMeans(primaryVoteFramej) ## Participation Rate#
## primaryVoteMeansj#
nPeriodthPrimaryMeanj<-primaryVoteMeansj[7]#
nPeriodthPrimaryMeanj#
#
primaryIndVotesj<-rowSums(primaryVoteFramej) ## Individual Participation by number of votes#
primaryIndParticipationj<-table(primaryIndVotesj) ## Summary of number of times respondents voted (mode)#
primaryIndParticipationj#
## barplot(primaryIndParticipationj, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
#
electionsj<-c(1:nPeriods)#
## meanparticipationj<-(voteRts+voteDts)/2 ## For each of nPeriods#
#
voteDts[nPeriods] ## in last period only#
voteRts[nPeriods]#
mean(actions) ## Voting rate for last election only#
#
##Habitual Voting Behavior#
primaryHabitualj<-(((primaryIndParticipationj["0"])+(primaryIndParticipationj["7"]))/n) ## For consistent voters and abstainers#
primaryHabitualj#
#
## Plots#
 par(mfrow=c(2,2))#
 barplot(primaryIndParticipationj, main="BDT Primary Election Participation", xlab="Number of Times Respondents Voted", ylab="Number of Respondents")#
 plot(electionsj, voteRts, cex=.3, xlab="Elections", ylab="Republican Votes", col="Red")#
##par(new=T)#
 plot(electionsj, voteDts, cex=.3, xlab="Elections", ylab="Democratic Votes", col="Blue")#
##par(new=F)#
#
sum(actions)#
primaryVoteSumsj[7]#
#
votematrixi<- list(votematrixi, actions)#
habitmatrixi<- list(habitmatrixi, primaryHabitualj)#
#
##}#
#
primaryVoteFramei <- data.frame(matrix(unlist(list(votematrixi)), nrow=n, byrow=FALSE))  ## Extracts data from matrix#
primaryVoteMeansi<-colMeans(primaryVoteFramei) ## Vote Mean for each in nSims#
primaryVoteMeansi#
overallPrimaryMean<-mean(primaryVoteMeansi) ## Mean for nPeriodth in nSims#
overallPrimaryMean#
#
primaryHabitFramei <- data.frame(matrix(unlist(list(habitmatrixi)), nrow=nSims, byrow=FALSE))  ## Extracts data from matrix#
overallPrimaryHabitBehavior<- colMeans(primaryHabitFramei) ## Habitual Behavior for nPeriodth in nSims#
overallPrimaryHabitBehavior
library(ggplot2)#
library(scales)#
#
##data(economics)#
##View(economics)#
#
scatterplot <- ggplot(economics,#
	aes(x=date, y= psavert)) +#
	geop_point() +#
	ggtitle("US Economic Time Series") +#
	xlab("Year") +#
	ylab("Personal Savings Rate")
library(ggplot2)#
library(scales)#
#
##data(economics)#
##View(economics)#
#
scatterplot <- ggplot(economics,#
	aes(x=date, y= psavert)) +#
	geom_point() +#
	ggtitle("US Economic Time Series") +#
	xlab("Year") +#
	ylab("Personal Savings Rate")
scatterplot
library(ggplot2)#
library(scales)#
#
##data(economics)#
##View(economics)#
#
scatterplot <- ggplot(economics,#
	aes(x=date, y= psavert)) +#
	geom_line() +#
	ggtitle("US Economic Time Series") +#
	xlab("Year") +#
	ylab("Personal Savings Rate")#
#
scatterplot
print(scatterplot)
library(ggplot2)#
library(scales)#
#
##data(economics)#
##View(economics)#
#
scatterplot <- ggplot(economics, aes(x=date, y= psavert)) + ##base#
	geom_line() +#
	ggtitle("US Economic Time Series") +#
	xlab("Year") +#
	ylab("Personal Savings Rate")#
#
print(scatterplot)#
#
help(geom_line)
scatterplot <- ggplot(economics, aes(x=date, y= psavert)) + ##base#
	geom_area() +#
	ggtitle("US Economic Time Series") +#
	xlab("Year") +#
	ylab("Personal Savings Rate")#
#
print(scatterplot)
library(ggplot2)#
library(scales)#
#
##data(economics)#
##View(economics)#
#
economics$year <- + as.POSIXlt(economics$date)$year#
economics$month <- + as.POSIXlt(economics$date)$mon#
#
p <- ggplot(subset(economics, year >= 2003), aes(x=date, y= psavert)) + ##base#
	geom_bar(stat="identity") +#
	ylim(-5,5)#
	ggtitle("US Economic Time Series") +#
	xlab("Year") +#
	ylab("Personal Savings Rate")#
print(p)#
#
##help(geom_line)
library(ggplot2)#
library(scales)#
#
##data(economics)#
##View(economics)#
#
economics$year <- + as.POSIXlt(economics$date)$year#
economics$month <- + as.POSIXlt(economics$date)$mon#
#
p <- ggplot(subset(economics, year >= 2003), aes(x=date, y= psavert)) + ##base#
	geom_bar(stat="identity") +#
	ylim(-5,5) +#
	ggtitle("US Economic Time Series") +#
	xlab("Year") +#
	ylab("Personal Savings Rate")#
print(p)#
#
##help(geom_line)
library(ggplot2)#
library(scales)#
#
##data(economics)#
##View(economics)#
#
economics$year <- 1900 + as.POSIXlt(economics$date)$year#
economics$mon <- 1 + as.POSIXlt(economics$date)$mon#
#
p <- ggplot(subset(economics, year >= 2003), aes(x=date, y= psavert)) + ##base#
	geom_bar(stat="identity") +#
	ylim(-5,5) +#
	ggtitle("US Economic Time Series") +#
	xlab("Year") +#
	ylab("Personal Savings Rate")#
print(p)#
#
##help(geom_line)
library(ggplot2)#
library(scales)#
#
##data(economics)#
##View(economics)#
#
economics$year <- 1900 + as.POSIXlt(economics$date)$year#
economics$mon <- 1 + as.POSIXlt(economics$date)$mon#
#
p <- ggplot(subset(economics, year <= 1990),#
	aes(x=factor(year), y= psavert)) + ##base#
	geom_bar(stat="identity") +#
	ylim(-5,5) +#
	ggtitle("US Economic Time Series") +#
	xlab("Year") +#
	ylab("Personal Savings Rate")#
#
print(p)#
#
##help(geom_line)
library(ggplot2)#
library(scales)#
#
##data(economics)#
##View(economics)#
#
economics$year <- 1900 + as.POSIXlt(economics$date)$year#
economics$mon <- 1 + as.POSIXlt(economics$date)$mon#
#
p <- ggplot(subset(economics, year <= 1990),#
	aes(x=factor(year), y= psavert)) + ##base#
	geom_boxplot() +#
	ylim(-5,5) +#
	ggtitle("US Economic Time Series") +#
	xlab("Year") +#
	ylab("Personal Savings Rate")#
#
print(p)#
#
##help(geom_line)
library(ggplot2)#
library(scales)#
#
##data(economics)#
##View(economics)#
#
economics$year <- 1900 + as.POSIXlt(economics$date)$year ##posix is date object#
economics$month <- 1 + as.POSIXlt(economics$date)$mon#
#
p <- ggplot(subset(economics, year <= 1990),#
	aes(x=factor(year), y= psavert)) + ##base#
	geom_bar(stat="identity") +#
	ylim(-5,5) +#
	ggtitle("US Economic Time Series") +#
	xlab("Year") +#
	ylab("Personal Savings Rate")#
#
print(p)#
#
##help(geom_line)
library(ggplot2)#
library(scales)#
#
##data(economics)#
##View(economics)#
#
economics$year <- 1900 + as.POSIXlt(economics$date)$year ##posix is date object#
economics$month <- 1 + as.POSIXlt(economics$date)$mon#
#
p <- ggplot(subset(economics, year %in% seq(1970, 2010, 5)),#
	aes(x=factor(year), y= psavert)) + ##base#
	geom_line(stat="identity") +#
	ylim(-5,5) +#
	ggtitle("US Economic Time Series") +#
	xlab("Year") +#
	ylab("Personal Savings Rate")#
#
print(p)#
#
##help(geom_line)
library(ggplot2)#
library(scales)#
#
##data(economics)#
##View(economics)#
#
economics$year <- 1900 + as.POSIXlt(economics$date)$year ##posix is date object#
economics$month <- 1 + as.POSIXlt(economics$date)$mon#
#
p <- ggplot(subset(economics, year %in% seq(1970, 2010, 5)),#
	aes(x=factor(month), y= psavert)) + ##base#
	geom_line() +#
	ylim(-5,5) +#
	ggtitle("US Economic Time Series") +#
	xlab("Year") +#
	ylab("Personal Savings Rate")#
#
print(p)#
#
##help(geom_line)
library(ggplot2)#
library(scales)#
#
##data(economics)#
##View(economics)#
#
economics$year <- 1900 + as.POSIXlt(economics$date)$year ##posix is date object#
economics$month <- 1 + as.POSIXlt(economics$date)$mon#
#
p <- ggplot(subset(economics, year %in% seq(1970, 2010, 5)),#
	aes(x=month, y= psavert)) + ##base#
	geom_line() +#
	ylim(-5,5) +#
	ggtitle("US Economic Time Series") +#
	xlab("Year") +#
	ylab("Personal Savings Rate")#
#
print(p)#
#
##help(geom_line)
library(ggplot2)#
library(scales)#
#
##data(economics)#
##View(economics)#
#
economics$year <- 1900 + as.POSIXlt(economics$date)$year ##posix is date object#
economics$month <- 1 + as.POSIXlt(economics$date)$mon#
#
d<-subset(economics, year %in% seq(1970, 2010, 5))#
#
p <- ggplot(d, #
	aes(x=month, y= psavert, #
	group = factor(year),#
	color = factor(year))) + ##base#
	geom_line() +#
	ylim(-5,5) +#
	ggtitle("US Economic Time Series") +#
	xlab("Year") +#
	ylab("Personal Savings Rate")#
#
print(p)#
#
##help(geom_line)
library(ggplot2)#
library(scales)#
#
##data(economics)#
##View(economics)#
#
economics$year <- 1900 + as.POSIXlt(economics$date)$year ##posix is date object#
economics$month <- 1 + as.POSIXlt(economics$date)$mon#
#
d<-subset(economics, year %in% seq(1970, 2010, 5))#
#
p <- ggplot(d, #
	aes(x=month, y= psavert, #
	group = factor(year),#
	color = factor(year))) + ##base#
	geom_line() +#
	ylim(-2,15) +#
	ggtitle("US Economic Time Series") +#
	xlab("Year") +#
	ylab("Personal Savings Rate")#
#
print(p)#
#
##help(geom_line)
library(ggplot2)#
library(scales)#
#
##data(economics)#
##View(economics)#
#
economics$year <- 1900 + as.POSIXlt(economics$date)$year ##posix is date object#
economics$month <- 1 + as.POSIXlt(economics$date)$mon#
#
d<-subset(economics, year %in% seq(1970, 2010, 5))#
#
p <- ggplot(d, #
	aes(x=month, y= psavert, #
	group = factor(year),#
	color = factor(year))) + ##base#
	geom_line() +#
	ylim(-5,15) +#
	ggtitle("US Economic Time Series") +#
	xlab("Year") +#
	ylab("Personal Savings Rate")#
#
print(p)#
#
##help(geom_line)
library(ggplot2)#
library(scales)#
#
##data(economics)#
##View(economics)#
#
economics$year <- 1900 + as.POSIXlt(economics$date)$year ##posix is date object#
economics$month <- 1 + as.POSIXlt(economics$date)$mon#
monthtext<- c("Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec")#
#
d<-subset(economics, year %in% seq(1970, 2010, 5))#
#
p <- ggplot(d, #
	aes(x=month, y= psavert, #
	group = factor(year),#
	color = factor(year))) + ##base#
	geom_line() +#
	ylim(-5,15) +#
	ggtitle("US Economic Time Series") +#
	xlab("Year") +#
	ylab("Personal Savings Rate")#
	scale_x_discrete(labels = monthtext)#
print(p)#
#
##help(geom_line)
library(ggplot2)#
library(scales)#
#
##data(economics)#
##View(economics)#
#
economics$year <- 1900 + as.POSIXlt(economics$date)$year ##posix is date object#
economics$month <- 1 + as.POSIXlt(economics$date)$mon#
monthtext<- c("Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec")#
#
d<-subset(economics, year %in% seq(1970, 2010, 5))#
#
p <- ggplot(d, #
	aes(x=month, y= psavert, #
	group = factor(year),#
	color = factor(year))) + ##base#
	geom_line() +#
	ylim(-5,15) +#
	ggtitle("US Economic Time Series") +#
	xlab("Year") +#
	ylab("Personal Savings Rate") +#
	scale_x_discrete(labels = monthtext) +#
	facet_wrap( ~year, ncol=3)#
#
print(p)#
#
##help(geom_line)
library(ggplot2)#
data(movies)#
data(EuStockMarkets)
movies
MSAN 622#
## Jeremy Gilmore#
## Homework 1#
#
library(ggplot2)#
data(movies)#
data(EuStockMarkets)#
#
## modify data: movies#
movies=movies[!(movies$budget<="0"),]#
genre <- rep(NA, nrow(movies))#
count <- rowSums(movies[, 18:24])#
genre[which(count > 1)] = "Mixed"#
genre[which(count < 1)] = "None"#
genre[which(count == 1 & movies$Action == 1)] = "Action"#
genre[which(count == 1 & movies$Animation == 1)] = "Animation"#
genre[which(count == 1 & movies$Comedy == 1)] = "Comedy"#
genre[which(count == 1 & movies$Drama == 1)] = "Drama"#
genre[which(count == 1 & movies$Documentary == 1)] = "Documentary"#
genre[which(count == 1 & movies$Romance == 1)] = "Romance"#
genre[which(count == 1 & movies$Short == 1)] = "Short"#
#
## modify data: EuStockMarkets#
eu <- transform(data.frame(EuStockMarkets), time = time(EuStockMarkets))
movies
MSAN 622#
## Jeremy Gilmore#
## Homework 1#
#
library(ggplot2)#
data(movies)#
data(EuStockMarkets)#
#
## modify data: movies#
movies=movies[(movies$budget<="0"),]#
##subset(dataframe, )#
genre <- rep(NA, nrow(movies))#
count <- rowSums(movies[, 18:24])#
genre[which(count > 1)] = "Mixed"#
genre[which(count < 1)] = "None"#
genre[which(count == 1 & movies$Action == 1)] = "Action"#
genre[which(count == 1 & movies$Animation == 1)] = "Animation"#
genre[which(count == 1 & movies$Comedy == 1)] = "Comedy"#
genre[which(count == 1 & movies$Drama == 1)] = "Drama"#
genre[which(count == 1 & movies$Documentary == 1)] = "Documentary"#
genre[which(count == 1 & movies$Romance == 1)] = "Romance"#
genre[which(count == 1 & movies$Short == 1)] = "Short"#
#
## modify data: EuStockMarkets#
eu <- transform(data.frame(EuStockMarkets), time = time(EuStockMarkets))
movies
MSAN 622#
## Jeremy Gilmore#
## Homework 1#
#
library(ggplot2)#
data(movies)#
data(EuStockMarkets)#
#
## modify data: movies#
movies=movies[!(movies$budget<=0),]#
##subset(dataframe, )#
genre <- rep(NA, nrow(movies))#
count <- rowSums(movies[, 18:24])#
genre[which(count > 1)] = "Mixed"#
genre[which(count < 1)] = "None"#
genre[which(count == 1 & movies$Action == 1)] = "Action"#
genre[which(count == 1 & movies$Animation == 1)] = "Animation"#
genre[which(count == 1 & movies$Comedy == 1)] = "Comedy"#
genre[which(count == 1 & movies$Drama == 1)] = "Drama"#
genre[which(count == 1 & movies$Documentary == 1)] = "Documentary"#
genre[which(count == 1 & movies$Romance == 1)] = "Romance"#
genre[which(count == 1 & movies$Short == 1)] = "Short"#
#
## modify data: EuStockMarkets#
eu <- transform(data.frame(EuStockMarkets), time = time(EuStockMarkets))
movies
library(ggplot2)#
data(movies)#
data(EuStockMarkets)
movies
movies=movies[!(movies$budget<=0 | movies$budget=="NA"),]
movies
MSAN 622#
## Jeremy Gilmore#
## Homework 1#
#
library(ggplot2)#
data(movies)#
data(EuStockMarkets)#
#
## modify data: movies#
movies=movies[(movies$budget>0),]#
##subset(dataframe, )#
genre <- rep(NA, nrow(movies))#
count <- rowSums(movies[, 18:24])#
genre[which(count > 1)] = "Mixed"#
genre[which(count < 1)] = "None"#
genre[which(count == 1 & movies$Action == 1)] = "Action"#
genre[which(count == 1 & movies$Animation == 1)] = "Animation"#
genre[which(count == 1 & movies$Comedy == 1)] = "Comedy"#
genre[which(count == 1 & movies$Drama == 1)] = "Drama"#
genre[which(count == 1 & movies$Documentary == 1)] = "Documentary"#
genre[which(count == 1 & movies$Romance == 1)] = "Romance"#
genre[which(count == 1 & movies$Short == 1)] = "Short"#
#
## modify data: EuStockMarkets#
eu <- transform(data.frame(EuStockMarkets), time = time(EuStockMarkets))
movies
library(ggplot2)#
data(movies)#
data(EuStockMarkets)
budget
movies$budget
MSAN 622#
## Jeremy Gilmore#
## Homework 1#
#
library(ggplot2)#
data(movies)#
data(EuStockMarkets)#
#
## modify data: movies#
##movies=movies[(movies$budget>0),]#
##subset(dataframe, )#
genre <- rep(NA, nrow(movies))#
count <- rowSums(movies[, 18:24])#
genre[which(count > 1)] = "Mixed"#
genre[which(count < 1)] = "None"#
genre[which(count == 1 & movies$Action == 1)] = "Action"#
genre[which(count == 1 & movies$Animation == 1)] = "Animation"#
genre[which(count == 1 & movies$Comedy == 1)] = "Comedy"#
genre[which(count == 1 & movies$Drama == 1)] = "Drama"#
genre[which(count == 1 & movies$Documentary == 1)] = "Documentary"#
genre[which(count == 1 & movies$Romance == 1)] = "Romance"#
genre[which(count == 1 & movies$Short == 1)] = "Short"#
#
## modify data: EuStockMarkets#
eu <- transform(data.frame(EuStockMarkets), time = time(EuStockMarkets))
budget
library(ggplot2)#
library(shiny)#
#
data("movies", package = "ggplot2")#
#
start <- which(colnames(movies) == "Action")#
#
end <- which (colnames(movies) == "Short")#
#
genres <- colnames(movies)[start:end]#
#
counts <- rep(0, lengeth(genres))#
#
for(i in 1:length(genres)) {#
	counts[i] <- sum(movies[, genres[i]])#
}#
#
df <- data.frame(factor(genres), counts)#
colnames(df) <- c("Genres", "Counts")#
#
p <- ggplot(df, aes(x = Genres, y = Counts, fill = Genres))#
#
p <- p + geom_bar(stat="identity")#
#
print(p)
library(ggplot2)#
library(shiny)#
#
data("movies", package = "ggplot2")#
#
start <- which(colnames(movies) == "Action")#
#
end <- which (colnames(movies) == "Short")#
#
genres <- colnames(movies)[start:end]#
#
counts <- rep(0, length(genres))#
#
for(i in 1:length(genres)) {#
	counts[i] <- sum(movies[, genres[i]])#
}#
#
df <- data.frame(factor(genres), counts)#
colnames(df) <- c("Genres", "Counts")#
#
p <- ggplot(df, aes(x = Genres, y = Counts, fill = Genres))#
#
p <- p + geom_bar(stat="identity")#
#
print(p)
library(ggplot2)#
library(shiny)#
#
data("movies", package = "ggplot2")#
#
start <- which(colnames(movies) == "Action")#
#
end <- which (colnames(movies) == "Short")#
#
genres <- colnames(movies)[start:end]#
#
counts <- rep(0, length(genres))#
#
for(i in 1:length(genres)) {#
	counts[i] <- sum(movies[, genres[i]])#
}#
#
df <- data.frame(factor(genres), counts)#
colnames(df) <- c("Genres", "Counts")#
#
## How to Sort by Bars#
sortOrder <- order(df$Counts, decreasing = FALSE)#
p <- ggplot(df, aes(x = Genres, y = Counts, fill = Genres))#
#
p <- p + geom_bar(stat="identity")#
#
print(p)
library(ggplot2)#
library(shiny)#
#
data("movies", package = "ggplot2")#
#
start <- which(colnames(movies) == "Action")#
#
end <- which (colnames(movies) == "Short")#
#
genres <- colnames(movies)[start:end]#
#
counts <- rep(0, length(genres))#
#
for(i in 1:length(genres)) {#
	counts[i] <- sum(movies[, genres[i]])#
}#
#
df <- data.frame(factor(genres), counts)#
colnames(df) <- c("Genres", "Counts")#
#
## How to Sort by Bars#
sortOrder <- order(df$Counts, decreasing = FALSE)#
df$Genres <- factor(df$Genres[sortOrder])#
#
p <- ggplot(df, aes(x = Genres, y = Counts, fill = Genres))#
#
p <- p + geom_bar(stat="identity")#
#
print(p)
library(ggplot2)#
library(shiny)#
#
data("movies", package = "ggplot2")#
#
start <- which(colnames(movies) == "Action")#
#
end <- which (colnames(movies) == "Short")#
#
genres <- colnames(movies)[start:end]#
#
counts <- rep(0, length(genres))#
#
for(i in 1:length(genres)) {#
	counts[i] <- sum(movies[, genres[i]])#
}#
#
df <- data.frame(factor(genres), counts)#
colnames(df) <- c("Genres", "Counts")#
#
## How to Sort by Bars#
sortOrder <- order(df$Counts, decreasing = FALSE)#
df$Genres <- factor(df$Genres, levels = df$Genres[sortOrder])#
#
p <- ggplot(df, aes(x = Genres, y = Counts, fill = Genres))#
#
p <- p + geom_bar(stat="identity")#
#
print(p)
library(ggplot2)#
library(shiny)#
#
data("movies", package = "ggplot2")#
#
start <- which(colnames(movies) == "Action")#
#
end <- which (colnames(movies) == "Short")#
#
genres <- colnames(movies)[start:end]#
#
counts <- rep(0, length(genres))#
#
for(i in 1:length(genres)) {#
	counts[i] <- sum(movies[, genres[i]])#
}#
#
df <- data.frame(factor(genres), counts)#
colnames(df) <- c("Genres", "Counts")#
#
## How to Sort by Bars#
sortOrder <- order(df$Counts, decreasing = FALSE)#
df$Genres <- factor(df$Genres, levels = df$Genres[sortOrder])#
#
p <- ggplot(df, aes(x = Genres, y = Counts, fill = Genres))#
#
p <- p + geom_bar(stat="identity")#
#
p <- p + xlab("Movie Genre")#
p <- p + ylab("Count in 1000s")#
p <- p + ggtitle("Movies by Genre")#
p <- p + labs(fill = "Movie Genres")#
#
thousand_formatter <- function(x) {#
	label <- x / 1000#
}#
#
p <- p + scale_y_continuous(#
	label = thousand_formatter#
	)#
#
print(p)
library(ggplot2)#
library(shiny)#
#
data("movies", package = "ggplot2")#
#
start <- which(colnames(movies) == "Action")#
#
end <- which (colnames(movies) == "Short")#
#
genres <- colnames(movies)[start:end]#
#
counts <- rep(0, length(genres))#
#
for(i in 1:length(genres)) {#
	counts[i] <- sum(movies[, genres[i]])#
}#
#
df <- data.frame(factor(genres), counts)#
colnames(df) <- c("Genres", "Counts")#
#
## How to Sort by Bars#
sortOrder <- order(df$Counts, decreasing = FALSE)#
df$Genres <- factor(df$Genres, levels = df$Genres[sortOrder])#
#
p <- ggplot(df, aes(x = Genres, y = Counts, fill = Genres))#
#
p <- p + geom_bar(stat="identity")#
#
p <- p + xlab("Movie Genre")#
p <- p + ylab("Count in 1000s")#
p <- p + ggtitle("Movies by Genre")#
p <- p + labs(fill = "Movie Genres")#
#
##thousand_formatter <- function(x) {#
##	label <- x / 1000#
##}#
#
thousand_formatter <- funciton(x) {#
	return(sprintf("%dk", round(x / 1000))) # d is digit, f would be floating#
}#
p <- p + scale_y_continuous(#
	label = thousand_formatter#
	)#
print(p)
library(ggplot2)#
library(shiny)#
#
data("movies", package = "ggplot2")#
#
start <- which(colnames(movies) == "Action")#
#
end <- which (colnames(movies) == "Short")#
#
genres <- colnames(movies)[start:end]#
#
counts <- rep(0, length(genres))#
#
for(i in 1:length(genres)) {#
	counts[i] <- sum(movies[, genres[i]])#
}#
#
df <- data.frame(factor(genres), counts)#
colnames(df) <- c("Genres", "Counts")#
#
## How to Sort by Bars#
sortOrder <- order(df$Counts, decreasing = FALSE)#
df$Genres <- factor(df$Genres, levels = df$Genres[sortOrder])#
#
p <- ggplot(df, aes(x = Genres, y = Counts, fill = Genres))#
#
p <- p + geom_bar(stat="identity")#
#
p <- p + xlab("Movie Genre")#
p <- p + ylab("Count in 1000s")#
p <- p + ggtitle("Movies by Genre")#
p <- p + labs(fill = "Movie Genres")#
#
##thousand_formatter <- function(x) {#
##	label <- x / 1000#
##}#
#
thousand_formatter <- function(x) {#
	return(sprintf("%dk", round(x / 1000))) # d is digit, f would be floating#
}#
p <- p + scale_y_continuous(#
	label = thousand_formatter#
	)#
print(p)
library(ggplot2)#
library(shiny)#
#
data("movies", package = "ggplot2")#
#
start <- which(colnames(movies) == "Action")#
#
end <- which (colnames(movies) == "Short")#
#
genres <- colnames(movies)[start:end]#
#
counts <- rep(0, length(genres))#
#
for(i in 1:length(genres)) {#
	counts[i] <- sum(movies[, genres[i]])#
}#
#
df <- data.frame(factor(genres), counts)#
colnames(df) <- c("Genres", "Counts")#
#
## How to Sort by Bars#
sortOrder <- order(df$Counts, decreasing = FALSE)#
df$Genres <- factor(df$Genres, levels = df$Genres[sortOrder])#
#
p <- ggplot(df, aes(x = Genres, y = Counts, fill = Genres))#
#
p <- p + geom_bar(stat="identity")#
#
p <- p + xlab("Movie Genre")#
p <- p + ylab("Count in 1000s")#
p <- p + ggtitle("Movies by Genre")#
p <- p + labs(fill = "Movie Genres")#
#
##thousand_formatter <- function(x) {#
##	label <- x / 1000#
##}#
#
thousand_formatter <- function(x) {#
	return(sprintf("%dk", round(x / 1000))) # d is digit, f would be floating#
}#
p <- p + scale_y_continuous(#
	expand = c(0,500),#
	label = thousand_formatter#
	)#
print(p)
library(ggplot2)#
library(shiny)#
#
data("movies", package = "ggplot2")#
#
start <- which(colnames(movies) == "Action")#
#
end <- which (colnames(movies) == "Short")#
#
genres <- colnames(movies)[start:end]#
#
counts <- rep(0, length(genres))#
#
for(i in 1:length(genres)) {#
	counts[i] <- sum(movies[, genres[i]])#
}#
#
df <- data.frame(factor(genres), counts)#
colnames(df) <- c("Genres", "Counts")#
#
## How to Sort by Bars#
sortOrder <- order(df$Counts, decreasing = FALSE)#
df$Genres <- factor(df$Genres, levels = df$Genres[sortOrder])#
#
p <- ggplot(df, aes(x = Genres, y = Counts, fill = Genres))#
#
p <- p + geom_bar(stat="identity")#
#
p <- p + xlab("Movie Genre")#
p <- p + ylab("Count in 1000s")#
p <- p + ggtitle("Movies by Genre")#
p <- p + labs(fill = "Movie Genres")#
#
##thousand_formatter <- function(x) {#
##	label <- x / 1000#
##}#
#
thousand_formatter <- function(x) {#
	return(sprintf("%dk", round(x / 1000))) # d is digit, f would be floating#
}#
p <- p + scale_y_continuous(#
	expand = c(0,0),#
	label = thousand_formatter#
	)#
print(p)
library(ggplot2)#
library(shiny)#
#
data("movies", package = "ggplot2")#
#
start <- which(colnames(movies) == "Action")#
#
end <- which (colnames(movies) == "Short")#
#
genres <- colnames(movies)[start:end]#
#
counts <- rep(0, length(genres))#
#
for(i in 1:length(genres)) {#
	counts[i] <- sum(movies[, genres[i]])#
}#
#
df <- data.frame(factor(genres), counts)#
colnames(df) <- c("Genres", "Counts")#
#
## How to Sort by Bars#
sortOrder <- order(df$Counts, decreasing = FALSE)#
df$Genres <- factor(df$Genres, levels = df$Genres[sortOrder])#
#
p <- ggplot(df, aes(x = Genres, y = Counts, fill = Genres))#
#
p <- p + geom_bar(stat="identity")#
#
p <- p + xlab("Movie Genre")#
p <- p + ylab("Count in 1000s")#
p <- p + ggtitle("Movies by Genre")#
p <- p + labs(fill = "Movie Genres")#
#
##thousand_formatter <- function(x) {#
##	label <- x / 1000#
##}#
#
thousand_formatter <- function(x) {#
	return(sprintf("%dk", round(x / 1000))) # d is digit, f would be floating#
}#
p <- p + scale_y_continuous(#
	expand = c(0,20), # removes padding at bottom#
	label = thousand_formatter#
	)#
print(p)
library(ggplot2)#
library(shiny)#
#
data("movies", package = "ggplot2")#
#
start <- which(colnames(movies) == "Action")#
#
end <- which (colnames(movies) == "Short")#
#
genres <- colnames(movies)[start:end]#
#
counts <- rep(0, length(genres))#
#
for(i in 1:length(genres)) {#
	counts[i] <- sum(movies[, genres[i]])#
}#
#
df <- data.frame(factor(genres), counts)#
colnames(df) <- c("Genres", "Counts")#
#
## How to Sort by Bars#
sortOrder <- order(df$Counts, decreasing = FALSE)#
df$Genres <- factor(df$Genres, levels = df$Genres[sortOrder])#
#
p <- ggplot(df, aes(x = Genres, y = Counts, fill = Genres))#
#
p <- p + geom_bar(stat="identity")#
#
p <- p + xlab("Movie Genre")#
p <- p + ylab("Count in 1000s")#
p <- p + ggtitle("Movies by Genre")#
p <- p + labs(fill = "Movie Genres")#
#
##thousand_formatter <- function(x) {#
##	label <- x / 1000#
##}#
#
thousand_formatter <- function(x) {#
	return(sprintf("%dk", round(x / 1000))) # d is digit, f would be floating#
}#
p <- p + scale_y_continuous(#
	expand = c(0,20), # removes padding at bottom#
	label = thousand_formatter#
	)#
#
p <- p + theme(axis.title.x = element())#
print(p)
library(ggplot2)#
library(shiny)#
#
data("movies", package = "ggplot2")#
#
start <- which(colnames(movies) == "Action")#
#
end <- which (colnames(movies) == "Short")#
#
genres <- colnames(movies)[start:end]#
#
counts <- rep(0, length(genres))#
#
for(i in 1:length(genres)) {#
	counts[i] <- sum(movies[, genres[i]])#
}#
#
df <- data.frame(factor(genres), counts)#
colnames(df) <- c("Genres", "Counts")#
#
## How to Sort by Bars#
sortOrder <- order(df$Counts, decreasing = FALSE)#
df$Genres <- factor(df$Genres, levels = df$Genres[sortOrder])#
#
p <- ggplot(df, aes(x = Genres, y = Counts, fill = Genres))#
#
p <- p + geom_bar(stat="identity")#
#
p <- p + xlab("Movie Genre")#
p <- p + ylab("Count in 1000s")#
p <- p + ggtitle("Movies by Genre")#
p <- p + labs(fill = "Movie Genres")#
#
##thousand_formatter <- function(x) {#
##	label <- x / 1000#
##}#
#
thousand_formatter <- function(x) {#
	return(sprintf("%dk", round(x / 1000))) # d is digit, f would be floating#
}#
p <- p + scale_y_continuous(#
	expand = c(0,20), # removes padding at bottom#
	label = thousand_formatter#
	)#
#
p <- p + theme(axis.title.x = element())#
p <- p + theme(axis.title.y = element())#
print(p)
library(ggplot2)#
library(shiny)#
#
data("movies", package = "ggplot2")#
#
start <- which(colnames(movies) == "Action")#
#
end <- which (colnames(movies) == "Short")#
#
genres <- colnames(movies)[start:end]#
#
counts <- rep(0, length(genres))#
#
for(i in 1:length(genres)) {#
	counts[i] <- sum(movies[, genres[i]])#
}#
#
df <- data.frame(factor(genres), counts)#
colnames(df) <- c("Genres", "Counts")#
#
## How to Sort by Bars#
sortOrder <- order(df$Counts, decreasing = FALSE)#
df$Genres <- factor(df$Genres, levels = df$Genres[sortOrder])#
#
p <- ggplot(df, aes(x = Genres, y = Counts, fill = Genres))#
#
p <- p + geom_bar(stat="identity")#
#
p <- p + xlab("Movie Genre")#
p <- p + ylab("Count in 1000s")#
p <- p + ggtitle("Movies by Genre")#
p <- p + labs(fill = "Movie Genres")#
#
##thousand_formatter <- function(x) {#
##	label <- x / 1000#
##}#
#
thousand_formatter <- function(x) {#
	return(sprintf("%dk", round(x / 1000))) # d is digit, f would be floating#
}#
p <- p + scale_y_continuous(#
	expand = c(0,20), # removes padding at bottom#
	label = thousand_formatter#
	)#
#
p <- p + theme(axis.title.x = element_blank())#
p <- p + theme(axis.title.y = element_blank())#
p <- p + theme(legend.position = "none")#
print(p)
library(ggplot2)#
library(shiny)#
#
data("movies", package = "ggplot2")#
#
start <- which(colnames(movies) == "Action")#
#
end <- which (colnames(movies) == "Short")#
#
genres <- colnames(movies)[start:end]#
#
counts <- rep(0, length(genres))#
#
for(i in 1:length(genres)) {#
	counts[i] <- sum(movies[, genres[i]])#
}#
#
df <- data.frame(factor(genres), counts)#
colnames(df) <- c("Genres", "Counts")#
#
## How to Sort by Bars#
sortOrder <- order(df$Counts, decreasing = FALSE)#
df$Genres <- factor(df$Genres, levels = df$Genres[sortOrder])#
#
p <- ggplot(df, aes(x = Genres, y = Counts, fill = Genres))#
#
p <- p + geom_bar(stat="identity")#
#
p <- p + xlab("Movie Genre")#
p <- p + ylab("Count in 1000s")#
p <- p + ggtitle("Movies by Genre")#
p <- p + labs(fill = "Movie Genres")#
#
##thousand_formatter <- function(x) {#
##	label <- x / 1000#
##}#
#
thousand_formatter <- function(x) {#
	return(sprintf("%dk", round(x / 1000))) # d is digit, f would be floating#
}#
p <- p + scale_y_continuous(#
	expand = c(0,20), # removes padding at bottom#
	label = thousand_formatter#
	)#
#
p <- p + theme(axis.title.x = element_blank())#
p <- p + theme(axis.title.y = element_blank())#
p <- p + theme(legend.position = "none")#
p <- p + theme(axis.ticks.x = element_blank())#
print(p)
library(ggplot2)#
library(shiny)#
#
data("movies", package = "ggplot2")#
#
start <- which(colnames(movies) == "Action")#
#
end <- which (colnames(movies) == "Short")#
#
genres <- colnames(movies)[start:end]#
#
counts <- rep(0, length(genres))#
#
for(i in 1:length(genres)) {#
	counts[i] <- sum(movies[, genres[i]])#
}#
#
df <- data.frame(factor(genres), counts)#
colnames(df) <- c("Genres", "Counts")#
#
## How to Sort by Bars#
sortOrder <- order(df$Counts, decreasing = FALSE)#
df$Genres <- factor(df$Genres, levels = df$Genres[sortOrder])#
#
p <- ggplot(df, aes(x = Genres, y = Counts, fill = Genres))#
#
p <- p + geom_bar(stat="identity")#
#
p <- p + xlab("Movie Genre")#
p <- p + ylab("Count in 1000s")#
p <- p + ggtitle("Movies by Genre")#
p <- p + labs(fill = "Movie Genres")#
#
##thousand_formatter <- function(x) {#
##	label <- x / 1000#
##}#
#
thousand_formatter <- function(x) {#
	return(sprintf("%dk", round(x / 1000))) # d is digit, f would be floating#
}#
p <- p + scale_y_continuous(#
	expand = c(0,20), # removes padding at bottom#
	label = thousand_formatter#
	)#
#
p <- p + theme(axis.title.x = element_blank())#
p <- p + theme(axis.title.y = element_blank())#
p <- p + theme(legend.position = "none")#
p <- p + theme(axis.ticks.x = element_blank())#
p <- p + theme(panel.grid.major.x = element_blank())#
print(p)
library(ggplot2)#
library(shiny)#
#
data("movies", package = "ggplot2")#
#
start <- which(colnames(movies) == "Action")#
#
end <- which (colnames(movies) == "Short")#
#
genres <- colnames(movies)[start:end]#
#
counts <- rep(0, length(genres))#
#
for(i in 1:length(genres)) {#
	counts[i] <- sum(movies[, genres[i]])#
}#
#
df <- data.frame(factor(genres), counts)#
colnames(df) <- c("Genres", "Counts")#
#
## How to Sort by Bars#
sortOrder <- order(df$Counts, decreasing = FALSE)#
df$Genres <- factor(df$Genres, levels = df$Genres[sortOrder])#
#
p <- ggplot(df, aes(x = Genres, y = Counts, fill = Genres))#
#
p <- p + geom_bar(stat="identity")#
#
p <- p + xlab("Movie Genre")#
p <- p + ylab("Count in 1000s")#
p <- p + ggtitle("Movies by Genre")#
p <- p + labs(fill = "Movie Genres")#
#
##thousand_formatter <- function(x) {#
##	label <- x / 1000#
##}#
#
thousand_formatter <- function(x) {#
	return(sprintf("%dk", round(x / 1000))) # d is digit, f would be floating#
}#
p <- p + scale_y_continuous(#
	expand = c(0,20), # removes padding at bottom#
	label = thousand_formatter#
	)#
#
p <- p + theme(axis.title.x = element_blank())#
p <- p + theme(axis.title.y = element_blank())#
p <- p + theme(legend.position = "none")#
p <- p + theme(axis.ticks.x = element_blank())#
p <- p + theme(panel.grid.major.x = element_blank())#
p <- p + theme(panel.grid.minor.y = element_blank())#
print(p)
library(ggplot2)#
library(shiny)#
#
data("movies", package = "ggplot2")#
#
start <- which(colnames(movies) == "Action")#
#
end <- which (colnames(movies) == "Short")#
#
genres <- colnames(movies)[start:end]#
#
counts <- rep(0, length(genres))#
#
for(i in 1:length(genres)) {#
	counts[i] <- sum(movies[, genres[i]])#
}#
#
df <- data.frame(factor(genres), counts)#
colnames(df) <- c("Genres", "Counts")#
#
## How to Sort by Bars#
sortOrder <- order(df$Counts, decreasing = FALSE)#
df$Genres <- factor(df$Genres, levels = df$Genres[sortOrder])#
#
p <- ggplot(df, aes(x = Genres, y = Counts, fill = Genres))#
#
p <- p + geom_bar(stat="identity")#
#
p <- p + xlab("Movie Genre")#
p <- p + ylab("Count in 1000s")#
p <- p + ggtitle("Movies by Genre")#
p <- p + labs(fill = "Movie Genres")#
#
##thousand_formatter <- function(x) {#
##	label <- x / 1000#
##}#
#
thousand_formatter <- function(x) {#
	return(sprintf("%dk", round(x / 1000))) # d is digit, f would be floating#
}#
p <- p + scale_y_continuous(#
	expand = c(0,40), # removes padding at bottom#
	label = thousand_formatter#
	)#
#
p <- p + theme(axis.title.x = element_blank())#
p <- p + theme(axis.title.y = element_blank())#
p <- p + theme(legend.position = "none")#
p <- p + theme(axis.ticks.x = element_blank())#
p <- p + theme(panel.grid.major.x = element_blank())#
p <- p + theme(panel.grid.minor.y = element_blank())#
print(p)
library(ggplot2)#
library(shiny)#
#
data("movies", package = "ggplot2")#
#
start <- which(colnames(movies) == "Action")#
#
end <- which (colnames(movies) == "Short")#
#
genres <- colnames(movies)[start:end]#
#
counts <- rep(0, length(genres))#
#
for(i in 1:length(genres)) {#
	counts[i] <- sum(movies[, genres[i]])#
}#
#
df <- data.frame(factor(genres), counts)#
colnames(df) <- c("Genres", "Counts")#
#
## How to Sort by Bars#
sortOrder <- order(df$Counts, decreasing = FALSE)#
df$Genres <- factor(df$Genres, levels = df$Genres[sortOrder])#
#
p <- ggplot(df, aes(x = Genres, y = Counts, fill = Genres))#
#
p <- p + geom_bar(stat="identity")#
#
p <- p + xlab("Movie Genre")#
p <- p + ylab("Count in 1000s")#
p <- p + ggtitle("Movies by Genre")#
p <- p + labs(fill = "Movie Genres")#
#
##thousand_formatter <- function(x) {#
##	label <- x / 1000#
##}#
#
thousand_formatter <- function(x) {#
	return(sprintf("%dk", round(x / 1000))) # d is digit, f would be floating#
}#
p <- p + scale_y_continuous(#
	expand = c(0,500), # removes padding at bottom#
	label = thousand_formatter#
	)#
#
p <- p + theme(axis.title.x = element_blank())#
p <- p + theme(axis.title.y = element_blank())#
p <- p + theme(legend.position = "none")#
p <- p + theme(axis.ticks.x = element_blank())#
p <- p + theme(panel.grid.major.x = element_blank())#
p <- p + theme(panel.grid.minor.y = element_blank())#
p <- p + theme(axis.text.x = element_text(size=12))#
print(p)
library(ggplot2)#
library(shiny)#
#
data("movies", package = "ggplot2")#
#
start <- which(colnames(movies) == "Action")#
#
end <- which (colnames(movies) == "Short")#
#
genres <- colnames(movies)[start:end]#
#
counts <- rep(0, length(genres))#
#
for(i in 1:length(genres)) {#
	counts[i] <- sum(movies[, genres[i]])#
}#
#
df <- data.frame(factor(genres), counts)#
colnames(df) <- c("Genres", "Counts")#
#
## How to Sort by Bars#
sortOrder <- order(df$Counts, decreasing = FALSE)#
df$Genres <- factor(df$Genres, levels = df$Genres[sortOrder])#
#
p <- ggplot(df, aes(x = Genres, y = Counts, fill = Genres))#
#
p <- p + geom_bar(stat="identity")#
#
p <- p + xlab("Movie Genre")#
p <- p + ylab("Count in 1000s")#
p <- p + ggtitle("Movies by Genre")#
p <- p + labs(fill = "Movie Genres")#
#
##thousand_formatter <- function(x) {#
##	label <- x / 1000#
##}#
#
thousand_formatter <- function(x) {#
	return(sprintf("%dk", round(x / 1000))) # d is digit, f would be floating#
}#
p <- p + scale_y_continuous(#
	expand = c(0,200), # removes padding at bottom#
	label = thousand_formatter#
	)#
#
p <- p + theme(axis.title.x = element_blank())#
p <- p + theme(axis.title.y = element_blank())#
p <- p + theme(legend.position = "none")#
p <- p + theme(axis.ticks.x = element_blank())#
p <- p + theme(panel.grid.major.x = element_blank())#
p <- p + theme(panel.grid.minor.y = element_blank())#
p <- p + theme(axis.text.x = element_text(size=12))#
print(p)
library(ggplot2)#
library(shiny)#
#
data("movies", package = "ggplot2")#
#
start <- which(colnames(movies) == "Action")#
#
end <- which (colnames(movies) == "Short")#
#
genres <- colnames(movies)[start:end]#
#
counts <- rep(0, length(genres))#
#
for(i in 1:length(genres)) {#
	counts[i] <- sum(movies[, genres[i]])#
}#
#
df <- data.frame(factor(genres), counts)#
colnames(df) <- c("Genres", "Counts")#
#
## How to Sort by Bars#
sortOrder <- order(df$Counts, decreasing = FALSE)#
df$Genres <- factor(df$Genres, levels = df$Genres[sortOrder])#
#
p <- ggplot(df, aes(x = Genres, y = Counts, fill = Genres))#
#
p <- p + geom_bar(stat="identity")#
#
p <- p + xlab("Movie Genre")#
p <- p + ylab("Count in 1000s")#
p <- p + ggtitle("Movies by Genre")#
p <- p + labs(fill = "Movie Genres")#
#
##thousand_formatter <- function(x) {#
##	label <- x / 1000#
##}#
#
thousand_formatter <- function(x) {#
	return(sprintf("%dk", round(x / 1000))) # d is digit, f would be floating#
}#
p <- p + scale_y_continuous(#
	expand = c(0,200), # removes padding at bottom#
	label = thousand_formatter#
	)#
#
p <- p + theme(axis.title.x = element_blank())#
p <- p + theme(axis.title.y = element_blank())#
p <- p + theme(legend.position = "none")#
p <- p + theme(axis.ticks.x = element_blank())#
p <- p + theme(panel.grid.major.x = element_blank())#
p <- p + theme(panel.grid.minor.y = element_blank())#
p <- p + theme(axis.text.x = element_text(size=12))#
p <- p + scale_color_brewer(type = "qual", palette = "Set3")#
print(p)
library(ggplot2)#
library(shiny)#
#
data("movies", package = "ggplot2")#
#
start <- which(colnames(movies) == "Action")#
#
end <- which (colnames(movies) == "Short")#
#
genres <- colnames(movies)[start:end]#
#
counts <- rep(0, length(genres))#
#
for(i in 1:length(genres)) {#
	counts[i] <- sum(movies[, genres[i]])#
}#
#
df <- data.frame(factor(genres), counts)#
colnames(df) <- c("Genres", "Counts")#
#
## How to Sort by Bars#
sortOrder <- order(df$Counts, decreasing = FALSE)#
df$Genres <- factor(df$Genres, levels = df$Genres[sortOrder])#
#
p <- ggplot(df, aes(x = Genres, y = Counts, fill = Genres))#
#
p <- p + geom_bar(stat="identity")#
#
p <- p + xlab("Movie Genre")#
p <- p + ylab("Count in 1000s")#
p <- p + ggtitle("Movies by Genre")#
p <- p + labs(fill = "Movie Genres")#
#
##thousand_formatter <- function(x) {#
##	label <- x / 1000#
##}#
#
thousand_formatter <- function(x) {#
	return(sprintf("%dk", round(x / 1000))) # d is digit, f would be floating#
}#
p <- p + scale_y_continuous(#
	expand = c(0,200), # removes padding at bottom#
	label = thousand_formatter#
	)#
#
p <- p + theme(axis.title.x = element_blank())#
p <- p + theme(axis.title.y = element_blank())#
p <- p + theme(legend.position = "none")#
p <- p + theme(axis.ticks.x = element_blank())#
p <- p + theme(panel.grid.major.x = element_blank())#
p <- p + theme(panel.grid.minor.y = element_blank())#
p <- p + theme(axis.text.x = element_text(size=12))#
p <- p + scale_fill_brewer(type = "qual", palette = "Set3")#
print(p)
library(ggplot2)#
library(shiny)#
#
data("movies", package = "ggplot2")#
#
start <- which(colnames(movies) == "Action")#
#
end <- which (colnames(movies) == "Short")#
#
genres <- colnames(movies)[start:end]#
#
counts <- rep(0, length(genres))#
#
for(i in 1:length(genres)) {#
	counts[i] <- sum(movies[, genres[i]])#
}#
#
df <- data.frame(factor(genres), counts)#
colnames(df) <- c("Genres", "Counts")#
#
## How to Sort by Bars#
sortOrder <- order(df$Counts, decreasing = FALSE)#
df$Genres <- factor(df$Genres, levels = df$Genres[sortOrder])#
#
p <- ggplot(df, aes(x = Genres, y = Counts, fill = Genres, color = "red"))#
#
p <- p + geom_bar(stat="identity")#
#
p <- p + xlab("Movie Genre")#
p <- p + ylab("Count in 1000s")#
p <- p + ggtitle("Movies by Genre")#
p <- p + labs(fill = "Movie Genres")#
#
##thousand_formatter <- function(x) {#
##	label <- x / 1000#
##}#
#
thousand_formatter <- function(x) {#
	return(sprintf("%dk", round(x / 1000))) # d is digit, f would be floating#
}#
p <- p + scale_y_continuous(#
	expand = c(0,200), # removes padding at bottom#
	label = thousand_formatter#
	)#
#
p <- p + theme(axis.title.x = element_blank())#
p <- p + theme(axis.title.y = element_blank())#
p <- p + theme(legend.position = "none")#
p <- p + theme(axis.ticks.x = element_blank())#
p <- p + theme(panel.grid.major.x = element_blank())#
p <- p + theme(panel.grid.minor.y = element_blank())#
p <- p + theme(axis.text.x = element_text(size=12))#
p <- p + scale_fill_brewer(type = "qual", palette = "Set3")#
#
palette1 <- c("...")#
p <- p + scale_fill_manual(value = "palette1")#
#
p <- p + scale_fill_grey(start = 0.4 end 0.4)#
print(p)
if (!require("devtools"))#
  install.packages("devtools")#
devtools::install_github("shiny", "rstudio")
library()
Server File#
# library(ggplot2)#
# library(shiny)#
#
# shinyServer(function(input, output) {#
	# localFrame <- globalData #copy of global#
	# sortOrder <- reactive({#
		# if (input$sortColumn == "Genre") {#
			# return(#
				# order(localFrame$Genre,#
					# descending = input$sortDescending))#
		# }#
		# else {#
			# return(#
				# )#
		# }#
	# })#
	# output$scatterPlot <- renderPlot({#
		# scatterPlot <- getPlot(localFrame, sortOrder(), ""None"") #getPlot function#
		# print(scatterPlot)#
	# })#
## Jeremy Gilmore#
## MSAN 622#
#
## Homework 2#
#
library(ggplot2)#
library(scales)#
data(movies)#
#
## modify data: movies#
movies=movies[which(!movies$budget<=0 & !movies$mpaa==""),]#
genre <- rep(NA, nrow(movies))#
count <- rowSums(movies[, 18:24])#
genre[which(count > 1)] = "Mixed"#
genre[which(count < 1)] = "None"#
genre[which(count == 1 & movies$Action == 1)] = "Action"#
genre[which(count == 1 & movies$Animation == 1)] = "Animation"#
genre[which(count == 1 & movies$Comedy == 1)] = "Comedy"#
genre[which(count == 1 & movies$Drama == 1)] = "Drama"#
genre[which(count == 1 & movies$Documentary == 1)] = "Documentary"#
genre[which(count == 1 & movies$Romance == 1)] = "Romance"#
genre[which(count == 1 & movies$Short == 1)] = "Short"#
movies$Genre<-genre#
#
million_formatter <- function(x) {#
	#label <- round(x / 1000000)#
	return(sprintf("$%sM", round(x / 1000000)))#
}#
#
getPlot <- function(alphaVal,genreVal,mpaaVal,pointVal,colorScheme) {#
	subMovies <- subset(movies, (movies$Genre %in% genreVal) & (movies$mpaa %in% mpaaVal), c(budget, mpaa, rating))#
	MPAA <- factor(subMovies$mpaa, levels=c("PG", "PG-13", "R", "NC-17"))#
#
	assign("subMovies", subMovies, envir=globalenv())#
	assign("MPAA", MPAA, envir=globalenv())#
	p <- ggplot(subMovies,#
		aes(x= subMovies$budget, y= subMovies$rating,#
		colour=MPAA)) +#
		geom_point(alpha=alphaVal, shape=20, size=pointVal) +#
		scale_y_continuous(breaks=seq(0,10,1), labels=seq(0,10,1)) +#
		scale_x_continuous(label = million_formatter) +#
		theme(legend.position="bottom") +#
		ggtitle("IMDB Movies Data") +#
		xlab("Budget in Millions of USD") +#
		ylab("IMDB Ratings")#
#
	if (colorScheme == "Default") {#
		p <- p#
	}#
	else {#
		p <- p + scale_color_brewer(palette = colorScheme)#
	}#
	return(p)#
}#
shinyServer(function(input, output) {#
	cat("Press \"ESC\" to exit...\n")#
#
	alphaVal <- reactive ({#
		input$alphaVals#
	})#
	genreVal <- reactive ({#
		input$genreVals#
	})#
	mpaaVal <- reactive ({#
		input$mpaaVals#
	})#
	pointVal <- reactive ({#
		input$pointVals#
	})#
	colorScheme <- reactive ({#
		input$colorSchemes#
	})#
#
	output$scatterPlot <- renderPlot ({#
		print(getPlot(alphaVal,genreVal,mpaaVal,pointVal,colorScheme))#
	})#
})
Iris dataset#
#
# Shiny example 3#
#
data("iris")#
#
p <- ggplot(iris, aes(x = Sepal.Length,#
						y = Sepal.Width,#
						color = Species))#
p <- geom_point(size=4)#
print(p)
p <- ggplot(iris, aes(x = Sepal.Length,
Iris dataset#
#
# Shiny example 3#
#
data("iris")#
#
p <- ggplot(iris, aes(x = Sepal.Length,#
						y = Sepal.Width,#
						color = Species))#
p <- geom_point(size=4)#
print(p)
Iris dataset#
#
# Shiny example 3#
#
data("iris")#
#
p <- ggplot(iris, aes(x = Sepal.Length,#
						y = Sepal.Width,#
						color = Species)))#
p <- geom_point(size=4)#
print(p)
Iris dataset#
#
# Shiny example 3#
#
data("iris")#
#
p <- ggplot(iris, aes(x = Sepal.Length,#
						y = Sepal.Width,#
						color = Species))#
p <- geom_point(size=4)#
print(p)
Iris dataset#
#
# Shiny example 3#
#
data("iris")#
#
p <- ggplot(iris, aes(x = Sepal.Length,#
						y = Sepal.Width,#
						color = Species))#
p <- p + geom_point(size=4)#
print(p)
Iris dataset#
#
# Shiny example 3#
library(ggplot2)#
#
data("iris")#
#
p <- ggplot(iris, aes(x = Sepal.Length,#
						y = Sepal.Width,#
						color = Species))#
p <- p + geom_point(size=4)#
print(p)
Jeremy Gilmore#
## MSAN 622#
#
## Homework 2#
#
library(ggplot2)#
library(shiny)#
library(scales)#
data(movies)#
movies=movies[which(!movies$budget<=0 & !movies$mpaa==""),]#
genre <- rep(NA, nrow(movies))#
count <- rowSums(movies[, 18:24])#
genre[which(count > 1)] = "Mixed"#
genre[which(count < 1)] = "None"#
genre[which(count == 1 & movies$Action == 1)] = "Action"#
genre[which(count == 1 & movies$Animation == 1)] = "Animation"#
genre[which(count == 1 & movies$Comedy == 1)] = "Comedy"#
genre[which(count == 1 & movies$Drama == 1)] = "Drama"#
genre[which(count == 1 & movies$Documentary == 1)] = "Documentary"#
genre[which(count == 1 & movies$Romance == 1)] = "Romance"#
genre[which(count == 1 & movies$Short == 1)] = "Short"#
movies$Genre<-genre#
#
million_formatter <- function(x) {#
	#label <- round(x / 1000000)#
	return(sprintf("$%sM", round(x / 1000000)))#
}#
#
getPlot <- function(alphaVal,genreVal,mpaaVal,pointVal,colorScheme) {#
	subMovies <- subset(movies, (movies$Genre %in% genreVal) & (movies$mpaa %in% mpaaVal), c(budget, mpaa, rating))#
	MPAA <- factor(subMovies$mpaa, levels=c("PG", "PG-13", "R", "NC-17"))#
#
	assign("subMovies", subMovies, envir=globalenv())#
	assign("MPAA", MPAA, envir=globalenv())#
	p <- ggplot(subMovies,#
		aes(x= subMovies$budget, y= subMovies$rating,#
		colour=MPAA)) +#
		geom_point(alpha=alphaVal, shape=20, size=pointVal) +#
		scale_y_continuous(breaks=seq(0,10,1), labels=seq(0,10,1)) +#
		scale_x_continuous(label = million_formatter) +#
		theme(legend.position="bottom") +#
		ggtitle("IMDB Movies Data") +#
		xlab("Budget in Millions of USD") +#
		ylab("IMDB Ratings")#
#
	if (colorScheme == "Default") {#
		p <- p#
	}#
	else {#
		p <- p + scale_color_brewer(palette = colorScheme)#
	}#
	return(p)#
}#
#
shinyServer(function(input, output) {#
	cat("Press \"ESC\" to exit...\n")#
#
	mpaaValS <- reactive ({#
		if (input$mpaaVal == "All") {#
			result <- c("PG", "PG-13", "R", "NC-17")#
			return(result)#
		}#
		else {#
			return(input$mpaaVal)#
		}#
	})#
#
	genreValS <- reactive ({#
		if(length(input$genreVal) == 0) {#
			result <- c("Action", "Animation", "Comedy", "Documentary", 					"Drama", "Romance", "Short")#
			return(result)#
		}#
		else {#
			return(input$genreVal)#
		}#
	})#
#
	# mpaaVal <- reactive ({#
		# input$mpaaVals#
	# })#
	# pointVal <- reactive ({#
		# input$pointVals#
	# })#
	# colorScheme <- reactive ({#
		# input$colorSchemes#
	# })#
#
	output$scatterPlot <- renderPlot ({#
		scatterPlot <- getPlot(input$alphaVal, (genreValS()), (mpaaValS()), 			input$pointVal, input$colorScheme)#
		print(scatterPlot)#
	})#
})
runApp()
update.packages(shiny)
update.packages(Shiny)
library()
update.packages("shiny")
library(shiny)
shiny::runGitHub('msan622', 'j-gilmore', 'homework2')
library(ggplot2)#
library(grid)#
#
data("iris")#
#
df <- iris#
#
p <- ggplot(df, aes(#
	x = Sepal.Length#
	y = Sepal.Width#
	color = Species#
	size = Petal.Length#
	))#
#
p <- p + geom_point(alpha = 0.6, position = "jitter")#
p <- p + scale_size_area(max_size=10)#
#
print(p)
library(ggplot2)#
library(grid)#
#
data("iris")#
#
df <- iris#
#
p <- ggplot(df, aes(#
	x = Sepal.Length,#
	y = Sepal.Width,#
	color = Species,#
	size = Petal.Length#
	))#
#
p <- p + geom_point(alpha = 0.6, position = "jitter")#
p <- p + scale_size_area(max_size=10)#
#
print(p)
library(ggplot2)#
library(grid)#
#
data("iris")#
#
df <- iris[(df$Petal.Length, decreasing = TRUE),]#
#
p <- ggplot(df, aes(#
	x = Sepal.Length,#
	y = Sepal.Width,#
	color = Species,#
	size = Petal.Length#
	))#
#
p <- p + geom_point(alpha = 0.6, position = "jitter")#
p <- p + scale_size_area(max_size=10)#
#
print(p)
library(ggplot2)#
library(grid)#
#
data("iris")#
#
df <- iris[(df$Petal.Length, decreasing = TRUE),]#
#
p <- ggplot(df, aes(#
	x = Sepal.Length,#
	y = Sepal.Width,#
	color = Species,#
	size = Petal.Length#
	))#
#
p <- p + geom_point(alpha = 0.6, position = "jitter")#
p <- p + scale_size_area(max_size=10)#
#
p <- p + guides(colour = guide_legend(override.aes = list(size=8)))#
#
print(p)
Melting necessarty for heatmaps#
library(ggplot2)#
library(reshape)#
library(plyr)#
library(scales)#
# Processing Data#
processData <- function(original) {#
	processed <- original#
	colnames(processed) <- gsub("\\.", " ", colnames(processed))#
	processed <- processed[sapply(processed, is.numeric)]#
	processed <- rescaler(processed, type = "range")#
	processed$id <- 1:nrow(original)#
	processed <- melt(processed, "id")#
	processed$id <- factor(processed$id,#
		levels = 1:nrow(original), ordered = TRUE)#
	return(processed)#
}#
# possibly normalize between zero and one#
# data from 1 to 5, and from 1 to 5000 -> normalize#
#
getHeatmap <- function(dataset, midrange) {#
	p <- ggplot(dataset, aes(x = id, y = variable))#
	p <- geom_tile(aes(fill = value))#
	return(p)#
}#
#
melted < processData(iris)#
print(getheatmap(melted, c(0.4, 0.6)))
Melting necessarty for heatmaps#
library(ggplot2)#
library(reshape)#
library(plyr)#
library(scales)#
# Processing Data#
processData <- function(original) {#
	processed <- original#
	colnames(processed) <- gsub("\\.", " ", colnames(processed))#
	processed <- processed[sapply(processed, is.numeric)]#
	processed <- rescaler(processed, type = "range")#
	processed$id <- 1:nrow(original)#
	processed <- melt(processed, "id")#
	processed$id <- factor(processed$id,#
		levels = 1:nrow(original), ordered = TRUE)#
	return(processed)#
}#
# possibly normalize between zero and one#
# data from 1 to 5, and from 1 to 5000 -> normalize#
#
getHeatmap <- function(dataset, midrange) {#
	p <- ggplot(dataset, aes(x = id, y = variable))#
	p <- geom_tile(aes(fill = value))#
	return(p)#
}#
#
melted < processData(iris)#
print(getHeatmap(melted, c(0.4, 0.6)))
Melting necessarty for heatmaps#
library(ggplot2)#
library(reshape)#
library(plyr)#
library(scales)#
# Processing Data#
processData <- function(original) {#
	processed <- original#
	colnames(processed) <- gsub("\\.", " ", colnames(processed))#
	processed <- processed[sapply(processed, is.numeric)]#
	processed <- rescaler(processed, type = "range")#
	processed$id <- 1:nrow(original)#
	processed <- melt(processed, "id")#
	processed$id <- factor(processed$id,#
		levels = 1:nrow(original), ordered = TRUE)#
	return(processed)#
}#
# possibly normalize between zero and one#
# data from 1 to 5, and from 1 to 5000 -> normalize#
#
getHeatmap <- function(dataset, midrange) {#
	p <- ggplot(dataset, aes(x = id, y = variable))#
	p <- geom_tile(aes(fill = value))#
	return(p)#
}#
#
melted < processed(iris)#
print(getHeatmap(melted, c(0.4, 0.6)))
Melting necessarty for heatmaps#
library(ggplot2)#
library(reshape)#
library(plyr)#
library(scales)#
# Processing Data#
processData <- function(original) {#
	processed <- original#
	colnames(processed) <- gsub("\\.", " ", colnames(processed))#
	processed <- processed[sapply(processed, is.numeric)]#
	processed <- rescaler(processed, type = "range")#
	processed$id <- 1:nrow(original)#
	processed <- melt(processed, "id")#
	processed$id <- factor(processed$id,#
		levels = 1:nrow(original), ordered = TRUE)#
	return(processed)#
}#
# possibly normalize between zero and one#
# data from 1 to 5, and from 1 to 5000 -> normalize#
#
getHeatmap <- function(dataset, midrange) {#
	p <- ggplot(dataset, aes(x = id, y = variable))#
	p <- geom_tile(aes(fill = value))#
	return(p)#
}#
#
melted <- processData(iris)#
print(getHeatmap(melted, c(0.4, 0.6)))
if (!require(devtools))#
  install.packages("devtools")#
devtools::install_github("jcheng5/leaflet-shiny")#
shiny::runGitHub("superzip", "jcheng5")
install.packages(dplyr)
library()
?dplyr
??dplyr
install.packages(plyr)
library()
library(plyr)
shiny::runGitHub("superzip", "jcheng5")
library(shiny)
shiny::runGitHub('msan622', 'trevorstephens', subdir='homework2')
library(shiny)
shiny::runGitHub('msan622', 'ashishthakur1296', subdir='homework2')
install.packages("sqldf")
shiny::runGitHub('msan622', 'ashishthakur1296', subdir='homework2')
library(shiny)
shiny::runGitHub('msan622', 'trevorstephens', subdir='homework2')
Jeremy Gilmore#
## MSAN 622#
#
## Homework 3#
#
library(ggplot2)#
library(grid)#
library(shiny)#
library(lattice)#
library(GGally)#
library(reshape2)#
#
setwd("/Users/jg/Documents/DataVis/msan622/Homework3/")#
#
df <- data.frame(state.x77,#
	State = state.name,#
	Abbrev = state.abb,#
	Region = state.region,#
	Division = state.division,#
	Long = state.center$x,#
	Lat = state.center$y#
)#
#
# Add New Variables#
Pop.Density <- (df$Population/df$Area) # to get population density per state#
df$Pop.Density <- Pop.Density#
Pop.Nation <- sum(df$Population)#
StatePercNatPop <- (df$Population/Pop.Nation)#
df$StatePercNatPop <- StatePercNatPop#
df$Illiteracy <- df$Illiteracy/100#
NatIllRate <- (sum((df$Illiteracy/100)*df$Population)/Pop.Nation)#
df$Murder <- df$Murder/100#
NatMurderRate <- mean(df$Murder)#
df$HS.Grad <- df$HS.Grad/100#
NatHSGradRate <- mean(df$HS.Grad)#
#
# Income Variables#
GDP <- (sum((df$Population*df$Income)))#
StateIncome <- df$Population*df$Income#
df$StateIncome <- StateIncome#
DivisionIncome <- rowsum(df$StateIncome, df$Division)#
RegionIncome <- rowsum(df$StateIncome, df$Region)#
df$StateIncGDP <- df$StateIncome/GDP#
#
DivIncGDP <- DivisionIncome/GDP#
RegIncGDP <- RegionIncome/GDP#
#
# Apply Division Income to each row of dataset#
df$DivisionIncome <- rep(NA, nrow(df))#
levelsDivision <- levels(df$Division)#
df$DivisionIncome[which(df$Division == "New England")] = DivisionIncome[1,]#
df$DivisionIncome[which(df$Division == "Middle Atlantic")] = DivisionIncome[2,]#
df$DivisionIncome[which(df$Division == "South Atlantic")] = DivisionIncome[3,]#
df$DivisionIncome[which(df$Division == "East South Central")] = DivisionIncome[4,]#
df$DivisionIncome[which(df$Division == "West South Central")] = DivisionIncome[5,]#
df$DivisionIncome[which(df$Division == "East North Central")] = DivisionIncome[6,]#
df$DivisionIncome[which(df$Division == "West North Central")] = DivisionIncome[7,]#
df$DivisionIncome[which(df$Division == "Mountain")] = DivisionIncome[8,]#
df$DivisionIncome[which(df$Division == "Pacific")] = DivisionIncome[9,]#
#
# Assign Region Income to each row of dataset#
df$RegionIncome <- rep(NA, nrow(df))#
df$RegionIncome[which(df$Region == "Northeast")] = RegionIncome[1,]#
df$RegionIncome[which(df$Region == "South")] = RegionIncome[2,]#
df$RegionIncome[which(df$Region == "North Central")] = RegionIncome[3,]#
df$RegionIncome[which(df$Region == "West")] = RegionIncome[4,]#
#
df$StateIncDiv <- df$StateIncome/df$DivisionIncome#
df$StateIncReg <- df$StateIncome/df$RegionIncome#
#
#for percentage rank#
perc.rank <- function(x) rank(x)/length(x)#
df<- within(df, RankStateIncGDP <- perc.rank(StateIncGDP))#
#
df$id <- rownames(df)#
#
plotFunction <- function(plotType,xVar,yVar,subsetGeog,scale,perc,dataType,dType) {#
	indices <- which(df$RankStateIncGDP >= perc[1]#
					& df$RankStateIncGDP <= perc[2])#
	dfsub <- df[indices,]#
#
	if(plotType=="Bubble") {#
		p <- ggplot(dfsub, aes_string(#
			x = xVar,#
			y = yVar,#
			color = subsetGeog,#
			size = scale#
			))#
		p <- p + geom_point(alpha=0.7, position = "jitter")#
		p <- p + scale_size_area(max_size = 10, guide = "none")#
		p <- p + ggtitle("State.x77 Bubble Plot")#
		p <- p + theme(legend.title = element_blank())#
		p <- p + theme(legend.justification = c(0,0))#
		p <- p + theme(legend.background = element_blank())#
		p <- p + theme(legend.key = element_blank())#
		p <- p + theme(legend.text = element_text(size=14))#
		p <- p + theme(legend.margin = unit(0, "pt"))#
		p <- p + guides(colour = guide_legend(override.aes = list(size = 8)))#
		return(print(p))#
	}#
#
	if(plotType=="Small Multiples") {#
		if(subsetGeog=="Region" & dataType=="statestats") {#
			dfsubsm <- dfsub[,c(3,5,6,7,11,24)]#
			dfsubsm <- melt(dfsubsm, id.vars=c("id", "Region"))#
			smr <- ggplot(dfsubsm, aes(#
				x = value,#
				group = variable,#
				fill = Region)) +#
				geom_density(aes(colour = Region)) +#
				facet_grid(Region ~ variable,#
				scales = "free_x")#
			smr <- smr + theme(legend.position = "none")#
			smr <- smr + theme(axis.title = element_blank())#
			smr <- smr + theme(panel.grid.minor.x = element_blank())#
			smr <- smr + theme(panel.grid.major.x = element_blank())#
			smr <- smr + labs(title = "State.x77 Small Multiples")#
			return(print(smr))#
		}#
		if(subsetGeog=="Region" & dataType=="incomeVars") {#
			dfsubsm <- dfsub[,c(11,15,16,18,22,24)]#
			dfsubsm <- melt(dfsubsm, id.vars=c("id", "Region"))#
			smr <- ggplot(dfsubsm, aes(#
				x = value,#
				group = variable,#
				fill = Region)) +#
				geom_density(aes(colour = Region)) +#
				facet_grid(Region ~ variable,#
				scales = "free_x")#
			smr <- smr + theme(legend.position = "none")#
			smr <- smr + theme(axis.title = element_blank())#
			smr <- smr + theme(panel.grid.minor.x = element_blank())#
			smr <- smr + theme(panel.grid.major.x = element_blank())#
			smr <- smr + labs(title = "State.x77 Small Multiples")#
			return(print(smr))#
		}#
		if(subsetGeog=="Division" & dataType=="statestats") {#
			dfsubsm <- dfsub[,c(3,5,6,7,12,24)]#
			dfsubsm <- melt(dfsubsm, id.vars=c("id", "Division"))#
			smd <- ggplot(dfsubsm, aes(#
				x = value,#
				group = variable,#
				fill = Division)) +#
				geom_density(aes(colour = Division)) +#
				facet_grid(Division ~ variable,#
				scales = "free_x")#
			smd <- smd + theme(legend.position = "none")#
			smd <- smd + theme(axis.title = element_blank())#
			smd <- smd + theme(panel.grid.minor.x = element_blank())#
			smd <- smd + theme(panel.grid.major.x = element_blank())#
			smd <- smd + labs(title = "State.x77 Small Multiples")#
			return(print(smd))#
		}#
		if(subsetGeog=="Division" & dataType=="incomeVars") {#
			dfsubsm <- dfsub[,c(12,15,16,18,22,24)]#
			dfsubsm <- melt(dfsubsm, id.vars=c("id", "Division"))#
			smd <- ggplot(dfsubsm, aes(#
				x = value,#
				group = variable,#
				fill = Division)) +#
				geom_density(aes(colour = Division)) +#
				facet_grid(Division ~ variable,#
				scales = "free_x")#
			smd <- smd + theme(legend.position = "none")#
			smd <- smd + theme(axis.title = element_blank())#
			smd <- smd + theme(panel.grid.minor.x = element_blank())#
			smd <- smd + theme(panel.grid.major.x = element_blank())#
			smd <- smd + labs(title = "State.x77 Small Multiples")#
			return(print(smd))#
		}#
	}#
#
	if(plotType=="Parallel") {#
		if(subsetGeog=="Region" & dType=="sstats") {#
			pplotr <- ggparcoord(data = dfsub,#
				columns = c("Illiteracy", "Murder", "HS.Grad", "Frost"),#
				groupColumn = "Region", # or column number#
				order = "anyClass",#
				showPoints = FALSE,#
				alphaLines = 0.6,#
				shadeBox = NULL,#
				scale = "uniminmax")#
			pplotr <- pplotr + theme_minimal()#
			pplotr <- pplotr + theme(axis.ticks = element_blank())#
			pplotr <- pplotr + theme(axis.title = element_blank())#
			pplotr <- pplotr + theme(axis.text.y = element_blank())#
			pplotr <- pplotr + theme(panel.grid.minor = element_blank())#
			pplotr <- pplotr + theme(panel.grid.major.y = element_blank())#
			pplotr <- pplotr + theme(panel.grid.major.x = element_line(color = 				"#bbbbbb"))#
			pplotr <- pplotr + theme(legend.text = element_text(size=14))#
			pplotr <- pplotr + theme(legend.margin = unit(0, "pt"))#
			pplotr <- pplotr + guides(colour = guide_legend(override.aes = 				list(size = 8)))#
			return(print(pplotr))#
		}#
		if(subsetGeog=="Region" & dType=="incVars") {#
			pplotr <- ggparcoord(data = dfsub,#
				columns = c("Pop.Density", "StatePercNatPop", "StateIncGDP", 				"StateIncReg"),#
				groupColumn = "Region", # or column number#
				order = "anyClass",#
				showPoints = FALSE,#
				alphaLines = 0.6,#
				shadeBox = NULL,#
				scale = "uniminmax")#
			pplotr <- pplotr + theme_minimal()#
			pplotr <- pplotr + theme(axis.ticks = element_blank())#
			pplotr <- pplotr + theme(axis.title = element_blank())#
			pplotr <- pplotr + theme(axis.text.y = element_blank())#
			pplotr <- pplotr + theme(panel.grid.minor = element_blank())#
			pplotr <- pplotr + theme(panel.grid.major.y = element_blank())#
			pplotr <- pplotr + theme(panel.grid.major.x = element_line(color = 				"#bbbbbb"))#
			pplotr <- pplotr + theme(legend.text = element_text(size=14))#
			pplotr <- pplotr + theme(legend.margin = unit(0, "pt"))#
			pplotr <- pplotr + guides(colour = guide_legend(override.aes = 				list(size = 8)))#
#
			return(print(pplotr))#
		}#
		if(subsetGeog=="Division" & dType=="sstats") {#
			pplotr <- ggparcoord(data = dfsub,#
				columns = c("Illiteracy", "Murder", "HS.Grad", "Frost"),#
				groupColumn = "Division", # or column number#
				order = "anyClass",#
				showPoints = FALSE,#
				alphaLines = 0.6,#
				shadeBox = NULL,#
				scale = "uniminmax")#
			pplotr <- pplotr + theme_minimal()#
			pplotr <- pplotr + theme(axis.ticks = element_blank())#
			pplotr <- pplotr + theme(axis.title = element_blank())#
			pplotr <- pplotr + theme(axis.text.y = element_blank())#
			pplotr <- pplotr + theme(panel.grid.minor = element_blank())#
			pplotr <- pplotr + theme(panel.grid.major.y = element_blank())#
			pplotr <- pplotr + theme(panel.grid.major.x = element_line(color = 				"#bbbbbb"))#
			pplotr <- pplotr + theme(legend.text = element_text(size=14))#
			pplotr <- pplotr + theme(legend.margin = unit(0, "pt"))#
			pplotr <- pplotr + guides(colour = guide_legend(override.aes = 				list(size = 8)))#
#
			return(print(pplotr))#
		}#
		if(subsetGeog=="Division" & dType=="incVars") {#
			pplotr <- ggparcoord(data = dfsub,#
				columns = c("Pop.Density", "StatePercNatPop", "StateIncGDP", 				"StateIncReg"),#
				groupColumn = "Division", # or column number#
				order = "anyClass",#
				showPoints = FALSE,#
				alphaLines = 0.6,#
				shadeBox = NULL,#
				scale = "uniminmax")#
			pplotr <- pplotr + theme_minimal()#
			pplotr <- pplotr + theme(axis.ticks = element_blank())#
			pplotr <- pplotr + theme(axis.title = element_blank())#
			pplotr <- pplotr + theme(axis.text.y = element_blank())#
			pplotr <- pplotr + theme(panel.grid.minor = element_blank())#
			pplotr <- pplotr + theme(panel.grid.major.y = element_blank())#
			pplotr <- pplotr + theme(panel.grid.major.x = element_line(color = 				"#bbbbbb"))#
			pplotr <- pplotr + theme(legend.text = element_text(size=14))#
			pplotr <- pplotr + theme(legend.margin = unit(0, "pt"))#
			pplotr <- pplotr + guides(colour = guide_legend(override.aes = 				list(size = 8)))#
#
			return(print(pplotr))#
		}#
	}#
}#
#
shinyServer(function(input, output) {#
	cat("Press \"ESC\" to exit...\n")#
#
	output$ui <- renderUI({#
		if (is.null(input$input_type))#
			return()#
		switch(input$input_type,#
			"Bubble" = fluidRow(#
				column(4,#
					radioButtons("xVar", "X Variable",#
						choices = c("Population" = "Population",#
								"Income" = "Income",#
								"Murder Rate" = "Murder",#
								"Illiteracy Rate" = "Illiteracy",#
								"HS Grad Rate" = "HS.Grad"),#
						selected = "Income"#
					)#
				),#
				column(4,#
					radioButtons("yVar", "Y Variable",#
						choices = c("Population" = "Population",#
									"Income" = "Income",#
									"Murder Rate" = "Murder",#
									"Illiteracy Rate" = "Illiteracy",#
									"HS Grad Rate" = "HS.Grad"),#
						selected = "Illiteracy"#
					)#
				),#
				column(4,#
					radioButtons("scale", "Scale",#
						choices = c("Pop. Density" = "Pop.Density",#
									"State Perc Nat Pop " = "StatePercNatPop",#
									"State Inc. of GDP" = "StateIncGDP"),#
						selected = "Pop.Density"#
					)#
				)#
			),#
			"Small Multiples" = fluidRow(#
				column(6,#
					radioButtons("dataType", "Type of Data",#
						choices = c("State Stats" = "statestats",#
									"Income Variables" = "incomeVars"),#
						selected = "statestats"#
						))#
			),#
			"Parallel" = fluidRow(#
				column(6,#
					radioButtons("dType", "Type of Data",#
						choices = c("State Stats" = "sstats",#
									"Income Variables" = "incVars"),#
						selected = "sstats"#
						))#
			)#
			)#
	})#
#
	getperc <- reactive({#
		return(input$perc)#
	})#
#
	output$plotResults <- renderPlot ({#
		plotResults <- plotFunction(input$input_type, input$xVar, input$yVar, #
		input$subsetGeog, input$scale, getperc(),input$dataType,input$dType)#
		print(plotResults)#
	}, width = 700, height = 600)#
})
runApp()
